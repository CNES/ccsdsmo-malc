<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>MAL - MAL C API</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MAL C API</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Accueil</a>
                    </li>
                
                
                
                    <li >
                        <a href="../tutorial/">Tutoriel</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">APIs MAL <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_attributes/">Attributs</a>
</li>

                        
                            
<li >
    <a href="../mal_encoding/">Encodage</a>
</li>

                        
                            
<li class="active">
    <a href="./">MAL</a>
</li>

                        
                            
<li >
    <a href="../mal_transport/">Transport</a>
</li>

                        
                            
<li >
    <a href="../area/">Area</a>
</li>

                        
                            
<li >
    <a href="../mal_actor/">Actor</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transports <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_czmq/">MAL/CZMQ</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Générateurs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../stub_generator/">Stubs de service</a>
</li>

                        
                            
<li >
    <a href="../malbinary_generator/">MalBinary</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../annexes/">Annexes</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../mal_encoding/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../mal_transport/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#api-mal">API MAL</a></li>
        
            <li><a href="#definitions">Définitions</a></li>
        
            <li><a href="#contexte-mal">Contexte MAL</a></li>
        
            <li><a href="#message-mal">Message MAL</a></li>
        
            <li><a href="#end-point-mal">End-Point MAL</a></li>
        
            <li><a href="#poller-mal">Poller MAL</a></li>
        
            <li><a href="#handler-et-routage">Handler et routage</a></li>
        
            <li><a href="#union-des-elements">Union des éléments</a></li>
        
            <li><a href="#holder-delement">Holder d'élément</a></li>
        
            <li><a href="#listes-dattribut-non-pointeur">Listes d'Attribut non pointeur</a></li>
        
            <li><a href="#listes-dattribut-pointeur">Listes d'Attribut pointeur</a></li>
        
            <li><a href="#listes-de-composite">Listes de Composite</a></li>
        
            <li><a href="#listes-denumere">Listes d'énuméré</a></li>
        
            <li><a href="#etapes-dinteraction">Etapes d'interaction</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="api-mal">API MAL</h1>
<p>L'API MAL permet d'utiliser les concepts de niveau MAL :</p>
<ul>
<li>les concepts définis par la spécification MAL (Blue Book)</li>
<li>les concepts propres à l'API C, définis en section 2</li>
</ul>
<p>L'API MAL contient l'API d'Area générée à partir de la définition de l'Area MAL.</p>
<h2 id="definitions">Définitions</h2>
<pre><code class="c">mal.h
</code></pre>

<h3 id="fonction-virtuelle-de-creation-duri">Fonction virtuelle de création d'URI</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef mal_uri_t *mal_binding_ctx_create_uri_fn(
  void *mal_binding_ctx,
  char *id);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>id</code> : identifiant unique devant être inclus dans l'URI</li>
</ul>
<p>Résultat : </p>
<p>L'URI créée</p>
<h3 id="fonction-virtuelle-de-creation-dun-end-point">Fonction virtuelle de création d'un end-point</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef void *mal_binding_ctx_create_endpoint_fn(
  void *mal_binding_ctx,
  mal_endpoint_t *mal_endpoint);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>mal_endpoint</code> : le end-point MAL correspondant au end-point physique du transport</li>
</ul>
<p>Résultat :</p>
<p>La référence du end-point physique créé (non typée pour éviter la dépendance avec les concepts physiques du transport, par exemple socket ZMQ).</p>
<h3 id="fonction-virtuelle-de-destruction-dun-end-point">Fonction virtuelle de destruction d'un end-point</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef void mal_binding_ctx_destroy_endpoint_fn(
  void *mal_binding_ctx,
  void **endpoint_p);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>endpoint_p</code> : le end-point à détruire</li>
</ul>
<h3 id="fonction-virtuelle-de-creation-dun-poller-mal">Fonction virtuelle de création d'un poller MAL</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef void *mal_binding_ctx_create_poller_fn(
  void *mal_binding_ctx,
  mal_poller_t *mal_poller);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>mal_poller</code> : le poller MAL correspondant au poller physique du transport</li>
</ul>
<p>Résultat : </p>
<p>La référence du poller physique créé (non typée pour éviter la dépendance avec les concepts physiques du transport, par exemple zpoller ZMQ).</p>
<h3 id="fonction-virtuelle-dajout-suppression-dun-end-point-a-un-poller">Fonction virtuelle d'ajout / suppression d'un end-point à un poller</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef int mal_binding_ctx_poller_add_endpoint_fn(
    void *mal_binding_ctx,
    mal_poller_t *mal_poller,
    mal_endpoint_t *mal_endpoint);

typedef int mal_binding_ctx_poller_del_endpoint_fn(
    void *mal_binding_ctx,
    mal_poller_t *mal_poller,
    mal_endpoint_t *mal_endpoint);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>mal_poller</code> : le poller à utiliser</li>
<li><code>mal_endpoint</code> : le end-point à ajouter ou supprimer au poller</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur.</p>
<h3 id="fonction-virtuelle-dattente-de-message-sur-un-poller-mal">Fonction virtuelle d'attente de message sur un poller MAL</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef int mal_binding_ctx_poller_wait_fn(
    void *mal_binding_ctx,
    mal_poller_t *mal_poller,
    mal_endpoint_t **mal_endpoint,
    int timeout);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>mal_poller</code> : le poller sur lequel attendre</li>
<li><code>mal_endpoint</code> : le end-point sur lequel un message est en attente de réception</li>
<li><code>timeout</code> : le temps d'attente maximum, éventuellement infini (-1)</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur.</p>
<h3 id="fonction-virtuelle-de-destruction-dun-poller-mal">Fonction virtuelle de destruction d'un poller MAL</h3>
<p>Déclaration :</p>
<pre><code class="c">typedef void mal_binding_ctx_destroy_poller_fn(
  void *mal_binding_ctx,
  void **poller_p);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>poller_p</code> : le poller à détruire</li>
</ul>
<h3 id="fonction-virtuelle-denvoi-de-message-mal">Fonction virtuelle d'envoi de message MAL</h3>
<p>Cette fonction est appelée par la fonction <code>mal_ctx_send_message</code> (section 7.4.2).</p>
<p>Déclaration :</p>
<pre><code class="c">typedef int mal_binding_ctx_send_message_fn(
    void *mal_binding_ctx,
    mal_endpoint_t *mal_endpoint,
    mal_message_t *message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>mal_endpoint</code> : le end-point qui envoie le message</li>
<li><code>message</code> : message MAL à envoyer</li>
</ul>
<p>Résultat : </p>
<p>code d'erreur</p>
<h3 id="fonction-virtuelle-de-reception-de-message-mal">Fonction virtuelle de réception de message MAL</h3>
<p>Cette fonction est appelée par la fonction <code>mal_ctx_recv_message</code> (section 7.4.3).</p>
<p>Déclaration :</p>
<pre><code class="c">typedef int mal_binding_ctx_recv_message_fn(
  void *mal_binding_ctx,
  mal_endpoint_t *mal_endpoint, mal_message_t **message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>mal_endpoint</code> : le end-point qui reçoit le message</li>
<li><code>message</code> : message MAL reçu</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur</p>
<h3 id="fonction-virtuelle-de-destruction-de-message-mal">Fonction virtuelle de destruction de message MAL</h3>
<p>Permet au transport d'associer des ressources au message MAL (champ <code>body_owner</code>) et de les libérer lors de la destruction du message.</p>
<p>Déclaration :</p>
<pre><code class="c">typedef int mal_binding_ctx_destroy_message_fn(void *mal_binding_ctx,
    mal_message_t *message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_binding_ctx</code> : contexte du transport (binding) utilisé par la couche MAL ; non typé pour permettre à la couche MAL d'utiliser plusieurs transports</li>
<li><code>message</code> : message MAL à détruire</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur</p>
<h2 id="contexte-mal">Contexte MAL</h2>
<pre><code class="c">mal_ctx.h
</code></pre>

<h3 id="constructeur">Constructeur</h3>
<p>Déclaration :</p>
<pre><code class="c">mal_ctx_t *mal_ctx_new(void);
</code></pre>

<p>Résultat : </p>
<p>Le contexte MAL créé</p>
<h3 id="creation-duri">Création d'URI</h3>
<p>Déclaration :</p>
<pre><code class="c">mal_uri_t *mal_ctx_create_uri(mal_ctx_t *self, char *id);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : contexte MAL</li>
<li><code>id</code> : identifiant unique devant être inclus dans l'URI</li>
</ul>
<p>Résultat : </p>
<p>L'URI créée</p>
<h3 id="creation-dun-end-point">Création d'un end-point</h3>
<p>Déclaration :</p>
<pre><code class="c">void *mal_ctx_create_poller(
  mal_ctx_t *self,
  mal_poller_t *poller);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code>  : contexte MAL</li>
<li><code>poller</code> : le poller MAL correspondant au poller physique créé</li>
</ul>
<p>Résultat : </p>
<pre><code>La référence du poller physique créé (non typée pour éviter la dépendance avec les concepts physiques du transport, par exemple zpoller ZMQ).
</code></pre>
<h3 id="creation-dun-poller">Création d'un poller</h3>
<p>Déclaration :</p>
<pre><code class="c">void *mal_ctx_create_endpoint(
  mal_ctx_t *self,
  mal_endpoint_t *endpoint);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : contexte MAL</li>
<li><code>endpoint</code> : le end-point MAL correspondant au end-point physique créé</li>
</ul>
<p>Résultat : </p>
<p>La référence du end-point physique créé (non typée pour éviter la dépendance avec les concepts physiques du transport, par exemple socket ZMQ).</p>
<h3 id="envoi-de-message-mal">Envoi de message MAL</h3>
<p>Cette fonction est appelée par les fonctions d'envoi de message MAL des end-points (section 7.4.2). Elle appelle la fonction virtuelle d'envoi de message offerte par le transport (section 7.1.8).</p>
<p>L'usage de cette fonction est limitée aux end-point MAL.</p>
<p>Déclaration :</p>
<pre><code class="c">int mal_ctx_send_message(
  mal_ctx_t *self,
  mal_endpoint_t *mal_endpoint,
  mal_message_t *message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : contexte MAL</li>
<li><code>mal_endpoint</code> : end-point qui envoie le message</li>
<li><code>message</code> : message MAL à envoyer</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur</p>
<h3 id="reception-de-message-mal">Réception de message MAL</h3>
<p>Cette fonction est appelée par les fonctions de réception de messages MAL des end-points (section 7.4.3). Elle appelle la fonction virtuelle de réception de messages offerte par le transport (section 7.1.9).</p>
<p>L'usage de cette fonction est limitée aux end-point MAL.</p>
<p>Déclaration :</p>
<pre><code class="c">int mal_ctx_recv_message(
  mal_ctx_t *self,
  mal_endpoint_t *mal_endpoint,
  mal_message_t **message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : contexte MAL</li>
<li><code>mal_endpoint</code> : end-point qui recoit le message</li>
<li><code>message</code> : message MAL à envoyer</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur</p>
<h3 id="destructeur">Destructeur</h3>
<p>Détruit le contexte MAL.</p>
<pre><code class="c">    void mal_ctx_destroy(mal_ctx_t **self_p);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self_p</code> : pointeur vers le contexte MAL à détruire</li>
</ul>
<h2 id="message-mal">Message MAL</h2>
<h3 id="constructeur_1">Constructeur</h3>
<p>Alloue la mémoire nécessaire pour le corps de message.</p>
<p>Déclaration :</p>
<pre><code class="c">mal_message_t *mal_message_new(
  mal_blob_t *authentication_id,
  mal_qoslevel_t qoslevel, mal_uinteger_t priority, mal_list_t *domain,
  mal_identifier_t *network_zone, mal_sessiontype_t session,
  mal_identifier_t *session_name, unsigned int body_length);
</code></pre>

<p>Paramètres :</p>
<ul>
<li>Champs du header MAL</li>
<li>Taille du corps de message en octets</li>
</ul>
<h3 id="initialisation">Initialisation</h3>
<p>Initialisation des champs propres à l'opération et à l'étape d'interaction :</p>
<p>Déclaration :</p>
<pre><code class="c">void mal_message_init(mal_message_t *self, mal_ushort_t service_area,
  mal_uoctet_t area_version, mal_ushort_t service,
  mal_ushort_t operation,
  mal_interactiontype_t interaction_type,
  mal_uoctet_t interaction_stage);
</code></pre>

<p>Paramètres :</p>
<ul>
<li>Champs du header MAL</li>
</ul>
<h3 id="destructeur_1">Destructeur</h3>
<p>Détruit le message MAL et le contenu du corps de message.</p>
<p>Appelle la fonction virtuelle de destruction de message MAL offerte par le transport (voir 7.1.10).</p>
<p>Déclaration :</p>
<pre><code class="c">void mal_message_destroy(mal_message_t **self_p, mal_ctx_t *mal_ctx);
</code></pre>

<p>Paramètres :</p>
<ul>
<li>Le message à détruire</li>
<li>Le contexte MAL pour éventuellement libérer des ressources au niveau transport (binding) associées au message</li>
</ul>
<h3 id="getters-et-setters">Getters et setters</h3>
<p>Les champs définis dans le tableau suivant sont accessibles.</p>
<table>
<thead>
<tr>
<th>Champ</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;mal header field&gt;</code></td>
<td><code>&lt;mal header field type&gt;</code></td>
<td>Les champs de header MAL sont décrits dans le livre MAL</td>
</tr>
<tr>
<td><code>free_&lt;header field&gt;</code></td>
<td><code>bool</code></td>
<td>Flags indiquant si les champs de header MAL qui sont de type pointeur doivent être détruits (destroy) lorsque le message MAL est détruit.</td>
</tr>
<tr>
<td><code>body</code></td>
<td><code>char *</code></td>
<td>Corps du message encodé</td>
</tr>
<tr>
<td><code>body_offset</code></td>
<td><code>unsigned int</code></td>
<td>Index de début du corps du message</td>
</tr>
<tr>
<td><code>body_length</code></td>
<td><code>unsigned int</code></td>
<td>Taille du corps de message</td>
</tr>
<tr>
<td><code>body_owner</code></td>
<td><code>void *</code></td>
<td>Ressource associée au message par le transport et devant être libérée lors de la destruction du message</td>
</tr>
</tbody>
</table>
<p>Les flags de présence s'appliquent aux champs suivants : <code>URI To</code>, <code>Authentication Id</code>, <code>URI From</code>, <code>Domain</code>, <code>Network Zone</code>, <code>Session Name</code>.
Par défaut, le comportement est le suivant :</p>
<ul>
<li>si le message MAL a été créé par le constructeur alors le flag est faux : les champs du header sont transmis lors de l'appel au constructeur, ils n'ont donc pas à être libérés</li>
<li>si le message MAL a été créé lors d'un décodage et si les champs de header ont été décodés (non récupérés d'un service de configuration) alors le flag est vrai : les champs du header appartiennent au message et doivent être détruits avec lui</li>
</ul>
<h2 id="end-point-mal">End-Point MAL</h2>
<p>Un end-point ne doit être manipulé que par un unique flot d'exécution.</p>
<h3 id="constructeur_2">Constructeur</h3>
<p>Crée une instance de end-point identifiée par une URI MAL. Un compteur de <code>Transaction Id</code> est géré.</p>
<p>Déclaration :</p>
<pre><code class="c">mal_endpoint_t *mal_endpoint_new(mal_ctx_t *mal_ctx, mal_uri_t *uri);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_ctx</code> : contexte MAL</li>
<li><code>uri</code> : URI MAL identifiant le end-point MAL</li>
</ul>
<p>L'API offre deux fonctions permettant de retrouver l'URI et le contexte MAL correspondant au end-point :</p>
<pre><code class="c">mal_uri_t *mal_endpoint_get_uri(mal_endpoint_t *self);
mal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);
</code></pre>

<h3 id="envoi-de-message-mal_1">Envoi de message MAL</h3>
<p>Deux fonctions d'envoi de message sont définies :</p>
<ul>
<li>une fonction pour l'initiation d'une interaction (première étape). Cette fonction affecte les champs d'URI (l'URI de destination est affectée avec le paramètre <code>uri_to</code> et l'URI source est l'URI du end-point). Si le flag <code>set_tid</code> est égal à True, alors le champ <code>Transaction Id</code> est affecté avec la prochaine valeur du compteur de 'Transaction Id' géré par le end-point MAL. Sinon, la valeur du champ <code>Transaction Id</code> du message fourni n'est pas modifiée.</li>
<li>une fonction pour les étapes de résultat d'une interaction (seconde étape et suivantes). Cette fonction affecte les champs d'URI (<code>URI To</code> est affectée avec la valeur du champ <code>URI From</code> du message d'initiation, et <code>URI From</code> est l'URI du end-point). Le champ <code>Transaction Id</code> est affecté avec la valeur du champ <code>Transaction Id</code> du message d'initiation. Le champ <code>Is Error Message</code> est affecté avec la valeur passée par le paramètre <code>is_error_message</code>.</li>
</ul>
<p>La fonction <code>mal_ctx_send_message</code> (section 7.2.5) est appelée pour envoyer le message MAL.</p>
<p>Déclaration :</p>
<pre><code class="c">int mal_endpoint_init_operation(
  mal_endpoint_t *self,
  mal_message_t *message,
  mal_uri_t *uri_to,
  bool set_tid);

int mal_endpoint_return_operation(
  mal_endpoint_t *self,
  mal_message_t *init_message,
  mal_message_t *message,
  bool is_error_message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : le end-point qui envoie le message</li>
<li><code>message</code> : message résultat de l'interaction (à envoyer)</li>
<li><code>init_message</code> : message qui a initié l'interaction</li>
<li><code>uri_to</code> : l'URI du destinataire du message</li>
<li><code>set_tid</code> : flag indiquant si le champ 'Transaction Id' du message MAL doit être affecté ou non</li>
<li><code>is_error_message</code> : flag indiquant si le message renvoie une erreur</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur</p>
<h3 id="reception-de-message-mal_1">Réception de message MAL</h3>
<p>La fonction <code>mal_endpoint_recv_message</code> permet de recevoir un message sur le end-point, cette fonction est bloquante.</p>
<pre><code class="c">int mal_endpoint_recv_message(
    mal_endpoint_t *self,
    mal_message_t **message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : le end-point qui envoie le message</li>
<li><code>message</code> : le message reçu</li>
</ul>
<p>Résultat : </p>
<p>Code d'erreur</p>
<h3 id="destructeur_2">Destructeur</h3>
<p>Détruit le end-point.</p>
<pre><code class="c">void mal_endpoint_destroy(mal_endpoint_t **self_p);
</code></pre>

<h2 id="poller-mal">Poller MAL</h2>
<p>Un poller ne doit être manipulé que par un unique flot d'exécution.</p>
<h3 id="constructeur_3">Constructeur</h3>
<p>Crée une instance de poller identifiée par une URI MAL.</p>
<p>Déclaration :</p>
<pre><code class="c">    mal_poller_t *mal_poller_new(mal_ctx_t *mal_ctx);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>mal_ctx</code> : contexte MAL</li>
</ul>
<p>L'API offre une fonction permettant de retrouver le contexte MAL correspondant au poller :</p>
<pre><code class="c">mal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);
</code></pre>

<h3 id="ajoutsuppression-de-end-point-mal">Ajout/Suppression de end-point MAL</h3>
<p>Deux fonctions permettent l'ajout et la suppression de end-point au poller.</p>
<p>Déclaration :</p>
<pre><code class="c">int mal_poller_add_endpoint(
    mal_poller_t *self,
    mal_endpoint_t *endpoint);

int mal_poller_del_endpoint(
    mal_poller_t *self,
    mal_endpoint_t *mal_endpoint);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : le poller</li>
<li><code>endpoint</code> : le end-point à ajouter ou supprimer</li>
</ul>
<p>Résultat :</p>
<p>Code d'erreur</p>
<h3 id="attente-de-message-mal">Attente de message MAL</h3>
<p>La fonction mal_poller_wait permet d'attendre la réception d'un message sur l'un des end-points du poller. Cette fonction est bloquante prend en paramètre un time-out.</p>
<pre><code class="c">int mal_poller_wait(
    mal_poller_t *self,
    mal_endpoint_t **endpoint,
    int timeout);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : le poller en attente de message</li>
<li><code>endpoint</code> : le end-point sur lequel un message est arrivé</li>
<li><code>timeout</code> : le temps d'attente maximal, éventuellement infini (-1).</li>
</ul>
<p>Résultat :</p>
<p>Code d'erreur</p>
<h3 id="destructeur_3">Destructeur</h3>
<p>Détruit le poller, les éventuels end-points rattachés doivent être détruits séparément.</p>
<pre><code class="c">    void mal_poller_destroy(mal_oller_t **self_p);
</code></pre>

<h2 id="handler-et-routage">Handler et routage</h2>
<p>Un Handler est une structure logique constituée d'un ensemble de fonctions de traitements de messages MAL, cet ensemble de fonctions dépend de son rôle (provider, consumer, etc.) et de l'interaction dans laquelle il intervient (send, submit, etc.). Les handlers s'exécutent dans le cadre d'une structure de routage (i;e ; un objet de la classe mal_routing, ou routeur).</p>
<p>Le routeur est lié à un end-point MAL, il permet d'enregistrer les handlers correspondants aux différentes interactions attendues, puis lors de la réception d'un message par le end-point d'activer explicitement le handler correspondant pour qu'il traite le message. Le routeur possède un état partagé par l'ensemble des handlers qu'il gère.</p>
<h3 id="handler">Handler</h3>
<p>Chaque fonction de traitement de messages des handlers prend en paramètre l'état du routeur, la référence du contexte MAL, la référence du end-point et le message à traiter. La signature correspondante est définie ci-dessous.</p>
<pre><code class="c">typedef int mal_routing_on_message_fn(
  void *self,
  mal_ctx_t *mal_ctx,
  mal_endpoint_t *mal_endpoint,
  mal_message_t *message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>state</code> : état du routeur</li>
<li><code>mal_ctx</code> : contexte MAL</li>
<li><code>endpoint</code> : end-point MAL</li>
<li><code>state</code> : état de du routeur, non typé pour permettre le polymorphisme</li>
</ul>
<h3 id="constructeur_4">Constructeur</h3>
<p>Crée une instance de routeur identifiée par l'URI du end-point correspondant. Normalement un unique routeur doit être associé à une end-point donné.</p>
<p>Déclaration :</p>
<pre><code class="c">mal_routing_t *mal_routing_new(mal_endpoint_t *endpoint, void *state);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>endpoint</code> : end-point MAL</li>
<li><code>state</code> : état de du routeur, non typé pour permettre le polymorphisme</li>
</ul>
<h3 id="enregistrement-des-handlers">Enregistrement des handlers</h3>
<p>L'API du routeur MAL définit l'ensemble des fonctions permettant l'enregistrement des handlers d'interaction. Chacune de ces fonctions prend en paramètre le pointeur vers le routeur lui-même, l'identification de l'area, sa version, l’identité du service et de l'opération. En fonction du rôle du handler et du type de l'opération l'interface comprend des pointeurs vers les fonctions de traitement des messages correspondants de l'interaction.</p>
<p>L'API définit une fonction pour enregistrer un provider d'interaction Send, et deux fonctions permettant d'enregistrer les handlers de consumer et provider de chacune des interactions <em>Submit</em>, <em>Request</em>, <em>Invoke</em> et <em>Progress</em>;</p>
<pre><code class="c">int mal_routing_register_provider_send_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_send);

int mal_routing_register_provider_submit_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_submit);

int mal_routing_register_consumer_submit_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_ack);

int mal_routing_register_provider_request_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_request);

int mal_routing_register_consumer_request_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_response);

int mal_routing_register_provider_invoke_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_invoke);

int mal_routing_register_consumer_invoke_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_ack,
    mal_routing_on_message_fn *on_response);

int mal_routing_register_provider_progress_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_progress);

int mal_routing_register_consumer_progress_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_ack,
    mal_routing_on_message_fn *on_update,
    mal_routing_on_message_fn *on_response);
</code></pre>

<p>L'API offre en outre 3 fonctions permettant d'enregistrer un handler de publisher, de subscriber et de broker pour une interaction <em>PubSub</em> :</p>
<pre><code class="c">int mal_routing_register_provider_pubsub_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_publish_error,
    mal_routing_on_message_fn *on_publish_register_ack,
    mal_routing_on_message_fn *on_publish_deregister_ack);

int mal_routing_register_consumer_pubsub_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_register_ack,
    mal_routing_on_message_fn *on_deregister_ack,
    mal_routing_on_message_fn *on_notify);

int mal_routing_register_broker_pubsub_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_notify_error,
    mal_routing_on_message_fn *on_register,
    mal_routing_on_message_fn *on_deregister,
    mal_routing_on_message_fn *on_publish);
</code></pre>

<p>L'API offre aussi une fonction permettant de désenregistrer un Handler :</p>
<pre><code class="c">int mal_routing_remove_handler(
    mal_routing_t *mal_routing,
    handler_type_t type,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation);
</code></pre>

<h3 id="execution-des-handlers">Exécution des handlers</h3>
<p>Le routeur offre une fonction permettant d'activer un handler donné en fonction du message MAL reçu. Lorsqu'elle est appelée cette fonction recherche le handler correspondant dans la liste des handlers  enregistrés. En cas de succès elle active cet handler en appelant la fonction correspondant au message reçu.</p>
<pre><code class="c">int mal_routing_handle(mal_routing_t *self, mal_message_t *message);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>self</code> : le routeur</li>
<li><code>message</code> : le message reçu</li>
</ul>
<h3 id="destructeur_4">Destructeur</h3>
<p>Détruit le routeur et son état.</p>
<pre><code class="c">void mal_routing_destroy(mal_routing_t **self_p);
</code></pre>

<h2 id="union-des-elements">Union des éléments</h2>
<p>Une union <code>mal_element_t</code> est définie pour permettre le polymorphisme d'élément.</p>
<pre><code class="c">union mal_element_t {
  mal_blob_t *blob_value;
  mal_boolean_t boolean_value;
  mal_double_t double_value;
  mal_float_t float_value;
  mal_octet_t octet_value;
  mal_uoctet_t uoctet_value;
  mal_short_t short_value;
  mal_ushort_t ushort_value;
  mal_integer_t integer_value;
  mal_uinteger_t uinteger_value;
  mal_long_t long_value;
  mal_ulong_t ulong_value;
  mal_string_t *string_value;
  mal_identifier_t *identifier_value;
  mal_uri_t *uri_value;
  mal_time_t time_value;
  mal_finetime_t finetime_value;
  mal_duration_t duration_value;
  int enumerated_value;
  void *composite_value;
  void *list_value;
};
</code></pre>

<h2 id="holder-delement">Holder d'élément</h2>
<p>Cette structure permet de gérer le décodage en cas de polymorphisme d'élément.</p>
<h3 id="constructeur_5">Constructeur</h3>
<p>Déclaration :</p>
<pre><code class="c">mal_element_holder_t *mal_element_holder_new(void);
</code></pre>

<h3 id="getters-et-setters_1">Getters et setters</h3>
<pre><code class="c">bool mal_element_holder_get_presence_flag(mal_element_holder_t *self);

void mal_element_holder_set_presence_flag(mal_element_holder_t *self,
  bool presence_flag);

long mal_element_holder_get_short_form(mal_element_holder_t *self);

void mal_element_holder_set_short_form(mal_element_holder_t *self,
  long short_form);

union mal_element_t mal_element_holder_get_value(
  mal_element_holder_t *self);

void mal_element_holder_set_value(mal_element_holder_t *self,
  union mal_element_t value);
</code></pre>

<h3 id="destructeur_5">Destructeur</h3>
<pre><code class="c">void mal_element_holder_destroy(mal_element_holder_t **self_p);
</code></pre>

<p>Ce destructeur ne libère que l'espace alloué pour la structure elle-même, mais pas les éléments de l'union.</p>
<h2 id="listes-dattribut-non-pointeur">Listes d'Attribut non pointeur</h2>
<p>Structures de donnée définies pour représenter les listes des types d'Attribut qui ne sont pas représentés par un type C pointeur (voir section 2.6).
Ces listes sont spécifiques à chaque type d'Attribut non pointeur.
Pour chaque liste, deux tableaux sont définis :</p>
<ul>
<li><code>presence_flags</code> : tableau des flags de présence pour chacun des éléments de la liste</li>
<li><code>content</code> : tableau contenant les valeurs des éléments de la liste ; si un élément est nul, sa valeur dans le tableau doit être affectée avec n'importe quelle valeur.</li>
</ul>
<p>La taille des tableaux <code>presence_flags</code> et <code>content</code> doit être la même.</p>
<h3 id="constructeur_6">Constructeur</h3>
<p>Déclaration :</p>
<pre><code class="c">mal_&lt;attribute&gt;_list_t *mal_&lt;attribute&gt;_list_new(
  unsigned int element_count);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>element_count</code> : nombre d'éléments dans la liste</li>
</ul>
<h3 id="getter">Getter</h3>
<p>Des fonctions « getters » sont définies pour accéder aux champs :</p>
<pre><code class="c">unsigned int mal_&lt;attribute&gt;_list_get_element_count(
  mal_&lt;attribute&gt;_list_t *self);

bool *mal_&lt;attribute&gt;_list_get_presence_flags(
  mal_&lt;attribute&gt;_list_t *self);

mal_&lt;attribute&gt;_t *mal_&lt;attribute&gt;_list_get_content(
  mal_&lt;attribute&gt;_list_t *self);
</code></pre>

<h3 id="destructeur_6">Destructeur</h3>
<p>Détruit la liste et son contenu (tableau des flags de présence et tableau des valeurs).</p>
<pre><code class="c">void mal_&lt;attribute&gt;_list_destroy(mal_&lt;attribute&gt;_list_t **self_p);
</code></pre>

<h2 id="listes-dattribut-pointeur">Listes d'Attribut pointeur</h2>
<p>Structures de donnée définies pour représenter les listes des types d'Attribut qui sont représentés par un type C pointeur (voir section 2.6).</p>
<h3 id="constructeur_7">Constructeur</h3>
<p>Déclaration :</p>
<pre><code class="c">mal_&lt;attribute&gt;_list_t *mal_&lt;attribute&gt;_list_new(
  unsigned int element_count);
</code></pre>

<p>Paramètres :</p>
<ul>
<li><code>element_count</code> : nombre d'éléments dans la liste</li>
</ul>
<h3 id="getters">Getters</h3>
<p>Des fonctions « getters » sont définies pour accéder aux champs :</p>
<pre><code class="c">unsigned int mal_&lt;attribute&gt;_list_get_element_count(
  mal_&lt;attribute&gt;_list_t *self);

mal_&lt;attribute&gt;_t **mal_&lt;attribute&gt;_list_get_content(
  mal_&lt;attribute&gt;_list_t *self);
</code></pre>

<h3 id="destructeur_7">Destructeur</h3>
<p>Détruit la liste, son contenu (tableau de pointeurs) et les éléments de la liste.</p>
<pre><code class="c">void mal_&lt;attribute&gt;_list_destroy(mal_&lt;attribute&gt;_list_t **self_p);
</code></pre>

<h2 id="listes-de-composite">Listes de Composite</h2>
<p>Voir section 9.6.</p>
<h2 id="listes-denumere">Listes d'énuméré</h2>
<p>Voir section 9.7.</p>
<h2 id="etapes-dinteraction">Etapes d'interaction</h2>
<p>Une constante est définie pour chaque étape d'interaction :</p>
<pre><code class="c">#define MAL_IP_STAGE_SEND 1
#define MAL_IP_STAGE_SUBMIT 1
#define MAL_IP_STAGE_SUBMIT_ACK 2
#define MAL_IP_STAGE_REQUEST 1
#define MAL_IP_STAGE_REQUEST_RESPONSE 2
#define MAL_IP_STAGE_INVOKE 1
#define MAL_IP_STAGE_INVOKE_ACK 2
#define MAL_IP_STAGE_INVOKE_RESPONSE 3
#define MAL_IP_STAGE_PROGRESS 1
#define MAL_IP_STAGE_PROGRESS_ACK 2
#define MAL_IP_STAGE_PROGRESS_UPDATE 3
#define MAL_IP_STAGE_PROGRESS_RESPONSE 4
#define MAL_IP_STAGE_PUBSUB_REGISTER 1
#define MAL_IP_STAGE_PUBSUB_REGISTER_ACK 2
#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER 3
#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER_ACK 4
#define MAL_IP_STAGE_PUBSUB_PUBLISH 5
#define MAL_IP_STAGE_PUBSUB_NOTIFY 6
#define MAL_IP_STAGE_PUBSUB_DEREGISTER 7
#define MAL_IP_STAGE_PUBSUB_DEREGISTER_ACK 8
#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER 9
#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER_ACK 10
</code></pre></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
