{
    "docs": [
        {
            "location": "/", 
            "text": "MAL C API and MAL/CZMQ transport\n\n\nIntroduction\n\n\nThis C API represents all MAL concepts, especially the interaction patterns, the MAL message format and the data model. The main goal of this API is to offer a simplified version of the Java MAL API functions. The inherent complexity of MAL standard must be maintained. However, more complex aspects of the Java MAL API can be simplified or abandoned, either because they are not essential, either because they are related to different designs choice (eg Remote Procedure Call oriented approach), or because they can be improved (eg the high dependence between transport and encoding).\n\n\nThe following elements of complexity are inherent to the MAL standard, they must be kept:\n\n\n\n\nSeparation of transport functions, encoding and access control: multiple APIs and abstract functions\n\n\nComplex interaction patterns: \nInvoke\n, \nProgress\n, \nPublish-Subscribe\n\n\nPolymorphism of MAL component, limited to the last element of a message body\n\n\nPolymorphism of MAL attribute\n\n\nInheritance of structure\n\n\n\n\nPolymorphism of MAL element\n\n\nThe MAL specification allows the use of polymorphism for MAL \nElement\n if it is applied at the last item of a message body. It can be used with the following types:\n\n\n\n\nMAL::Element\n\n\nan abstract \nComposite\n\n\na list of \nMAL::Element\n items\n\n\na list of abstract \nComposite\n items\n\n\na list of \nMAL::Attribute\n items\n\n\n\n\nThe types listed above are reserved for polymorphism of the last item of a message body. They can not be used for a composite field.\n\n\nThe lists of abstract type items (\nComposite\n, \nMAL::Element\n or \nMAL::Attribute\n) can not be instantiated: there is no structure of list that may contain items of abstract type (and thus items of several types conform to this abstract type). For example :\n\n\n\n\nList\nMAL::Element\n, \nList\nMAL::Attribute\n cannot be instantiated\n\n\nList\nMAL::UpdateHeader\n, \nList\nMAL::Boolean\n can be instantiated\n\n\n\n\nAccordingly, a list structure only contain elements of the same type and none of abstract type.\n\n\nPolymorphism of MAL Attribute\n\n\nThe MAL specification allows the use of polymorphism for MAL \nAttribute\n it it is applied to the last item of a message body and for \nComposite\n field.\nThe \nAttribute\n polymorphism consist to declare an element or field with the type \nMAL::Attribute\n.\n\n\nConcepts\n\n\nMost concepts of MAL C API are imposed by the MAL specification: MAL message, header fields, data types. However, the MAL specification does not define some concepts that are specific to the implementation of this specification. This section presents only those concepts.\n\n\nEnd-Point\n\n\nThe MAL End-Point is the entity that allows to send and receive MAL messages. Each end-point is related to a single URI of MAL service, the MAL C API enables the dynamic creation and removal of end-points.\n\n\nOnly the end-point which received the message initiating an interaction can answer to this interaction.\n\n\nAn end-point has the following features:\n\n\n\n\nIt can only use a unique transport (binding) to receive and send MAL messages.\n\n\nIt can use multiple encoding formats for the MAL message body.\n\n\nIt is uniquely identified by a MAL URI relative to the MAL context, the URI format depends on the transport used.\n\n\nIt must be run in single-threaded way.\n\n\nIt manages a \nTransaction Id\n counter (MAL header field).\n\n\n\n\nPoller\n\n\nThe MAL Poller is an entity that allows to await the arrival of a message across multiple end-points. The MAL C API enables the dynamic creation and deletion of pollers, adding and removing end-point to the poller.\n\n\nA Poller has the following features:\n\n\n\n\nAll the end-points of a poller must depend on a single MAL context and thus a single transport (binding).\n\n\nIt must be run in single-threaded way.\n\n\n\n\nThe use of MAL Poller is not mandatory, it is useful in different cases:\n\n\n\n\nmanagement of multiple end-points through a single execution flow,\n\n\nnon-blocking message reception.\n\n\n\n\nHandler and routing\n\n\nThese concepts are provided in order to facilitate the distribution of MAL messages received for processing functions, their use is optional.\n\n\nA MAL Handler is an interaction processor, it runs asynchronously when it is notified of an incoming MAL message, and in return it sends zero, one or more MAL messages, either to initiate new interactions (consumer role) or to reply to the current interaction (provider role).\n\n\nEach handler has an interface that depends on its role (provider, consumer, etc.) and interaction in which it operates (send, submit, etc.). For example for a Progress interaction:\n\n\n\n\nThe provider handler must provide the function: \non_progress\n\n\nThe consumer handler must provide the functions: \non_ack\n, \non_update\n and \non_response\n.\n\n\n\n\nEach of these functions is called with the following parameters:\n\n\n\n\na pointer to the Router state (cf 7.6),\n\n\na pointer to the MAL Context (cf 7.2),\n\n\na pointer to the MAL End-Point (cf 7.4),\n\n\nand a pointer to the MAL message (cf 7.3).\n\n\n\n\nThe MAL C API provides a helper class (mal-routing) that simplifies the management of handlers for a particular end-point. This class allows to register the handlers corresponding to expected interactions, and then upon receipt of a message by the end-point to activate the corresponding handler to process the message.\n\n\nThe routers have a state shared by all the handlers they manage.\n\n\nMAL Broker\n\n\nIn our implementation of MAC/CZMQ transport the Publish/Subscribe is partially supported by the MAC/CZMQ transport through the ZMQ PUB/SUB sockets. In order to respect the semantics of MAL Publish/Subscribe pattern it is however necessary to implement a Broker component to manage subscriptions and message filtering.\n\n\nTo comply with the functioning of ZMQ, this broker component will be located Consumer side. Currently it operates as a special Handler (section 2.3) that the user can change or replace.\n\n\nURI Transformation\n\n\nZMQ can use multiple underlying protocols to communicate. For example point-to-point communications may pass through TCP between different machines process, IPC between processes on the same machine or internal mechanisms within the same process. Similarly, the Publish/Subscribe pattern can be implemented through TCP, PGM or EPGM.\n\n\nMAL/ZMQ transport uses various communication streams according interactions, in our prototype each MAL context is listening on 2 different sockets:\n\n\n\n\nA \nDEALER\n socket for point-to-point communications,\n\n\nA \nSUB\n socket for multicats communications.\n\n\n\n\nTo ensure the transformation of the MAL URI of a service in the ZMQ URI needed to achieve an interaction we have chosen to outsource this transformation through upcalls (section 12.2.1). This provides a greater freedom of configuration to the user.\n\n\nPointer attributes\n\n\nPointer attributes are MAL attributes whose representation in C is a pointer type: \nMAL::Blob\n, \nMAL::Identifier\n, \nMAL::String\n and \nMAL::URI\n.\n\n\nFor these attributes the \nNULL\n value (null pointer) is allowed. For other attributes, the null value is represented by an additional boolean field called \"presence flag\".\n\n\nOverview of the MAL C API\n\n\nThe MAL C API consists of several APIs:\n\n\n\n\nMAL attribute API\n : The MAL attributes are extracted from the MAL API to avoid a circular dependency bween MAL API (which depends on the encoding APIs) and encoding APIs (which depends of MAL attributes).\n\n\nEncoding APIs\n : Encoding APIs are specifically defined for each encoding format.\n\n\nMAL API\n : The MAL API allows the use of MAL level concepts.\n\n\nArea APIs\n (generated) : The MAL API contains the Area API generated from the definition of the MAL Area.\n\n\nTransport APIs\n : which manages the mapping of MAL concepts to the underlying concepts of transport chosen.\n\n\nExtraction API for configuration paramters\n.\n\n\n\n\nMost concepts are each represented by a class that conforms to the zproject Class model:\n\n\n\n\nan opaque structure (only the type is visible and not the content) declared in the main header file of the API (\napi\n.h\n)\n\n\nan include file: \nclassname\n.h\n\n\na source file: \nclassname\n.c\n\n\n\n\nClass names are lowercase, with '_' separator, and prefixed by the API name. For example, the concept of end-point, defined in the API MAL, is represented by a class named: \nmal_endpoint\n.\n\n\nThe names of the classes representing data types are prefixed by the names of their Area and their service (if available). For example, the type \nMAL::Blob\n (defined in the area MAL without intermediate Service) is named: \nmal_blob\n.\n\n\nOther conventions are conform to the zproject \nClass\n model.", 
            "title": "Home"
        }, 
        {
            "location": "/#mal-c-api-and-malczmq-transport", 
            "text": "", 
            "title": "MAL C API and MAL/CZMQ transport"
        }, 
        {
            "location": "/#introduction", 
            "text": "This C API represents all MAL concepts, especially the interaction patterns, the MAL message format and the data model. The main goal of this API is to offer a simplified version of the Java MAL API functions. The inherent complexity of MAL standard must be maintained. However, more complex aspects of the Java MAL API can be simplified or abandoned, either because they are not essential, either because they are related to different designs choice (eg Remote Procedure Call oriented approach), or because they can be improved (eg the high dependence between transport and encoding).  The following elements of complexity are inherent to the MAL standard, they must be kept:   Separation of transport functions, encoding and access control: multiple APIs and abstract functions  Complex interaction patterns:  Invoke ,  Progress ,  Publish-Subscribe  Polymorphism of MAL component, limited to the last element of a message body  Polymorphism of MAL attribute  Inheritance of structure", 
            "title": "Introduction"
        }, 
        {
            "location": "/#polymorphism-of-mal-element", 
            "text": "The MAL specification allows the use of polymorphism for MAL  Element  if it is applied at the last item of a message body. It can be used with the following types:   MAL::Element  an abstract  Composite  a list of  MAL::Element  items  a list of abstract  Composite  items  a list of  MAL::Attribute  items   The types listed above are reserved for polymorphism of the last item of a message body. They can not be used for a composite field.  The lists of abstract type items ( Composite ,  MAL::Element  or  MAL::Attribute ) can not be instantiated: there is no structure of list that may contain items of abstract type (and thus items of several types conform to this abstract type). For example :   List MAL::Element ,  List MAL::Attribute  cannot be instantiated  List MAL::UpdateHeader ,  List MAL::Boolean  can be instantiated   Accordingly, a list structure only contain elements of the same type and none of abstract type.", 
            "title": "Polymorphism of MAL element"
        }, 
        {
            "location": "/#polymorphism-of-mal-attribute", 
            "text": "The MAL specification allows the use of polymorphism for MAL  Attribute  it it is applied to the last item of a message body and for  Composite  field.\nThe  Attribute  polymorphism consist to declare an element or field with the type  MAL::Attribute .", 
            "title": "Polymorphism of MAL Attribute"
        }, 
        {
            "location": "/#concepts", 
            "text": "Most concepts of MAL C API are imposed by the MAL specification: MAL message, header fields, data types. However, the MAL specification does not define some concepts that are specific to the implementation of this specification. This section presents only those concepts.", 
            "title": "Concepts"
        }, 
        {
            "location": "/#end-point", 
            "text": "The MAL End-Point is the entity that allows to send and receive MAL messages. Each end-point is related to a single URI of MAL service, the MAL C API enables the dynamic creation and removal of end-points.  Only the end-point which received the message initiating an interaction can answer to this interaction.  An end-point has the following features:   It can only use a unique transport (binding) to receive and send MAL messages.  It can use multiple encoding formats for the MAL message body.  It is uniquely identified by a MAL URI relative to the MAL context, the URI format depends on the transport used.  It must be run in single-threaded way.  It manages a  Transaction Id  counter (MAL header field).", 
            "title": "End-Point"
        }, 
        {
            "location": "/#poller", 
            "text": "The MAL Poller is an entity that allows to await the arrival of a message across multiple end-points. The MAL C API enables the dynamic creation and deletion of pollers, adding and removing end-point to the poller.  A Poller has the following features:   All the end-points of a poller must depend on a single MAL context and thus a single transport (binding).  It must be run in single-threaded way.   The use of MAL Poller is not mandatory, it is useful in different cases:   management of multiple end-points through a single execution flow,  non-blocking message reception.", 
            "title": "Poller"
        }, 
        {
            "location": "/#handler-and-routing", 
            "text": "These concepts are provided in order to facilitate the distribution of MAL messages received for processing functions, their use is optional.  A MAL Handler is an interaction processor, it runs asynchronously when it is notified of an incoming MAL message, and in return it sends zero, one or more MAL messages, either to initiate new interactions (consumer role) or to reply to the current interaction (provider role).  Each handler has an interface that depends on its role (provider, consumer, etc.) and interaction in which it operates (send, submit, etc.). For example for a Progress interaction:   The provider handler must provide the function:  on_progress  The consumer handler must provide the functions:  on_ack ,  on_update  and  on_response .   Each of these functions is called with the following parameters:   a pointer to the Router state (cf 7.6),  a pointer to the MAL Context (cf 7.2),  a pointer to the MAL End-Point (cf 7.4),  and a pointer to the MAL message (cf 7.3).   The MAL C API provides a helper class (mal-routing) that simplifies the management of handlers for a particular end-point. This class allows to register the handlers corresponding to expected interactions, and then upon receipt of a message by the end-point to activate the corresponding handler to process the message.  The routers have a state shared by all the handlers they manage.", 
            "title": "Handler and routing"
        }, 
        {
            "location": "/#mal-broker", 
            "text": "In our implementation of MAC/CZMQ transport the Publish/Subscribe is partially supported by the MAC/CZMQ transport through the ZMQ PUB/SUB sockets. In order to respect the semantics of MAL Publish/Subscribe pattern it is however necessary to implement a Broker component to manage subscriptions and message filtering.  To comply with the functioning of ZMQ, this broker component will be located Consumer side. Currently it operates as a special Handler (section 2.3) that the user can change or replace.", 
            "title": "MAL Broker"
        }, 
        {
            "location": "/#uri-transformation", 
            "text": "ZMQ can use multiple underlying protocols to communicate. For example point-to-point communications may pass through TCP between different machines process, IPC between processes on the same machine or internal mechanisms within the same process. Similarly, the Publish/Subscribe pattern can be implemented through TCP, PGM or EPGM.  MAL/ZMQ transport uses various communication streams according interactions, in our prototype each MAL context is listening on 2 different sockets:   A  DEALER  socket for point-to-point communications,  A  SUB  socket for multicats communications.   To ensure the transformation of the MAL URI of a service in the ZMQ URI needed to achieve an interaction we have chosen to outsource this transformation through upcalls (section 12.2.1). This provides a greater freedom of configuration to the user.", 
            "title": "URI Transformation"
        }, 
        {
            "location": "/#pointer-attributes", 
            "text": "Pointer attributes are MAL attributes whose representation in C is a pointer type:  MAL::Blob ,  MAL::Identifier ,  MAL::String  and  MAL::URI .  For these attributes the  NULL  value (null pointer) is allowed. For other attributes, the null value is represented by an additional boolean field called \"presence flag\".", 
            "title": "Pointer attributes"
        }, 
        {
            "location": "/#overview-of-the-mal-c-api", 
            "text": "The MAL C API consists of several APIs:   MAL attribute API  : The MAL attributes are extracted from the MAL API to avoid a circular dependency bween MAL API (which depends on the encoding APIs) and encoding APIs (which depends of MAL attributes).  Encoding APIs  : Encoding APIs are specifically defined for each encoding format.  MAL API  : The MAL API allows the use of MAL level concepts.  Area APIs  (generated) : The MAL API contains the Area API generated from the definition of the MAL Area.  Transport APIs  : which manages the mapping of MAL concepts to the underlying concepts of transport chosen.  Extraction API for configuration paramters .   Most concepts are each represented by a class that conforms to the zproject Class model:   an opaque structure (only the type is visible and not the content) declared in the main header file of the API ( api .h )  an include file:  classname .h  a source file:  classname .c   Class names are lowercase, with '_' separator, and prefixed by the API name. For example, the concept of end-point, defined in the API MAL, is represented by a class named:  mal_endpoint .  The names of the classes representing data types are prefixed by the names of their Area and their service (if available). For example, the type  MAL::Blob  (defined in the area MAL without intermediate Service) is named:  mal_blob .  Other conventions are conform to the zproject  Class  model.", 
            "title": "Overview of the MAL C API"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Simple example of MAL application\n\n\nThis section shows the MAL C API concepts through the programming of a very simple application that\nruns in a unique process.\n\n\nDifferent blocks of code are distinguished:\n  - The code corresponding to the components of the application. In this example, two components are created.\n  To simplify the application, each component is limited to a single role: \"provider\" or \"consumer\" service.\n  A very simple test service is defined in a service area called \"TestArea\" (see section 14.1).\n  - The initialization code and application launch.\n\n\nThe code of components depends only on MAL C API and APIs generated from the definition of TestArea.\n\n\nThe initialization code and application launch ('main' function) depends on the MAL C API but also on the\ntransport API 'malzmq'.\n\n\nThis example uses the execution of actors CZMQ model.\n\n\nOnly the non generated code is presented in the following sections.\n\n\n\"consumer\" component\n\n\nInclude MAL C API definition and API service (generated code):\n\n\n#include \"mal.h\"\n#include \"testarea.h\"\n\n\n\nConstructor\n\n\nIn this example, all the parameters needed to operate the consumer are given when it was created:\n\n\n- The consumer's end-point.\n- The provider's URI (to which the consumer connects).\n- The parameters of the header of MAL message, such as the authentication ID, etc.\n- The identifier of the encoding format.\n- Encoding settings (untyped to avoid dependence 'malbinary').\n\n\n\nDeclaration:\n\n\n    simple_app_myconsumer_t *simple_app_myconsumer_new(\n      mal_endpoint_t *endpoint,\n      mal_uri_t *provider_uri,\n      mal_blob_t *authentication_id,\n      mal_qoslevel_t qoslevel,\n      mal_uinteger_t priority,\n      mal_identifier_list_t *domain,\n      mal_identifier_t *network_zone,\n      mal_sessiontype_t session,\n      mal_identifier_t *session_name,\n      int encoding_format_code,\n      void *encoder, void *decoder);\n\n\n\n\nImplementation\n\n\nIn this example a CZMQ actor related to the consumer component initiates a MAL interaction on startup.\nThe signature must conform to the \nmain\n virtual function of the actor as defined in CZMQ API:\n\n\n    void simple_app_myconsumer_run(zsock_t *pipe, void *self) {\n\n\n\n\nThe self parameter is cast to get the state of the actor (the \"consumer\" object):\n\n\n    simple_app_myconsumer_t *consumer = (simple_app_myconsumer_t *) self;\n\n\n\n\nThe provider URI is retrieved from the state of the consumer:\n\n\n    mal_uri_t *uri_to = consumer-\nprovider_uri;\n\n\n\n\nA C data structure \nTestComposite\n is instantiated:\n\n\n    testarea_testservice_testcomposite_t *testcomposite =\n      testarea_testservice_testcomposite_new();\n\n\n\n\nA MAL string is allocated from the static string \"hello world\":\n\n\n    mal_string_t *str = mal_string_new(\nhello world\n);\n\n\n\n\nThe \nstringField\n field is assigned:\n\n\n    testarea_testservice_testcomposite_set_stringfield(testcomposite, str);\n\n\n\n\nFrom this point the \nTestComposite\n structure is responsible for the release of the MAL string str.\nConversely the use of this string is only possible as long as the structure was not released.\n\n\nThe \nintField\n field may be null. It is therefore necessary to set the presence flag for this field\nto true, then assign the value of the field (10):\n\n\n    testarea_testservice_testcomposite_intfield_set_present(\n      testcomposite,\n      true);\n    testarea_testservice_testcomposite_set_intfield(testcomposite, 10);\n\n\n\n\nA data structure corresponding to a MAL string list is instantiated and initialized:\n\n\n    mal_string_list_t *string_list = mal_string_list_new(2);\n    mal_string_t **string_list_content =\n      mal_string_list_get_content(string_list);\n    string_list_content[0] = mal_string_new(\nlist-element-1\n);\n    string_list_content[1] = mal_string_new(\nlist-element-2\n);\n\n\n\n\nIn order to test the polymorphisme, a \nTestFinalCompositeA\n structure is instantiated.\nThis structure inherits from \nTestAbstractComposite\n:\n\n\n    testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n      testarea_testservice_testfinalcompositea_new();\n    testarea_testservice_testfinalcompositea_set_intfield(\n      testfinalcompositea, 20);\n    testarea_testservice_testfinalcompositea_set_intfield2(\n      testfinalcompositea, 30);\n\n\n\n\nThe size of encoded message body is calculated using generated functions for each element of the message body.\nA cursor depending of the encoding is created and initialized, this cursor corresponds to a pointer in the encoding\nstructures and datas. It is used during message size calculation, encoding and decoding.\n\n\n  malbinary_cursor_t cursor;\n  malbinary_cursor_reset(\ncursor);\n\n\n\n\nCalculation of the encoding size of the first element (index '0' for the initiation of the \nsend\n stage of\nthe \ntestSend\n operation):\n\n\n    unsigned int body_length = 0;\n    rc = testarea_testservice_testsend_send_add_encoding_length_0(\n      consumer-\nencoding_format_code,\n      consumer-\nencoder, testcomposite, \ncursor);\n\n\n\n\nCalculation of the encoding size of the second element (index '1'):\n\n\n    rc = testarea_testservice_testsend_send_add_encoding_length_1(\n      consumer-\nencoding_format_code,\n      consumer-\nencoder, string_list, \ncursor);\n\n\n\n\nCalculation of the encoding size of the third element (index '2') with polymorphism:\n\n\n    rc = testarea_testservice_testsend_send_add_encoding_length_2_testarea_\n    testservice_testfinalcompositea(\n      consumer-\nencoding_format_code,\n      consumer-\nencoder, testfinalcompositea, \ncursor);\n\n\n\n\nCreating a MAL message with the following parameters:\n\n\n- MAL header fields contained in the statement of Handler.\n- The encoding size of the MAL message body retrieved from the encoding cursor.\n\n\n\n    mal_message_t *message = mal_message_new(uri_to,\n      consumer-\nauthentication_id,\n      consumer-\nqoslevel, consumer-\npriority, consumer-\ndomain,\n      consumer-\nnetwork_zone, consumer-\nsession, consumer-\nsession_name,\n      malbinary_cursor_get_body_length(\ncursor));\n\n\n\n\nEncoding of the first element (index '0'):\n\n\n    unsigned int offset = mal_message_get_body_offset(message);\n    char *bytes = mal_message_get_body(message);\n    rc = testarea_testservice_testsend_send_encode_0(\n      consumer-\nencoding_format_code, \ncursor,\n      consumer-\nencoder, testcomposite);\n\n\n\n\nEncoding of the second (index '1'):\n\n\n    rc = testarea_testservice_testsend_send_encode_1(\n      consumer-\nencoding_format_code, \ncursor,\n      consumer-\nencoder, string_list);\n\n\n\n\nEncoding of the third element (index '3'):\n\n\n    rc = testarea_testservice_testsend_send_encode_2_testarea_testservice_\n    testfinalcompositea(\n      consumer-\nencoding_format_code, cursor,\n      consumer-\nencoder, testfinalcompositea);\n\n\n\n\nSending of MAL message (initiation of stage \nsend\n of \ntestSend\n operation):\n\n\n    rc = testarea_testservice_testsend_send(\n      consumer-\nendpoint,\n      message,\n      consumer-\nprovider_uri);\n\n\n\n\nReleasing of allocated structures:\n\n\n    testarea_testservice_testcomposite_destroy(\ntestcomposite);\n    mal_string_list_destroy(\nstring_list);\n    testarea_testservice_testfinalcompositea_destroy(\ntestfinalcompositea);\n\n\n\n\n\"provider\" component\n\n\nInclude MAL C API definition and API service (generated code):\n\n\n    #include \nmal.h\n\n    #include \ntestarea.h\n\n\n\n\n\nConstructor\n\n\nIn this example, all the parameters needed to operate the provider are given when it was created:\n\n\n- The provider's end-point.\n- The identifier of the encoding format.\n- Encoding settings (untyped to avoid dependence 'malbinary').\n\n\n\nDeclaration:\n\n\n    simple_app_myprovider_t simple_app_myprovider_new(\n      mal_endpoint_t *endpoint,\n      int encoding_format_code,\n      void *encoder, void *decoder);\n\n\n\n\nImplementation\n\n\nIn this example a CZMQ actor related to the provider registers an interaction handler on startup.\nThe signature must conform to the \nmain\n virtual function of the actor as defined in CZMQ API:\n\n\n  void simple_app_myprovider_run(zsock_t *pipe, void *self) {\n\n\n\n\nTo facilitate the messages routing a MAL router is created:\n\n\n    mal_routing_t *router = mal_routing_new(self-\nendpoint, self);\n\n\n\n\nThen a handler corresponding to the provider role of a \nsend\n interaction must be registered\ndynamically with the router:\n\n\n    rc = mal_routing_register_provider_send_handler(\n         router,\n         TESTAREA_AREA_NUMBER,\n         TESTAREA_AREA_VERSION,\n         TESTAREA_TESTSERVICE_SERVICE_NUMBER,\n         TESTAREA_TESTSERVICE_TESTSEND_OPERATION_NUMBER,\n         simple_app_myprovider_testarea_testservice_testsend);\n\n\n\n\nThese calls are made in the initialization function of the actor. Finally the actor waits to receive\na message on the corresponding end-point:\n\n\n    mal_message_t *message = NULL;\n    rc = mal_endpoint_recv_message(self-\nendpoint, \nmessage);\n\n\n\n\nThen the actor activates the corresponding handler through the router and destroy this message if it could\nnot be handled by any handler:\n\n\n    if (message != NULL) {\n      rc = mal_routing_handle(router, message);\n      if (rc != 0)\n        mal_message_destroy(\n          message,\n          mal_endpoint_get_mal_ctx(self-\nendpoint));\n\n\n\n\nThe handler can then react to the received MAL message MAL through the\n\nsimple_app_myprovider_testarea_testservice_testsend\n function whose signature must conform\nto the virtual function defined in the MAL Handler API (see Section 7.6.1).\nThe dispatch code thus refers to a specific function in the processing of the operation 'testSend':\n\n\n    int simple_app_myprovider_testarea_testservice_testsend(\n      void *self,\n      mal_ctx_t *mal_ctx,\n      mal_endpoint_t *mal_endpoint,\n      mal_message_t *message) {\n\n\n\n\nThe 'self' parameter is cast to get the state of the router shared by all registered handlers (the \"provider\"):\n\n\n      simple_app_myprovider_t *provider = (simple_app_myprovider_t *) self;\n\n\n\n\nA cursor depending of the encoding is created then initialized, this cursor corresponds to a pointer in\ndata buffer and decoding structure. It is used during decoding.\n\n\n  malbinary_cursor_t cursor;\n  malbinary_cursor_init(\ncursor,\n      mal_message_get_body(message),\n      mal_message_get_body_offset(message) + mal_message_get_body_length(message),\n      mal_message_get_body_offset(message));\n\n\n\n\nDecoding the first element of the MAL message body:\n\n\n      testarea_testservice_testcomposite_t *parameter_0 = NULL;\n      unsigned int offset = mal_message_get_body_offset(message);\n      char *bytes = mal_message_get_body(message);\n      rc = testarea_testservice_testsend_send_decode_0(\n        provider-\nencoding_format_code, \ncursor,\n        provider-\ndecoder, \nparameter_0);\n      if (rc \n 0) {\n        return rc;\n      }\n\n\n\n\nDecoding the second element:\n\n\n      mal_string_list_t *parameter_1;\n      rc = testarea_testservice_testsend_send_decode_1(\n        provider-\nencoding_format_code, \ncursor,\n        provider-\ndecoder, \nparameter_1);\n      if (rc \n 0) {\n        return rc;\n      }\n\n\n\n\nDecoding the third (last) element (with polymorphism):\n\n\n      mal_element_holder_t parameter_2;\n      rc = testarea_testservice_testsend_send_decode_2(\n        provider-\nencoding_format_code, \ncursor,\n        provider-\ndecoder, \nparameter_2);\n      if (rc \n 0) {\n        return rc;\n      }\n\n\n\n\nThe value of the decoded parameters can be zero.\n\n\nThe third parameter needs to test the value of the 'short_form' field before making the cast:\n\n\n    if (parameter_2.presence_flag \n parameter_2.short_form ==\n        TESTAREA_TESTSERVICE_TESTFINALCOMPOSITEA_SHORT_FORM) {\n      testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n        (testarea_testservice_testfinalcompositea_t *) parameter_2;\n      ...\n\n\n\n\nReleasing the corresponding allocated structures:\n\n\n      testarea_testservice_testfinalcompositea_destroy(\ntestfinalcompositea);\n\n\n\n\nReleasing the allocated structures for first and second parameters:\n\n\n      testarea_testservice_testcomposite_destroy(\nparameter_0);\n      mal_string_list_destroy(\nparameter_1);\n\n\n\n\nThe message should then be destroyed:\n\n\n    mal_message_destroy(\nmessage, mal_ctx);\n\n\n\n\nApplication launching:\n\n\nInclude MAL/C and MALZMQ transport API definition:\n\n\n    #include \nmal.h\n\n    #include \nmalzmq.h\n\n\n\n\n\nCreating a MAL context\n\n\n    mal_ctx_t *mal_ctx = mal_ctx_new();\n\n\n\n\nThe encoding and decoding contexts are created for the 'malbinary' format. The 'varint' format is not \nused and the 'verbose' flag is enabled:\n\n\n    malbinary_encoder_t *encoder = malbinary_encoder_new(false, true);\n    malbinary_decoder_t *decoder = malbinary_decoder_new(false, true);\n\n\n\n\nConfiguring the mapping catalog (see 12.1.3) and the presence of flags (see 12.1.2) in the MALZMQ header.\nIn this example we do not use a catalog and all optional fields are present (and encoded) in the MAL header.\n\n\n    malzmq_header_t *malzmq_header = malzmq_header_new(NULL, true, 0, true, NULL,\n      NULL, NULL, NULL);\n\n\n\n\nA MALZMQ context is created from the MAL context, an URI mapping function can beprovided (see 12.2). In this\nexample we use the default function. The IP address and listening port for incoming connections are 'localhost'\nand 5555.\n\n\n    malzmq_ctx_t *malzmq_ctx = malzmq_ctx_new(\n      mal_ctx, NULL,\n      \nlocalhost\n, \n5555\n,\n      malzmq_header,\n      encoder, decoder,\n      true);\n\n\n\n\nProvider creation\n\n\nCreating a MALZMQ URI. A unique name (in the MALZMQ context) is given in parameter.\n\n\n    mal_uri_t *provider_uri =\n      mal_ctx_create_uri(mal_ctx, \nsimple_app/myprovider\n);\n\n\n\n\nCreating the provider's endpoint with the following parameters:\n\n\n\n\nThe pointer to the MAL context.\n\n\nThe provider's URI previously allocated.\n\n\n\n\n    mal_endpoint_t *provider_endpoint = mal_endpoint_new(mal_ctx, provider_uri);\n\n\n\n\nInstantiating the provider with the pointer to the corresponding endpoint and the related encoding parameters:\n\n\n    simple_app_myprovider_t *provider = simple_app_myprovider_new(\n      provider_endpoint,\n      MALBINARY_FORMAT_CODE,\n      encoder, decoder);\n\n\n\n\nThe operation handler will be registered later in the run function of the CZMQ actor (see Section 4.2.2).\n\n\nConsumer creation\n\n\nCreating a MALZMQ URI. A unique name (in the MALZMQ context) is given in parameter.\n\n\n    mal_uri_t *consumer_uri =\n      mal_ctx_create_uri(mal_ctx, \nsimple_app/myconsumer\n);\n\n\n\n\nCreating the consumer's endpoint with the following parameters:\n\n\n\n\nThe pointer to the MAL context.\n\n\nThe consumer's URI previously allocated.\n\n\n\n\n    mal_endpoint_t *consumer_endpoint = mal_endpoint_new(mal_ctx, consumer_uri);\n\n\n\n\nThe instantiation of the consumer requires some more MAL message header settings:\n\n\n    mal_blob_t *authentication_id = mal_blob_new(0);\n    mal_qoslevel_t qoslevel = MAL_QOSLEVEL_ASSURED;\n    mal_uinteger_t priority = 4;\n    mal_identifier_list_t *domain = mal_identifier_list_new(0);\n    mal_identifier_t *network_zone = mal_identifier_new(\nNetwork Zone\n);\n    mal_sessiontype_t session = MAL_SESSIONTYPE_LIVE;\n    mal_identifier_t *session_name = mal_identifier_new(\nLIVE\n);\n\n    simple_app_myconsumer_t *consumer =\n    simple_app_myconsumer_new(provider_uri,\n      authentication_id, qoslevel, priority, domain, network_zone, session,\n      session_name, MALBINARY_FORMAT_CODE, encoder, decoder);\n\n\n\n\nThe encoding and decoding contexts used are those used by the provider.\nConsumer side the Send operation requires no handler, so there will be no handler registration\nfor this consumer.\n\n\nApplication launching and termination\n\n\nCreating the provider and the corresponding ZMQ actor:\n\n\n  provider = simple_app_create_provider(verbose, mal_ctx, provider_uri, encoder, decoder);\n  zactor_t *provider_actor = zactor_new(simple_app_myprovider_run, provider);\n\n\n\n\nCreating the consumer and the corresponding ZMQ actor:\n\n\n  consumer = simple_app_create_consumer(verbose, mal_ctx, provider_uri, encoder, decoder);\n  zactor_t *consumer_actor = zactor_new(simple_app_myconsumer_run, consumer);\n\n\n\n\nStarting the MALZMQ transport (this call blocks until termination of the context):\n\n\n      malzmq_ctx_start(malzmq_ctx);\n\n\n\n\nDeletion of provider and consumer actors:\n\n\n  zactor_destroy(\nprovider_actor);\n  zactor_destroy(\nconsumer_actor);\n\n\n\n\nDeletion of MAL and MALZMQ contexts:\n\n\n      mal_ctx_destroy(\nmal_ctx);\n      malzmq_ctx_destroy(\nmalzmq_ctx);", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#simple-example-of-mal-application", 
            "text": "This section shows the MAL C API concepts through the programming of a very simple application that\nruns in a unique process.  Different blocks of code are distinguished:\n  - The code corresponding to the components of the application. In this example, two components are created.\n  To simplify the application, each component is limited to a single role: \"provider\" or \"consumer\" service.\n  A very simple test service is defined in a service area called \"TestArea\" (see section 14.1).\n  - The initialization code and application launch.  The code of components depends only on MAL C API and APIs generated from the definition of TestArea.  The initialization code and application launch ('main' function) depends on the MAL C API but also on the\ntransport API 'malzmq'.  This example uses the execution of actors CZMQ model.  Only the non generated code is presented in the following sections.", 
            "title": "Simple example of MAL application"
        }, 
        {
            "location": "/tutorial/#consumer-component", 
            "text": "Include MAL C API definition and API service (generated code):  #include \"mal.h\"\n#include \"testarea.h\"", 
            "title": "\"consumer\" component"
        }, 
        {
            "location": "/tutorial/#constructor", 
            "text": "In this example, all the parameters needed to operate the consumer are given when it was created:  - The consumer's end-point.\n- The provider's URI (to which the consumer connects).\n- The parameters of the header of MAL message, such as the authentication ID, etc.\n- The identifier of the encoding format.\n- Encoding settings (untyped to avoid dependence 'malbinary').  Declaration:      simple_app_myconsumer_t *simple_app_myconsumer_new(\n      mal_endpoint_t *endpoint,\n      mal_uri_t *provider_uri,\n      mal_blob_t *authentication_id,\n      mal_qoslevel_t qoslevel,\n      mal_uinteger_t priority,\n      mal_identifier_list_t *domain,\n      mal_identifier_t *network_zone,\n      mal_sessiontype_t session,\n      mal_identifier_t *session_name,\n      int encoding_format_code,\n      void *encoder, void *decoder);", 
            "title": "Constructor"
        }, 
        {
            "location": "/tutorial/#implementation", 
            "text": "In this example a CZMQ actor related to the consumer component initiates a MAL interaction on startup.\nThe signature must conform to the  main  virtual function of the actor as defined in CZMQ API:      void simple_app_myconsumer_run(zsock_t *pipe, void *self) {  The self parameter is cast to get the state of the actor (the \"consumer\" object):      simple_app_myconsumer_t *consumer = (simple_app_myconsumer_t *) self;  The provider URI is retrieved from the state of the consumer:      mal_uri_t *uri_to = consumer- provider_uri;  A C data structure  TestComposite  is instantiated:      testarea_testservice_testcomposite_t *testcomposite =\n      testarea_testservice_testcomposite_new();  A MAL string is allocated from the static string \"hello world\":      mal_string_t *str = mal_string_new( hello world );  The  stringField  field is assigned:      testarea_testservice_testcomposite_set_stringfield(testcomposite, str);  From this point the  TestComposite  structure is responsible for the release of the MAL string str.\nConversely the use of this string is only possible as long as the structure was not released.  The  intField  field may be null. It is therefore necessary to set the presence flag for this field\nto true, then assign the value of the field (10):      testarea_testservice_testcomposite_intfield_set_present(\n      testcomposite,\n      true);\n    testarea_testservice_testcomposite_set_intfield(testcomposite, 10);  A data structure corresponding to a MAL string list is instantiated and initialized:      mal_string_list_t *string_list = mal_string_list_new(2);\n    mal_string_t **string_list_content =\n      mal_string_list_get_content(string_list);\n    string_list_content[0] = mal_string_new( list-element-1 );\n    string_list_content[1] = mal_string_new( list-element-2 );  In order to test the polymorphisme, a  TestFinalCompositeA  structure is instantiated.\nThis structure inherits from  TestAbstractComposite :      testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n      testarea_testservice_testfinalcompositea_new();\n    testarea_testservice_testfinalcompositea_set_intfield(\n      testfinalcompositea, 20);\n    testarea_testservice_testfinalcompositea_set_intfield2(\n      testfinalcompositea, 30);  The size of encoded message body is calculated using generated functions for each element of the message body.\nA cursor depending of the encoding is created and initialized, this cursor corresponds to a pointer in the encoding\nstructures and datas. It is used during message size calculation, encoding and decoding.    malbinary_cursor_t cursor;\n  malbinary_cursor_reset( cursor);  Calculation of the encoding size of the first element (index '0' for the initiation of the  send  stage of\nthe  testSend  operation):      unsigned int body_length = 0;\n    rc = testarea_testservice_testsend_send_add_encoding_length_0(\n      consumer- encoding_format_code,\n      consumer- encoder, testcomposite,  cursor);  Calculation of the encoding size of the second element (index '1'):      rc = testarea_testservice_testsend_send_add_encoding_length_1(\n      consumer- encoding_format_code,\n      consumer- encoder, string_list,  cursor);  Calculation of the encoding size of the third element (index '2') with polymorphism:      rc = testarea_testservice_testsend_send_add_encoding_length_2_testarea_\n    testservice_testfinalcompositea(\n      consumer- encoding_format_code,\n      consumer- encoder, testfinalcompositea,  cursor);  Creating a MAL message with the following parameters:  - MAL header fields contained in the statement of Handler.\n- The encoding size of the MAL message body retrieved from the encoding cursor.      mal_message_t *message = mal_message_new(uri_to,\n      consumer- authentication_id,\n      consumer- qoslevel, consumer- priority, consumer- domain,\n      consumer- network_zone, consumer- session, consumer- session_name,\n      malbinary_cursor_get_body_length( cursor));  Encoding of the first element (index '0'):      unsigned int offset = mal_message_get_body_offset(message);\n    char *bytes = mal_message_get_body(message);\n    rc = testarea_testservice_testsend_send_encode_0(\n      consumer- encoding_format_code,  cursor,\n      consumer- encoder, testcomposite);  Encoding of the second (index '1'):      rc = testarea_testservice_testsend_send_encode_1(\n      consumer- encoding_format_code,  cursor,\n      consumer- encoder, string_list);  Encoding of the third element (index '3'):      rc = testarea_testservice_testsend_send_encode_2_testarea_testservice_\n    testfinalcompositea(\n      consumer- encoding_format_code, cursor,\n      consumer- encoder, testfinalcompositea);  Sending of MAL message (initiation of stage  send  of  testSend  operation):      rc = testarea_testservice_testsend_send(\n      consumer- endpoint,\n      message,\n      consumer- provider_uri);  Releasing of allocated structures:      testarea_testservice_testcomposite_destroy( testcomposite);\n    mal_string_list_destroy( string_list);\n    testarea_testservice_testfinalcompositea_destroy( testfinalcompositea);", 
            "title": "Implementation"
        }, 
        {
            "location": "/tutorial/#provider-component", 
            "text": "Include MAL C API definition and API service (generated code):      #include  mal.h \n    #include  testarea.h", 
            "title": "\"provider\" component"
        }, 
        {
            "location": "/tutorial/#constructor_1", 
            "text": "In this example, all the parameters needed to operate the provider are given when it was created:  - The provider's end-point.\n- The identifier of the encoding format.\n- Encoding settings (untyped to avoid dependence 'malbinary').  Declaration:      simple_app_myprovider_t simple_app_myprovider_new(\n      mal_endpoint_t *endpoint,\n      int encoding_format_code,\n      void *encoder, void *decoder);", 
            "title": "Constructor"
        }, 
        {
            "location": "/tutorial/#implementation_1", 
            "text": "In this example a CZMQ actor related to the provider registers an interaction handler on startup.\nThe signature must conform to the  main  virtual function of the actor as defined in CZMQ API:    void simple_app_myprovider_run(zsock_t *pipe, void *self) {  To facilitate the messages routing a MAL router is created:      mal_routing_t *router = mal_routing_new(self- endpoint, self);  Then a handler corresponding to the provider role of a  send  interaction must be registered\ndynamically with the router:      rc = mal_routing_register_provider_send_handler(\n         router,\n         TESTAREA_AREA_NUMBER,\n         TESTAREA_AREA_VERSION,\n         TESTAREA_TESTSERVICE_SERVICE_NUMBER,\n         TESTAREA_TESTSERVICE_TESTSEND_OPERATION_NUMBER,\n         simple_app_myprovider_testarea_testservice_testsend);  These calls are made in the initialization function of the actor. Finally the actor waits to receive\na message on the corresponding end-point:      mal_message_t *message = NULL;\n    rc = mal_endpoint_recv_message(self- endpoint,  message);  Then the actor activates the corresponding handler through the router and destroy this message if it could\nnot be handled by any handler:      if (message != NULL) {\n      rc = mal_routing_handle(router, message);\n      if (rc != 0)\n        mal_message_destroy(\n          message,\n          mal_endpoint_get_mal_ctx(self- endpoint));  The handler can then react to the received MAL message MAL through the simple_app_myprovider_testarea_testservice_testsend  function whose signature must conform\nto the virtual function defined in the MAL Handler API (see Section 7.6.1).\nThe dispatch code thus refers to a specific function in the processing of the operation 'testSend':      int simple_app_myprovider_testarea_testservice_testsend(\n      void *self,\n      mal_ctx_t *mal_ctx,\n      mal_endpoint_t *mal_endpoint,\n      mal_message_t *message) {  The 'self' parameter is cast to get the state of the router shared by all registered handlers (the \"provider\"):        simple_app_myprovider_t *provider = (simple_app_myprovider_t *) self;  A cursor depending of the encoding is created then initialized, this cursor corresponds to a pointer in\ndata buffer and decoding structure. It is used during decoding.    malbinary_cursor_t cursor;\n  malbinary_cursor_init( cursor,\n      mal_message_get_body(message),\n      mal_message_get_body_offset(message) + mal_message_get_body_length(message),\n      mal_message_get_body_offset(message));  Decoding the first element of the MAL message body:        testarea_testservice_testcomposite_t *parameter_0 = NULL;\n      unsigned int offset = mal_message_get_body_offset(message);\n      char *bytes = mal_message_get_body(message);\n      rc = testarea_testservice_testsend_send_decode_0(\n        provider- encoding_format_code,  cursor,\n        provider- decoder,  parameter_0);\n      if (rc   0) {\n        return rc;\n      }  Decoding the second element:        mal_string_list_t *parameter_1;\n      rc = testarea_testservice_testsend_send_decode_1(\n        provider- encoding_format_code,  cursor,\n        provider- decoder,  parameter_1);\n      if (rc   0) {\n        return rc;\n      }  Decoding the third (last) element (with polymorphism):        mal_element_holder_t parameter_2;\n      rc = testarea_testservice_testsend_send_decode_2(\n        provider- encoding_format_code,  cursor,\n        provider- decoder,  parameter_2);\n      if (rc   0) {\n        return rc;\n      }  The value of the decoded parameters can be zero.  The third parameter needs to test the value of the 'short_form' field before making the cast:      if (parameter_2.presence_flag   parameter_2.short_form ==\n        TESTAREA_TESTSERVICE_TESTFINALCOMPOSITEA_SHORT_FORM) {\n      testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n        (testarea_testservice_testfinalcompositea_t *) parameter_2;\n      ...  Releasing the corresponding allocated structures:        testarea_testservice_testfinalcompositea_destroy( testfinalcompositea);  Releasing the allocated structures for first and second parameters:        testarea_testservice_testcomposite_destroy( parameter_0);\n      mal_string_list_destroy( parameter_1);  The message should then be destroyed:      mal_message_destroy( message, mal_ctx);", 
            "title": "Implementation"
        }, 
        {
            "location": "/tutorial/#application-launching", 
            "text": "Include MAL/C and MALZMQ transport API definition:      #include  mal.h \n    #include  malzmq.h", 
            "title": "Application launching:"
        }, 
        {
            "location": "/tutorial/#creating-a-mal-context", 
            "text": "mal_ctx_t *mal_ctx = mal_ctx_new();  The encoding and decoding contexts are created for the 'malbinary' format. The 'varint' format is not \nused and the 'verbose' flag is enabled:      malbinary_encoder_t *encoder = malbinary_encoder_new(false, true);\n    malbinary_decoder_t *decoder = malbinary_decoder_new(false, true);  Configuring the mapping catalog (see 12.1.3) and the presence of flags (see 12.1.2) in the MALZMQ header.\nIn this example we do not use a catalog and all optional fields are present (and encoded) in the MAL header.      malzmq_header_t *malzmq_header = malzmq_header_new(NULL, true, 0, true, NULL,\n      NULL, NULL, NULL);  A MALZMQ context is created from the MAL context, an URI mapping function can beprovided (see 12.2). In this\nexample we use the default function. The IP address and listening port for incoming connections are 'localhost'\nand 5555.      malzmq_ctx_t *malzmq_ctx = malzmq_ctx_new(\n      mal_ctx, NULL,\n       localhost ,  5555 ,\n      malzmq_header,\n      encoder, decoder,\n      true);", 
            "title": "Creating a MAL context"
        }, 
        {
            "location": "/tutorial/#provider-creation", 
            "text": "Creating a MALZMQ URI. A unique name (in the MALZMQ context) is given in parameter.      mal_uri_t *provider_uri =\n      mal_ctx_create_uri(mal_ctx,  simple_app/myprovider );  Creating the provider's endpoint with the following parameters:   The pointer to the MAL context.  The provider's URI previously allocated.       mal_endpoint_t *provider_endpoint = mal_endpoint_new(mal_ctx, provider_uri);  Instantiating the provider with the pointer to the corresponding endpoint and the related encoding parameters:      simple_app_myprovider_t *provider = simple_app_myprovider_new(\n      provider_endpoint,\n      MALBINARY_FORMAT_CODE,\n      encoder, decoder);  The operation handler will be registered later in the run function of the CZMQ actor (see Section 4.2.2).", 
            "title": "Provider creation"
        }, 
        {
            "location": "/tutorial/#consumer-creation", 
            "text": "Creating a MALZMQ URI. A unique name (in the MALZMQ context) is given in parameter.      mal_uri_t *consumer_uri =\n      mal_ctx_create_uri(mal_ctx,  simple_app/myconsumer );  Creating the consumer's endpoint with the following parameters:   The pointer to the MAL context.  The consumer's URI previously allocated.       mal_endpoint_t *consumer_endpoint = mal_endpoint_new(mal_ctx, consumer_uri);  The instantiation of the consumer requires some more MAL message header settings:      mal_blob_t *authentication_id = mal_blob_new(0);\n    mal_qoslevel_t qoslevel = MAL_QOSLEVEL_ASSURED;\n    mal_uinteger_t priority = 4;\n    mal_identifier_list_t *domain = mal_identifier_list_new(0);\n    mal_identifier_t *network_zone = mal_identifier_new( Network Zone );\n    mal_sessiontype_t session = MAL_SESSIONTYPE_LIVE;\n    mal_identifier_t *session_name = mal_identifier_new( LIVE );\n\n    simple_app_myconsumer_t *consumer =\n    simple_app_myconsumer_new(provider_uri,\n      authentication_id, qoslevel, priority, domain, network_zone, session,\n      session_name, MALBINARY_FORMAT_CODE, encoder, decoder);  The encoding and decoding contexts used are those used by the provider.\nConsumer side the Send operation requires no handler, so there will be no handler registration\nfor this consumer.", 
            "title": "Consumer creation"
        }, 
        {
            "location": "/tutorial/#application-launching-and-termination", 
            "text": "Creating the provider and the corresponding ZMQ actor:    provider = simple_app_create_provider(verbose, mal_ctx, provider_uri, encoder, decoder);\n  zactor_t *provider_actor = zactor_new(simple_app_myprovider_run, provider);  Creating the consumer and the corresponding ZMQ actor:    consumer = simple_app_create_consumer(verbose, mal_ctx, provider_uri, encoder, decoder);\n  zactor_t *consumer_actor = zactor_new(simple_app_myconsumer_run, consumer);  Starting the MALZMQ transport (this call blocks until termination of the context):        malzmq_ctx_start(malzmq_ctx);  Deletion of provider and consumer actors:    zactor_destroy( provider_actor);\n  zactor_destroy( consumer_actor);  Deletion of MAL and MALZMQ contexts:        mal_ctx_destroy( mal_ctx);\n      malzmq_ctx_destroy( malzmq_ctx);", 
            "title": "Application launching and termination"
        }, 
        {
            "location": "/mal_attributes/", 
            "text": "MAL Attribute API\n\n\nThe MAL Attribute API defines the \nC\n types used to represent the MAL attributes.\n\n\nBoolean type\n\n\nDefinition of type \nMAL::Boolean\n:\n\n\n    typedef bool mal_boolean_t;\n\n\n\n\nInteger types\n\n\nDefinition of types \nMAL::Octet\n, \nMAL::UOctet\n, \nMAL::Short\n, \nMAL::UShort\n, \nMAL::Integer\n, \nMAL::UInteger\n, \nMAL::Long\n, \nMAL::ULong\n:\n\n\n    typedef char mal_octet_t;\n    typedef unsigned char mal_uoctet_t;\n    typedef short mal_short_t;\n    typedef unsigned short mal_ushort_t;\n    typedef int mal_integer_t;\n    typedef unsigned int mal_uinteger_t;\n    typedef long mal_long_t;\n    typedef unsigned long mal_ulong_t;\n\n\n\n\nFloating point types\n\n\nDefinition of types \nMAL::Float\n, \nMAL::Double\n.\n\n\n    typedef float mal_float_t;\n    typedef double mal_double_t;\n\n\n\n\nDates\n\n\nDefinition of types \nMAL::Time\n, \nMAL::FineTime\n:\n\n\n    typedef unsigned long mal_time_t;\n    typedef unsigned long mal_finetime_t;\n\n\n\n\nDuration\n\n\nDefinition of type \nMAL::Duration\n:\n\n\n    typedef float mal_duration_t;\n\n\n\n\nString type\n\n\nThe \nchar\n type is used to represent strings. If the characters are not in the ASCII format\n(MAL specifies Unicode), then a character may be represented by several bytes. In this case,\nthe \nC\n functions dealing ASCII strings are no longer usable.\n\n\nDefinition of types \nMAL::String\n, \nMAL::Identifier\n, \nMAL::URI\n:\n\n\n    typedef char mal_string_t;\n    typedef char mal_identifier_t;\n    typedef char mal_uri_t;\n\n\n\n\nConstructor\n\n\nDynamically allocates a new string from an existing string. \nThis function should be called when a MAL string is built from a statically defined chain.\n\n\n    mal_\nattribute\n_t *mal_\nattribute\n_new(char *char_content);\n\n\n\n\nString length (ASCII)\n\n\nReturns the number of characters (encoded on 1 byte) in the string before the final null character (\n\\0\n).\n\n\n    size_t mal_\nattribute\n_get_char_count(mal_\nattribute\n_t *self)\n\n\n\n\nString copy\n\n\nWhen the same string must be used in two different fields of the same MAL structure or in two different MAL structures (composite, list), then it is necessary to duplicate the MAL string. Do never assign the same MAL string to different fields.\n\n\n    mal_\nattribute\n_t *attribute2 = mal_\nattribute\n_new(attribute1);\n\n\n\n\nDestructeur\n\n\nDeletes the string.\n\n\n    mal_\nattribute\n_destroy(mal_\nattribute\n_t **self_p);\n\n\n\n\nBlob\n\n\nA class is defined for the type Blob in order to keep the size of the corresponding byte array (not accessible in C).\n\n\nConstructeur\n\n\nDeclaration:\n\n\n    mal_blob_t *mal_blob_new(unsigned int length);\n\n\n\n\nParameter:\n\n\n\n\nlength\n: Number of bytes in the Blob.\n\n\n\n\nGetters\n\n\nTwo functions are defined to access the fields of Blob:\n\n\n    char *mal_blob_get_content(mal_blob_t *self);\n    unsigned int mal_blob_get_length(mal_blob_t *self);\n\n\n\n\nDestructeur\n\n\nDeletes the Blob and its content.\n\n\n    void mal_blob_destroy(mal_blob_t **self_p);\n\n\n\n\nMAL Attribute polymorphism\n\n\nTo handle the case of MAL Attribute polymorphism, a class is defined with the following elements:\n\n\n\n\ntags that identify the real type of the attribute,\n\n\na \nC\n union allowing the manipulation of the value of the attribute according to the associated tag,\n\n\na destructor.\n\n\n\n\nAttribute union\n\n\nA \nC\n union \nmal_attribute_t\n is defined to allow the MAL attribute polymorphism.\n\n\n    union mal_attribute_t {\n      mal_blob_t *blob_value;\n      mal_boolean_t boolean_value;\n      mal_double_t double_value;\n      mal_float_t float_value;\n      mal_octet_t octet_value;\n      mal_uoctet_t uoctet_value;\n      mal_short_t short_value;\n      mal_ushort_t ushort_value;\n      mal_integer_t integer_value;\n      mal_uinteger_t uinteger_value;\n      mal_long_t long_value;\n      mal_ulong_t ulong_value;\n      mal_string_t *string_value;\n      mal_identifier_t *identifier_value;\n      mal_uri_t *uri_value;\n      mal_time_t time_value;\n      mal_finetime_t finetime_value;\n      mal_duration_t duration_value;\n    };\n\n\n\n\nAttribute tags\n\n\nThese identifiers are transmitted in case of \nMAL Attribute\n polymorphism.\n\n\n    #define MAL_BLOB_ATTRIBUTE_TAG 0\n    #define MAL_BOOLEAN_ATTRIBUTE_TAG 1\n    #define MAL_DURATION_ATTRIBUTE_TAG 2\n    #define MAL_FLOAT_ATTRIBUTE_TAG 3\n    #define MAL_DOUBLE_ATTRIBUTE_TAG 4\n    #define MAL_IDENTIFIER_ATTRIBUTE_TAG 5\n    #define MAL_OCTET_ATTRIBUTE_TAG 6\n    #define MAL_UOCTET_ATTRIBUTE_TAG 7\n    #define MAL_SHORT_ATTRIBUTE_TAG 8\n    #define MAL_USHORT_ATTRIBUTE_TAG 9\n    #define MAL_INTEGER_ATTRIBUTE_TAG 10\n    #define MAL_UINTEGER_ATTRIBUTE_TAG 11\n    #define MAL_LONG_ATTRIBUTE_TAG 12\n    #define MAL_ULONG_ATTRIBUTE_TAG 13\n    #define MAL_STRING_ATTRIBUTE_TAG 14\n    #define MAL_TIME_ATTRIBUTE_TAG 15\n    #define MAL_FINETIME_ATTRIBUTE_TAG 16\n    #define MAL_URI_ATTRIBUTE_TAG 17\n\n\n\n\nDestructor\n\n\nDeletes the union content.\nDo not destroy the union itself which is not an allocated structure.\n\n\n    void mal_attribute_destroy(union mal_attribute_t *self_p,\n        unsigned char attribute_tag);\n\n\n\n\nAttribute short forms\n\n\nThese identifiers are transmitted in case of \nMAL Element\n polymorphism.\n\n\n    #define MAL_BLOB_SHORT_FORM 0x1000001000001L\n    #define MAL_BOOLEAN_SHORT_FORM 0x1000001000002L\n    #define MAL_DURATION_SHORT_FORM 0x1000001000003L\n    #define MAL_FLOAT_SHORT_FORM 0x1000001000004L\n    #define MAL_DOUBLE_SHORT_FORM 0x1000001000005L\n    #define MAL_IDENTIFIER_SHORT_FORM 0x1000001000006L\n    #define MAL_OCTET_SHORT_FORM 0x1000001000007L\n    #define MAL_UOCTET_SHORT_FORM 0x1000001000008L\n    #define MAL_SHORT_SHORT_FORM 0x1000001000009L\n    #define MAL_USHORT_SHORT_FORM 0x100000100000AL\n    #define MAL_INTEGER_SHORT_FORM 0x100000100000BL\n    #define MAL_UINTEGER_SHORT_FORM 0x100000100000CL\n    #define MAL_LONG_SHORT_FORM 0x100000100000DL\n    #define MAL_ULONG_SHORT_FORM 0x100000100000EL\n    #define MAL_STRING_SHORT_FORM 0x100000100000FL\n    #define MAL_TIME_SHORT_FORM 0x10000010000010L\n    #define MAL_FINETIME_SHORT_FORM 0x10000010000011L\n    #define MAL_URI_SHORT_FORM 0x10000010000012L", 
            "title": "Attributes"
        }, 
        {
            "location": "/mal_attributes/#mal-attribute-api", 
            "text": "The MAL Attribute API defines the  C  types used to represent the MAL attributes.", 
            "title": "MAL Attribute API"
        }, 
        {
            "location": "/mal_attributes/#boolean-type", 
            "text": "Definition of type  MAL::Boolean :      typedef bool mal_boolean_t;", 
            "title": "Boolean type"
        }, 
        {
            "location": "/mal_attributes/#integer-types", 
            "text": "Definition of types  MAL::Octet ,  MAL::UOctet ,  MAL::Short ,  MAL::UShort ,  MAL::Integer ,  MAL::UInteger ,  MAL::Long ,  MAL::ULong :      typedef char mal_octet_t;\n    typedef unsigned char mal_uoctet_t;\n    typedef short mal_short_t;\n    typedef unsigned short mal_ushort_t;\n    typedef int mal_integer_t;\n    typedef unsigned int mal_uinteger_t;\n    typedef long mal_long_t;\n    typedef unsigned long mal_ulong_t;", 
            "title": "Integer types"
        }, 
        {
            "location": "/mal_attributes/#floating-point-types", 
            "text": "Definition of types  MAL::Float ,  MAL::Double .      typedef float mal_float_t;\n    typedef double mal_double_t;", 
            "title": "Floating point types"
        }, 
        {
            "location": "/mal_attributes/#dates", 
            "text": "Definition of types  MAL::Time ,  MAL::FineTime :      typedef unsigned long mal_time_t;\n    typedef unsigned long mal_finetime_t;", 
            "title": "Dates"
        }, 
        {
            "location": "/mal_attributes/#duration", 
            "text": "Definition of type  MAL::Duration :      typedef float mal_duration_t;", 
            "title": "Duration"
        }, 
        {
            "location": "/mal_attributes/#string-type", 
            "text": "The  char  type is used to represent strings. If the characters are not in the ASCII format\n(MAL specifies Unicode), then a character may be represented by several bytes. In this case,\nthe  C  functions dealing ASCII strings are no longer usable.  Definition of types  MAL::String ,  MAL::Identifier ,  MAL::URI :      typedef char mal_string_t;\n    typedef char mal_identifier_t;\n    typedef char mal_uri_t;", 
            "title": "String type"
        }, 
        {
            "location": "/mal_attributes/#constructor", 
            "text": "Dynamically allocates a new string from an existing string. \nThis function should be called when a MAL string is built from a statically defined chain.      mal_ attribute _t *mal_ attribute _new(char *char_content);", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_attributes/#string-length-ascii", 
            "text": "Returns the number of characters (encoded on 1 byte) in the string before the final null character ( \\0 ).      size_t mal_ attribute _get_char_count(mal_ attribute _t *self)", 
            "title": "String length (ASCII)"
        }, 
        {
            "location": "/mal_attributes/#string-copy", 
            "text": "When the same string must be used in two different fields of the same MAL structure or in two different MAL structures (composite, list), then it is necessary to duplicate the MAL string. Do never assign the same MAL string to different fields.      mal_ attribute _t *attribute2 = mal_ attribute _new(attribute1);", 
            "title": "String copy"
        }, 
        {
            "location": "/mal_attributes/#destructeur", 
            "text": "Deletes the string.      mal_ attribute _destroy(mal_ attribute _t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_attributes/#blob", 
            "text": "A class is defined for the type Blob in order to keep the size of the corresponding byte array (not accessible in C).", 
            "title": "Blob"
        }, 
        {
            "location": "/mal_attributes/#constructeur", 
            "text": "Declaration:      mal_blob_t *mal_blob_new(unsigned int length);  Parameter:   length : Number of bytes in the Blob.", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_attributes/#getters", 
            "text": "Two functions are defined to access the fields of Blob:      char *mal_blob_get_content(mal_blob_t *self);\n    unsigned int mal_blob_get_length(mal_blob_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/mal_attributes/#destructeur_1", 
            "text": "Deletes the Blob and its content.      void mal_blob_destroy(mal_blob_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_attributes/#mal-attribute-polymorphism", 
            "text": "To handle the case of MAL Attribute polymorphism, a class is defined with the following elements:   tags that identify the real type of the attribute,  a  C  union allowing the manipulation of the value of the attribute according to the associated tag,  a destructor.", 
            "title": "MAL Attribute polymorphism"
        }, 
        {
            "location": "/mal_attributes/#attribute-union", 
            "text": "A  C  union  mal_attribute_t  is defined to allow the MAL attribute polymorphism.      union mal_attribute_t {\n      mal_blob_t *blob_value;\n      mal_boolean_t boolean_value;\n      mal_double_t double_value;\n      mal_float_t float_value;\n      mal_octet_t octet_value;\n      mal_uoctet_t uoctet_value;\n      mal_short_t short_value;\n      mal_ushort_t ushort_value;\n      mal_integer_t integer_value;\n      mal_uinteger_t uinteger_value;\n      mal_long_t long_value;\n      mal_ulong_t ulong_value;\n      mal_string_t *string_value;\n      mal_identifier_t *identifier_value;\n      mal_uri_t *uri_value;\n      mal_time_t time_value;\n      mal_finetime_t finetime_value;\n      mal_duration_t duration_value;\n    };", 
            "title": "Attribute union"
        }, 
        {
            "location": "/mal_attributes/#attribute-tags", 
            "text": "These identifiers are transmitted in case of  MAL Attribute  polymorphism.      #define MAL_BLOB_ATTRIBUTE_TAG 0\n    #define MAL_BOOLEAN_ATTRIBUTE_TAG 1\n    #define MAL_DURATION_ATTRIBUTE_TAG 2\n    #define MAL_FLOAT_ATTRIBUTE_TAG 3\n    #define MAL_DOUBLE_ATTRIBUTE_TAG 4\n    #define MAL_IDENTIFIER_ATTRIBUTE_TAG 5\n    #define MAL_OCTET_ATTRIBUTE_TAG 6\n    #define MAL_UOCTET_ATTRIBUTE_TAG 7\n    #define MAL_SHORT_ATTRIBUTE_TAG 8\n    #define MAL_USHORT_ATTRIBUTE_TAG 9\n    #define MAL_INTEGER_ATTRIBUTE_TAG 10\n    #define MAL_UINTEGER_ATTRIBUTE_TAG 11\n    #define MAL_LONG_ATTRIBUTE_TAG 12\n    #define MAL_ULONG_ATTRIBUTE_TAG 13\n    #define MAL_STRING_ATTRIBUTE_TAG 14\n    #define MAL_TIME_ATTRIBUTE_TAG 15\n    #define MAL_FINETIME_ATTRIBUTE_TAG 16\n    #define MAL_URI_ATTRIBUTE_TAG 17", 
            "title": "Attribute tags"
        }, 
        {
            "location": "/mal_attributes/#destructor", 
            "text": "Deletes the union content.\nDo not destroy the union itself which is not an allocated structure.      void mal_attribute_destroy(union mal_attribute_t *self_p,\n        unsigned char attribute_tag);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_attributes/#attribute-short-forms", 
            "text": "These identifiers are transmitted in case of  MAL Element  polymorphism.      #define MAL_BLOB_SHORT_FORM 0x1000001000001L\n    #define MAL_BOOLEAN_SHORT_FORM 0x1000001000002L\n    #define MAL_DURATION_SHORT_FORM 0x1000001000003L\n    #define MAL_FLOAT_SHORT_FORM 0x1000001000004L\n    #define MAL_DOUBLE_SHORT_FORM 0x1000001000005L\n    #define MAL_IDENTIFIER_SHORT_FORM 0x1000001000006L\n    #define MAL_OCTET_SHORT_FORM 0x1000001000007L\n    #define MAL_UOCTET_SHORT_FORM 0x1000001000008L\n    #define MAL_SHORT_SHORT_FORM 0x1000001000009L\n    #define MAL_USHORT_SHORT_FORM 0x100000100000AL\n    #define MAL_INTEGER_SHORT_FORM 0x100000100000BL\n    #define MAL_UINTEGER_SHORT_FORM 0x100000100000CL\n    #define MAL_LONG_SHORT_FORM 0x100000100000DL\n    #define MAL_ULONG_SHORT_FORM 0x100000100000EL\n    #define MAL_STRING_SHORT_FORM 0x100000100000FL\n    #define MAL_TIME_SHORT_FORM 0x10000010000010L\n    #define MAL_FINETIME_SHORT_FORM 0x10000010000011L\n    #define MAL_URI_SHORT_FORM 0x10000010000012L", 
            "title": "Attribute short forms"
        }, 
        {
            "location": "/mal_encoding/", 
            "text": "encoding APIs\n\n\nBased on our experience of the MalBinary and MalSplitBinary formats, we propose a generic encoding API for all encoding formats.\nIf it is not suitable to a particular encoding format, it is still possible to define format specific functions. For that reason the generated encoding functions may use code specific to the encoding format.\n\n\nThe user code does not depend on specific encoding APIs, except when the application needs to encode or decode data explicitely.\n\n\nThe encoding functions generated for each data structure may call either the generic encoding functions or possible format specific functions. The stub generator knows the specificities of each format. It may call the format specific functions, or produce format specific code.\n\n\nThe C name for the encoding format defined in the MAL/SPP book is: \nmalbinary\n.\nThe C name for the encoding format defined in the MAL/TCP book is: \nmalsplitbinary\n.\nThose names are strings used in the naming of the APIs.\n\n\nDefinitions\n\n\n    \nformat\n.h\n\n\n\n\nA code is defined to uniquely identify the encoding format.\n\n\n    #define \nFORMAT\n_FORMAT_CODE \nunique number\n\n\n\n\n\nData to encode\n\n\nThe data to encode are:\n\n\n\n\nMAL attributes (whose C types are defined in section 5)\n\n\nunion type \nmal_attribute_t\n\n\nformat specific data; for example : the presence flag for a nullable field, the size of a list, the value of an enumerated value.\n\n\n\n\nEncoding and decoding an error code is performed with the encoding functions for the \nMAL Uinteger\n type.\n\n\nFor each data type to encode, three functions are defined:\n\n\n\n\na function to get the size required to encode the data; it accepts the current state of the computed size as input parameter, adds the size of the data, and return the updated size value; the generic API allows for complex size computation, such as the one defined in the split binary encoding;\n\n\na function to encode the data in a preallocated buffer;\n\n\na function to decode the data.\n\n\n\n\nEncoder\n\n\n    mal_encoder.h\n\n\n\n\nComputing the encoding length\n\n\nThe function adds the encoding length to an initial value given as a parameter.\nThe length parameter is generalized as a cursor to manage on various encoding formats.\nThe generic mal_encoder_\n functions are mapped to specific \\\n_encoder_\n functions declared in the \\\n_encoder.h file.\n\n\nPrototype:\n\n\n\n\nIf the data type is not a pointer (non pointer Attributes or specific data):\n\n\n\n\n    int mal_encoder_add_\ndata\n_encoding_length(\n      mal_encoder_t *self, mal_\ndata type\n_t to_encode, void *cursor);\n\n\n\n\n\n\nIf the data type is a pointer (pointer Attributes or specific data):\n\n\n\n\n    int mal_encoder_add_\ndata\n_encoding_length(\n      mal_encoder_t *self, mal_\ndata type\n_t *to_encode, void *cursor);\n\n\n\n\n\n\nFor the type \nMAL::Attribute\n (polymorphism of Attribute):\n\n\n\n\n    int mal_encoder_add_attribute_encoding_length(\n      \nformat\n_encoder_t *self, unsigned char attribute_tag,\n      union mal_attribute_t to_encode, void *cursor);\n\n\n\n\nParameters:\n\n\n\n\nself\n : the encoding context\n\n\nattribute_tag\n : the identifier of the Attribute type (with polymorphism of Attribute)\n\n\nto_encode\n : the data to encode\n\n\ncursor\n : initial and updated value of the encoding length\n\n\n\n\nResult: \n\n\nError code\n\n\nEncoding\n\n\nThe function encodes the data in a buffer and at an index defined by the generic cursor parameter.\nThe generic mal_encoder_\n functions are mapped to specific \\\n_encoder_\n functions declared in the \\\n_encoder.h file.\nThe specific functions cast the generic cursor into a \\\n_cursor_t pointer.\n\n\nPrototype:\n\n\n\n\nIf the data type is not a pointer (non pointer Attributes or specific data):\n\n\n\n\n    int mal_encoder_encode_\ndata\n(mal_encoder_t *self,\n      void *cursor, mal_\ndata type\n_t to_encode);\n\n\n\n\n\n\nIf the data type is a pointer (pointer Attributes or specific data):\n\n\n\n\n    int mal_encoder_encode_\ndata\n(mal_encoder_t *self,\n      void *cursor, mal_\ndata type\n_t *to_encode);\n\n\n\n\n\n\nFor the type \nMAL::Attribute\n (polymorphism of Attribute):\n\n\n\n\n    int mal_encoder_encode_attribute(\n      mal_encoder_t *self, void *cursor,\n      unsigned char attribute_tag, mal_attribute_t to_encode);\n\n\n\n\nParameters:\n\n\n\n\nself\n : the encoding context\n\n\ncursor\n : a virtual index in the encoding structures\n\n\nattribute_tag\n : the identifier of the Attribute type (with polymorphism of Attribute)\n\n\nto_encode\n : the data to encode\n\n\n\n\nResult: \n\n\nError code\n\n\nDecoder\n\n\n    mal_decoder.h\n\n\n\n\nA decoding function is defined for each type to decode\nThe generic mal_decoder_\n functions are mapped to specific \\\n_decoder_\n functions declared in the \\\n_decoder.h file.\n\n\nPrototype:\n\n\n\n\nIf the data type is not a pointer (non pointer Attributes or specific data):\n\n\n\n\n    int mal_decoder_decode_\ndata\n(mal_decoder_t *self,\n      void *cursor, mal_\ndata type\n_t *result);\n\n\n\n\n\n\nIf the data type is a pointer (pointer Attributes or specific data):\n\n\n\n\n    int mal_decoder_decode_\ndata\n(mal_decoder_t *self,\n      void *cursor, mal_\ndata type\n_t **result);\n\n\n\n\n\n\nFor the type \nMAL::Attribute\n (polymorphism of Attribute):\n\n\n\n\n    int mal_decoder_decode_attribute(\n      mal_decoder_t *self, void *cursor,\n      unsigned char attribute_tag, mal_attribute_t *result);\n\n\n\n\nParameters:\n\n\n\n\nself\n : the encoding context\n\n\ncursor\n : a virtual index in the encoding structures\n\n\nattribute_tag\n : the identifier of the Attribute type (with polymorphism of Attribute)\n\n\nresult\n : the decoded data\n\n\n\n\nResult: \n\n\nError code\n\n\nFormat \nmalbinary\n and \nmalsplitbinary\n\n\nBoth formats require similar specific data. They have been declared in the generic encoding API.\n\n\nSpecific data\n\n\n\n\n\n\n\n\nData\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npresence_flag\n\n\nbool\n\n\nField used for a Nullable element. \nTRUE\n when the field is defined (non null value), \nFALSE\n when it is not (null value).\n\n\n\n\n\n\nlist_size\n\n\nunsigned int\n\n\nField defining the size of a MAL list\n\n\n\n\n\n\nsmall_enum\n\n\nint\n\n\nField used for an enumerated value of a small enumeration type (size lower than 2^8)\n\n\n\n\n\n\nmedium_enum\n\n\nint\n\n\nField used for an enumerated value of a medium enumeration type (size lower than 2^16)\n\n\n\n\n\n\nlarge_enum\n\n\nint\n\n\nField used for an enumerated value of a large enumeration type (size lower than 2^32)\n\n\n\n\n\n\nshort_form\n\n\nlong\n\n\nType identifier defined in section 4.1.2 of the MAL book. It is used in case of general polymorphism.\n\n\n\n\n\n\nattribute_tag\n\n\nunsigned char\n\n\nAttribute type identifier: \nshort form\n of the Attribute minus 1 (cf section 5.2.2 of the MAL/SPP book)", 
            "title": "Encoding"
        }, 
        {
            "location": "/mal_encoding/#encoding-apis", 
            "text": "Based on our experience of the MalBinary and MalSplitBinary formats, we propose a generic encoding API for all encoding formats.\nIf it is not suitable to a particular encoding format, it is still possible to define format specific functions. For that reason the generated encoding functions may use code specific to the encoding format.  The user code does not depend on specific encoding APIs, except when the application needs to encode or decode data explicitely.  The encoding functions generated for each data structure may call either the generic encoding functions or possible format specific functions. The stub generator knows the specificities of each format. It may call the format specific functions, or produce format specific code.  The C name for the encoding format defined in the MAL/SPP book is:  malbinary .\nThe C name for the encoding format defined in the MAL/TCP book is:  malsplitbinary .\nThose names are strings used in the naming of the APIs.", 
            "title": "encoding APIs"
        }, 
        {
            "location": "/mal_encoding/#definitions", 
            "text": "format .h  A code is defined to uniquely identify the encoding format.      #define  FORMAT _FORMAT_CODE  unique number", 
            "title": "Definitions"
        }, 
        {
            "location": "/mal_encoding/#data-to-encode", 
            "text": "The data to encode are:   MAL attributes (whose C types are defined in section 5)  union type  mal_attribute_t  format specific data; for example : the presence flag for a nullable field, the size of a list, the value of an enumerated value.   Encoding and decoding an error code is performed with the encoding functions for the  MAL Uinteger  type.  For each data type to encode, three functions are defined:   a function to get the size required to encode the data; it accepts the current state of the computed size as input parameter, adds the size of the data, and return the updated size value; the generic API allows for complex size computation, such as the one defined in the split binary encoding;  a function to encode the data in a preallocated buffer;  a function to decode the data.", 
            "title": "Data to encode"
        }, 
        {
            "location": "/mal_encoding/#encoder", 
            "text": "mal_encoder.h", 
            "title": "Encoder"
        }, 
        {
            "location": "/mal_encoding/#computing-the-encoding-length", 
            "text": "The function adds the encoding length to an initial value given as a parameter.\nThe length parameter is generalized as a cursor to manage on various encoding formats.\nThe generic mal_encoder_  functions are mapped to specific \\ _encoder_  functions declared in the \\ _encoder.h file.  Prototype:   If the data type is not a pointer (non pointer Attributes or specific data):       int mal_encoder_add_ data _encoding_length(\n      mal_encoder_t *self, mal_ data type _t to_encode, void *cursor);   If the data type is a pointer (pointer Attributes or specific data):       int mal_encoder_add_ data _encoding_length(\n      mal_encoder_t *self, mal_ data type _t *to_encode, void *cursor);   For the type  MAL::Attribute  (polymorphism of Attribute):       int mal_encoder_add_attribute_encoding_length(\n       format _encoder_t *self, unsigned char attribute_tag,\n      union mal_attribute_t to_encode, void *cursor);  Parameters:   self  : the encoding context  attribute_tag  : the identifier of the Attribute type (with polymorphism of Attribute)  to_encode  : the data to encode  cursor  : initial and updated value of the encoding length   Result:   Error code", 
            "title": "Computing the encoding length"
        }, 
        {
            "location": "/mal_encoding/#encoding", 
            "text": "The function encodes the data in a buffer and at an index defined by the generic cursor parameter.\nThe generic mal_encoder_  functions are mapped to specific \\ _encoder_  functions declared in the \\ _encoder.h file.\nThe specific functions cast the generic cursor into a \\ _cursor_t pointer.  Prototype:   If the data type is not a pointer (non pointer Attributes or specific data):       int mal_encoder_encode_ data (mal_encoder_t *self,\n      void *cursor, mal_ data type _t to_encode);   If the data type is a pointer (pointer Attributes or specific data):       int mal_encoder_encode_ data (mal_encoder_t *self,\n      void *cursor, mal_ data type _t *to_encode);   For the type  MAL::Attribute  (polymorphism of Attribute):       int mal_encoder_encode_attribute(\n      mal_encoder_t *self, void *cursor,\n      unsigned char attribute_tag, mal_attribute_t to_encode);  Parameters:   self  : the encoding context  cursor  : a virtual index in the encoding structures  attribute_tag  : the identifier of the Attribute type (with polymorphism of Attribute)  to_encode  : the data to encode   Result:   Error code", 
            "title": "Encoding"
        }, 
        {
            "location": "/mal_encoding/#decoder", 
            "text": "mal_decoder.h  A decoding function is defined for each type to decode\nThe generic mal_decoder_  functions are mapped to specific \\ _decoder_  functions declared in the \\ _decoder.h file.  Prototype:   If the data type is not a pointer (non pointer Attributes or specific data):       int mal_decoder_decode_ data (mal_decoder_t *self,\n      void *cursor, mal_ data type _t *result);   If the data type is a pointer (pointer Attributes or specific data):       int mal_decoder_decode_ data (mal_decoder_t *self,\n      void *cursor, mal_ data type _t **result);   For the type  MAL::Attribute  (polymorphism of Attribute):       int mal_decoder_decode_attribute(\n      mal_decoder_t *self, void *cursor,\n      unsigned char attribute_tag, mal_attribute_t *result);  Parameters:   self  : the encoding context  cursor  : a virtual index in the encoding structures  attribute_tag  : the identifier of the Attribute type (with polymorphism of Attribute)  result  : the decoded data   Result:   Error code", 
            "title": "Decoder"
        }, 
        {
            "location": "/mal_encoding/#format-malbinary-and-malsplitbinary", 
            "text": "Both formats require similar specific data. They have been declared in the generic encoding API.", 
            "title": "Format malbinary and malsplitbinary"
        }, 
        {
            "location": "/mal_encoding/#specific-data", 
            "text": "Data  Type  Description      presence_flag  bool  Field used for a Nullable element.  TRUE  when the field is defined (non null value),  FALSE  when it is not (null value).    list_size  unsigned int  Field defining the size of a MAL list    small_enum  int  Field used for an enumerated value of a small enumeration type (size lower than 2^8)    medium_enum  int  Field used for an enumerated value of a medium enumeration type (size lower than 2^16)    large_enum  int  Field used for an enumerated value of a large enumeration type (size lower than 2^32)    short_form  long  Type identifier defined in section 4.1.2 of the MAL book. It is used in case of general polymorphism.    attribute_tag  unsigned char  Attribute type identifier:  short form  of the Attribute minus 1 (cf section 5.2.2 of the MAL/SPP book)", 
            "title": "Specific data"
        }, 
        {
            "location": "/mal_api/", 
            "text": "MAL API\n\n\nMAL API allows the use of MAL-level concepts:\n\n\n\n\nconcepts defined by the MAL specification (Blue Book).\n\n\nspecific concepts to the C API, defined in section 2.\n\n\n\n\nThe MAL API contains the Area API generated from the definition of the MAL Area.\n\n\nDefinition\n\n\nmal.h\n\n\n\n\nVirtual function to create an URI\n\n\nFunction to be provided by a MAL binding to create a URI.\n\n\nDeclaration:\n\n\ntypedef mal_uri_t *mal_binding_ctx_create_uri_fn(\n  void *mal_binding_ctx,\n  char *id);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings. \n\n\nid\n: unique identifier to include in the created URI.\n\n\n\n\nResult: \n\n\n\n\nCreated URI.\n\n\n\n\nVirtual function to create an end-point\n\n\nFunction to be provided by a MAL binding to create an end-point.\n\n\nDeclaration:\n\n\ntypedef void *mal_binding_ctx_create_endpoint_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmal_endpoint\n: MAL end-point corresponding to the physical transport end-point to create.\n\n\n\n\nResult:\n\n\n\n\nThe pointer to the physical end-point created (untyped to allow the use of multiple bindings, for example ZMQ socket).\n\n\n\n\nVirtual function to delete an end-point\n\n\nFunction to be provided by a MAL binding to destroy an end-point.\n\n\nDeclaration:\n\n\ntypedef void mal_binding_ctx_destroy_endpoint_fn(\n  void *mal_binding_ctx,\n  void **endpoint_p);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nendpoint_p\n: the end-point to delete.\n\n\n\n\nVirtual function to create a poller\n\n\nFunction to be provided by a MAL binding to create a poller.\n\n\nDeclaration:\n\n\ntypedef void *mal_binding_ctx_create_poller_fn(\n  void *mal_binding_ctx,\n  mal_poller_t *mal_poller);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmal_poller\n: the MAL poller corresponding to the physical transport poller to create.\n\n\n\n\nResult: \n\n\n\n\nThe pointer to the physical poller created (untyped to allow the use of multiple bindings, for example ZMQ zpoller).\n\n\n\n\nVirtual function to destroy a poller\n\n\nFunction to be provided by a MAL binding to destroy a poller.\n\n\nDeclaration:\n\n\ntypedef void mal_binding_ctx_destroy_poller_fn(\n  void *mal_binding_ctx,\n  void **poller_p);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\npoller_p\n: poller to destroy.\n\n\n\n\nVirtual function to add (resp. remove) an end-point to a poller\n\n\nFunctions to be provided by a MAL binding to add or remove an end-point to a poller.\n\n\nDeclaration:\n\n\ntypedef int mal_binding_ctx_poller_add_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\ntypedef int mal_binding_ctx_poller_del_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmal_poller\n: MAL poller to use.\n\n\nmal_endpoint\n: MAL end-point to add (resp. remove) to the specified poller.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nVirtual function for waiting a message on a poller\n\n\nFunction to be provided by a MAL binding to wait on a poller.\n\n\nDeclaration:\n\n\ntypedef int mal_binding_ctx_poller_wait_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmal_poller\n: MAL poller to use.\n\n\nmal_endpoint\n: MAL end-point on which a message is pending.\n\n\ntimeout\n: the maximum waiting time, possibly infinite (-1).\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nVirtual function to send a message\n\n\nFunction to be provided by a MAL binding to send a message.\nThis function is called by \nmal_ctx_send_message\n (see section 7.4.2).\n\n\nDeclaration:\n\n\ntypedef int mal_binding_ctx_send_message_fn(\n    void *mal_binding_ctx,\n    mal_endpoint_t *mal_endpoint,\n    mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmal_endpoint\n: MAL end-point sending the message.\n\n\nmessage\n: MAL message to send.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nVirtual function to receive a message\n\n\nFunction to be provided by a MAL binding to receive a message.\nThis function is called by \nmal_ctx_recv_message\n (see section 7.4.3).\n\n\nDeclaration:\n\n\ntypedef int mal_binding_ctx_recv_message_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t **message);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmal_endpoint\n: MAL end-point receiving the message.\n\n\nmessage\n: receiving message.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nVirtual function to delete a MAL message\n\n\nFunction to be provided by a MAL binding to destroy a message.\nAllows the transport to free resources (field \nbody_owner\n) that it has associated with the message before its destruction.\n\n\nDeclaration:\n\n\ntypedef int mal_binding_ctx_destroy_message_fn(\n    void *mal_binding_ctx,\n    mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nmal_binding_ctx\n: transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.\n\n\nmessage\n: MAL message to delete.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nContexte MAL\n\n\nmal_ctx.h\n\n\n\n\nConstructor\n\n\nDeclaration:\n\n\nmal_ctx_t *mal_ctx_new(void);\n\n\n\n\nResult: \n\n\n\n\nThe created MAL context.\n\n\n\n\nURI creation\n\n\nDeclaration:\n\n\nmal_uri_t *mal_ctx_create_uri(mal_ctx_t *self, char *id);\n\n\n\n\nParameters:\n\n\n\n\nself\n: MAL context.\n\n\nid\n: unique identifier in the transport context.\n\n\n\n\nResult: \n\n\n\n\nThe created URI.\n\n\n\n\nPoller creation\n\n\nDeclaration:\n\n\nvoid *mal_ctx_create_poller(\n  mal_ctx_t *self,\n  mal_poller_t *poller);\n\n\n\n\nParameters:\n\n\n\n\nself\n: MAL context.\n\n\npoller\n: MAL poller corresponding to the new physical poller.\n\n\n\n\nResult: \n\n\n\n\nA pointer to the created physical poller (untyped to avoid dependence with physical concepts of transport, for example a ZMQ zpoller).\n\n\n\n\nend-point creation\n\n\nDeclaration:\n\n\nvoid *mal_ctx_create_endpoint(\n  mal_ctx_t *self,\n  mal_endpoint_t *endpoint);\n\n\n\n\nParameters:\n\n\n\n\nself\n: MAL context.\n\n\nendpoint\n: MAL end-point corresponding to the new physical end-point.\n\n\n\n\nResult: \n\n\n\n\nA pointer to the created physical end-point (untyped to avoid dependence with physical concepts of transport, for example a ZMQ socket).\n\n\n\n\nMAL message sending\n\n\nThis function is used by message sending functions of MAL end-points (section 7.4.2). It calls the message sending function offered by the underlying transport (section 7.1.8).\n\n\nThe use of this function is restricted to MAL end-point.\n\n\nDeclaration:\n\n\nint mal_ctx_send_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: MAL context.\n\n\nmal_endpoint\n: MAL end-point sending the message.\n\n\nmessage\n: MAL message to send.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nMAL message reception\n\n\nThis function is used by the message receiving functions of MAL end-points (section 7.4.3). It calls the message receiving function offered by underlying transport (7.1.9).\n\n\nThe use of this function is restricted to MAL end-point.\n\n\nDeclaration:\n\n\nint mal_ctx_recv_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t **message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: MAL context.\n\n\nmal_endpoint\n: MAL end-point receiving the message.\n\n\nmessage\n: MAL message received.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nDestructor\n\n\nDeletes the MAL context.\n\n\n  void mal_ctx_destroy(mal_ctx_t **self_p);\n\n\n\n\nParameters:\n\n\n\n\nself_p\n: Handle to the MAL context to delete.\n\n\n\n\nMAL message\n\n\nConstructor\n\n\nAllocate the memory chunk needed for the message body.\n\n\nDeclaration:\n\n\nmal_message_t *mal_message_new(\n  mal_blob_t *authentication_id,\n  mal_qoslevel_t qoslevel, mal_uinteger_t priority, mal_list_t *domain,\n  mal_identifier_t *network_zone, mal_sessiontype_t session,\n  mal_identifier_t *session_name, unsigned int body_length);\n\n\n\n\nParameters:\n\n\n\n\nMAL header fields.\n\n\nMessage body size in bytes.\n\n\n\n\nResult:\n\n\n\n\nThe new MAL message.\n\n\n\n\nInitialisation\n\n\nInitialization of the header fields corresponding to the operation and interaction stage.\n\n\nDeclaration:\n\n\nvoid mal_message_init(mal_message_t *self, mal_ushort_t service_area,\n  mal_uoctet_t area_version, mal_ushort_t service,\n  mal_ushort_t operation,\n  mal_interactiontype_t interaction_type,\n  mal_uoctet_t interaction_stage);\n\n\n\n\nParameters:\n\n\n\n\nself\n: a pointer to the MAL message to initialize.\n\n\nMAL header fields.\n\n\n\n\nDestructor\n\n\nDeletes the MAL message and the corresponding body.\nCalls the virtual function provided by the transport API.\nDeclaration:\n\n\nvoid mal_message_destroy(mal_message_t **self_p, mal_ctx_t *mal_ctx);\n\n\n\n\nParameters:\n\n\n\n\nself\n: an handle to the MAL message to destroy.\n\n\nThe MAL context needed to free associated resources in transport binding if needed.\n\n\n\n\nGetters et setters\n\n\nThe fields defined in the following table are accessible through getter and setter methods.\n\n\n\n\n\n\n\n\nChamp\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmal header field\n\n\nmal header field type\n\n\nMAL header fields as described in the MAL blue book.\n\n\n\n\n\n\nfree_\nheader field\n\n\nbool\n\n\nFlags indicating whether the corresponding MAL header fields of type pointer must be destroyed when the MAL message is deleted.\n\n\n\n\n\n\nbody\n\n\nchar *\n\n\nMessage Body encoded.\n\n\n\n\n\n\nbody_offset\n\n\nunsigned int\n\n\nStart offset of the message body.\n\n\n\n\n\n\nbody_length\n\n\nunsigned int\n\n\nSize of the message body.\n\n\n\n\n\n\nbody_owner\n\n\nvoid *\n\n\nResource associated with the message by the transport. Should be released during the destruction of the message.\n\n\n\n\n\n\n\n\nPresence flags apply to the following fields: \nURI To\n, \nAuthentication Id\n, \nURI From\n, \nDomain\n, \nNetwork Zone\n, \nSession Name\n.\nBy default, the behavior is:\n\n\n\n\nIf the MAL message is created through the constructor then the flag is false. The MAL header fields are transmitted by the application when calling the constructor, so they do not have to be released.\n\n\nIf the MAL message is created by the transport during a reception and if the header fields have been decoded (not recovered from a configuration service) then the flag is true. The MAL header fields are owned by the message and should be destroyed with it.\n\n\n\n\nEnd-Point MAL\n\n\nEach endpoint should be handled by a single execution flow.\n\n\nConstructor\n\n\nCreate an endpoint instance identified by a MAL URI.\nA \nTransaction Id\n counter is managed.\n\n\nDeclaration:\n\n\nmal_endpoint_t *mal_endpoint_new(mal_ctx_t *mal_ctx, mal_uri_t *uri);\n\n\n\n\nParameters:\n\n\n\n\nmal_ctx\n: a pointer to the MAL context.\n\n\nuri\n: MAL URI identifying the MAL endpoint.\n\n\n\n\nThe API provides two functions to retrieve the URL and context MAL corresponding to an end-point:\n\n\nmal_uri_t *mal_endpoint_get_uri(mal_endpoint_t *self);\nmal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);\n\n\n\n\nMAL message sending\n\n\nTwo message sending functions are defined:\n\n\n\n\nA funtion to initiate an interaction (first stage). This function sets the URI fields of the message: the destination URI of the message is set with the \nuri_to\n parameter, and the source URI of the message is set with the endpoint URI. If the \nset_tid\n flag is true then the \nTransaction Id\n field is set with the next value of the \nTransactionId\n counter handled by the endpoint. Otherwise the original value of the \nTransaction Id\n field is left unchanged.\n\n\nA function for the next stages of the interaction. This function sets the URI fields of the message: the destination URI of the message is set with the \nuri_from\n field of the initiation message, and the source URI of the message is set with the endpoint URI. The \nTransaction Id\n field of the message is set with the \nTransaction Id\n field of the initiation message. The field \nIs Error Message\n is set with the value of the \nis_error_message\n parameter. counter.\n\n\n\n\nThe \nmal_ctx_send_message\n function (section 7.2.5) is called to send the MAL message.\n\n\nDeclaration:\n\n\nint mal_endpoint_init_operation(\n  mal_endpoint_t *self,\n  mal_message_t *message,\n  mal_uri_t *uri_to,\n  bool set_tid);\n\nint mal_endpoint_return_operation(\n  mal_endpoint_t *self,\n  mal_message_t *init_message,\n  mal_message_t *message,\n  bool is_error_message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: A pointer to the MAL endpoint sending the message.\n\n\nmessage\n: A pointer to the MAL message to send.\n\n\ninit_message\n: A pointer to the MAL message initiating the interaction.\n\n\nuri_to\n: The MAL URI of the message recipient.\n\n\nset_tid\n: Boolean indicating whether the field 'Transaction ID' of the message MAL should be affected or not.\n\n\nis_error_message\n:  Boolean indicating whether the message returns an error\n\n\n\n\nResult: \n\n\nError code.\n\n\nMAL message reception\n\n\nThe \nmal_endpoint_recv_message\n function allows to receive a message on the end-point.\nThis function blocks until receiving a message.\n\n\nDeclaration:\n\n\nint mal_endpoint_recv_message(\n    mal_endpoint_t *self,\n    mal_message_t **message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: A pointer to the MAL endpoint waiting for a message.\n\n\nmessage\n: The message received.\n\n\n\n\nResult: \n\n\nError code.\n\n\nDestructor\n\n\nDelete the endpoint.\n\n\nDeclaration:\n\n\nvoid mal_endpoint_destroy(mal_endpoint_t **self_p);\n\n\n\n\nMAL Poller\n\n\nEach MAL poller should be handled by a single execution flow.\n\n\nConstructor\n\n\nCreate a poller instance identified by a MAL URI.\n\n\nDeclaration:\n\n\n  mal_poller_t *mal_poller_new(mal_ctx_t *mal_ctx);\n\n\n\n\nParameters:\n\n\n\n\nmal_ctx\n: A pointer to the MAL context.\n\n\n\n\nThe API provides a function to retrieve the MAL context corresponding to the poller:\n\n\nmal_ctx_t *mal_poller_get_mal_ctx(mal_poller_t *self);\n\n\n\n\nAdd / Remove MAL endpoint\n\n\nTwos functions allow to add and remove a endpoint to the poller.\n\n\nDeclaration:\n\n\nint mal_poller_add_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *endpoint);\n\nint mal_poller_del_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *mal_endpoint);\n\n\n\n\nParameters:\n\n\n\n\nself\n: A pointer to the MAL poller.\n\n\nendpoint\n: A pointer to the MAL endpoint to add or remove.\n\n\n\n\nResult:\n\n\nError code.\n\n\nAttente de message MAL\n\n\nmal_poller_wait\n function allows to wait the reception of a MAL message on one of the endpoint handled by the poller.\nThis is a blocking function, it takes a time-out parameter.\n\n\nDeclaration:\n\n\nint mal_poller_wait(\n    mal_poller_t *self,\n    mal_endpoint_t **endpoint,\n    int timeout);\n\n\n\n\nParameters:\n\n\n\n\nself\n: A pointer to the poller waiting a MAL message.\n\n\nendpoint\n: An handle to the endpoint which received a message.\n\n\ntimeout\n: The maximum waiting time, possibly infinite (-1).\n\n\n\n\nResult:\n\n\nError code.\n\n\nDestructor\n\n\nDeletes the MAL poller. The associated endpoint should be destroyed explicitly.\n\n\nDeclaration:\n\n\n  void mal_poller_destroy(mal_oller_t **self_p);\n\n\n\n\nMAL Handler and routing\n\n\nA handler is a logical structure composed of a set of MAL message processing functions.\nThis set of functions depends of its role (provider, consumer, etc.) and interaction in\nwhich it operates (send, submit, etc.). Handlers run in the context of a routing structure\n(i e, an object of the class \nmal_routing\n, or router).\n\n\nThe router is linked to the MAL endpoint: it allows to register the handlers corresponding\nto different expected interactions, then on a message receipt it allows the activatation of\nthe corresponding handler to handle the message. The router shares its state with all its\nhandlers.\n\n\nHandler\n\n\nEach message processing function of the handler has the same signature defined below.\n\n\n\n\nthe state of the router,\n\n\na pointer to the MAL context,\n\n\na pointer the MAL endpoint,\n\n\na pointer to the message to process.\n\n\n\n\nThe corresponding signature is.\n\n\nDeclaration:\n\n\ntypedef int mal_routing_on_message_fn(\n  void *self,\n  mal_ctx_t *mal_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nstate\n: The state of the router (untyped to allow polymorphism).\n\n\nmal_ctx\n: A pointer to the MAL context.\n\n\nendpoint\n: A pointer to the MAL endpoint.\n\n\nmessage\n: A pointer to the message to process.\n\n\n\n\nConstructor\n\n\nCreate a router instance identified by the corresponding endpoint URI.\nNormally only a single router must be associated with a given MAL endpoint.\n\n\nDeclaration:\n\n\nmal_routing_t *mal_routing_new(mal_endpoint_t *endpoint, void *state);\n\n\n\n\nParameters:\n\n\n\n\nendpoint\n: A pointer to the MAL endpoint.\n\n\nstate\n: The state of the router (untyped to allow polymorphism).\n\n\n\n\nHandlers registering\n\n\nThe MAL router interface defines the set of functions for registering the interaction's handlers.\nEach function takes as parameters a pointer to the router's state itself, the identification of the area, version, identity of service and operation. Depending on the role of the handler and the operation type, the interface includes pointers to the functions allowing to process the messages corresponding to the interaction.\n\n\nL'interface defines a function to register an handler of \nSend\n interaction, and two functions to register the \nprovider\n and \nconsumer\n handlers of each interactions \nSubmit\n, \nRequest\n, \nInvoke\n et \nProgress\n:\n\n\nint mal_routing_register_provider_send_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_send);\n\nint mal_routing_register_provider_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_submit);\n\nint mal_routing_register_consumer_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack);\n\nint mal_routing_register_provider_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_request);\n\nint mal_routing_register_consumer_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_invoke);\n\nint mal_routing_register_consumer_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_progress);\n\nint mal_routing_register_consumer_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_update,\n    mal_routing_on_message_fn *on_response);\n\n\n\n\nL'interface also offers three functions to register \npublisher\n, \nsubscriber\n and \nbroker\n handlers for \nPublish/Subscribe\n interaction:\n\n\nint mal_routing_register_provider_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_publish_error,\n    mal_routing_on_message_fn *on_publish_register_ack,\n    mal_routing_on_message_fn *on_publish_deregister_ack);\n\nint mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify);\n\nint mal_routing_register_broker_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_notify_error,\n    mal_routing_on_message_fn *on_register,\n    mal_routing_on_message_fn *on_deregister,\n    mal_routing_on_message_fn *on_publish);\n\n\n\n\nFinally, the interface also provides a function to deregister a \nhandler\n:\n\n\nint mal_routing_remove_handler(\n    mal_routing_t *mal_routing,\n    handler_type_t type,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation);\n\n\n\n\nHandlers execution\n\n\nThe \nrouter\n interface provides a function to activate the rigth handler when receiving a MAL message.\nWhen called this function search the right handler in the list of registered handlers. If successful it\nactivates the handler by calling the function corresponding to the received message.\n\n\nDeclaration:\n\n\nint mal_routing_handle(mal_routing_t *self, mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: A pointer to the \nrouter\n.\n\n\nmessage\n: A pointer to the received message.\n\n\n\n\nDestructor\n\n\nDeletes the \nrouter\n and its state.\n\n\nvoid mal_routing_destroy(mal_routing_t **self_p);\n\n\n\n\nElement union\n\n\nA \nmal_element_t\n  union is defined to allow the polymorphism of \nElement\n.\n\n\nunion mal_element_t {\n  mal_blob_t *blob_value;\n  mal_boolean_t boolean_value;\n  mal_double_t double_value;\n  mal_float_t float_value;\n  mal_octet_t octet_value;\n  mal_uoctet_t uoctet_value;\n  mal_short_t short_value;\n  mal_ushort_t ushort_value;\n  mal_integer_t integer_value;\n  mal_uinteger_t uinteger_value;\n  mal_long_t long_value;\n  mal_ulong_t ulong_value;\n  mal_string_t *string_value;\n  mal_identifier_t *identifier_value;\n  mal_uri_t *uri_value;\n  mal_time_t time_value;\n  mal_finetime_t finetime_value;\n  mal_duration_t duration_value;\n  int enumerated_value;\n  void *composite_value;\n  void *list_value;\n};\n\n\n\n\nElement holder\n\n\nThis structure allows to manage the decoding in case of element polymorphism.\n\n\nConstructor\n\n\nDeclaration:\n\n\nmal_element_holder_t *mal_element_holder_new(void);\n\n\n\n\nGetters et setters\n\n\nDeclaration:\n\n\nbool mal_element_holder_get_presence_flag(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_presence_flag(mal_element_holder_t *self,\n  bool presence_flag);\n\nlong mal_element_holder_get_short_form(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_short_form(mal_element_holder_t *self,\n  long short_form);\n\nunion mal_element_t mal_element_holder_get_value(\n  mal_element_holder_t *self);\n\nvoid mal_element_holder_set_value(mal_element_holder_t *self,\n  union mal_element_t value);\n\n\n\n\nDestructor\n\n\nThis destructor frees only space allocated for the structure itself, not the union elements.\n\n\nDeclaration:\n\n\nvoid mal_element_holder_destroy(mal_element_holder_t **self_p);\n\n\n\n\nList of non-pointer attribute\n\n\nData structures defined to represent lists of \nattribute\n types which are not represented by a \nC\n pointer\n(see section 2.6). These lists are specific to each type of non-pointer \nAttribute\n.\nFor each list, two tables are defined:\n\n\n\n\npresence_flags\n: Table of presence flags for each of the items in the list.\n\n\ncontent\n: Table containing the values of each item of the list; if an item is null, its value in the\n  table can be assigned with any value.\n\n\n\n\nThe size of \npresence_flags\n and \ncontent\n tables should be the same.\n\n\nConstructor\n\n\nDeclaration:\n\n\nmal_\nattribute\n_list_t *mal_\nattribute\n_list_new(\n  unsigned int element_count);\n\n\n\n\nParameters:\n\n\n\n\nelement_count\n: Number of items in the list.\n\n\n\n\nGetter\n\n\nGetter functions are defined to access the fields:\n\n\nunsigned int mal_\nattribute\n_list_get_element_count(\n  mal_\nattribute\n_list_t *self);\n\nbool *mal_\nattribute\n_list_get_presence_flags(\n  mal_\nattribute\n_list_t *self);\n\nmal_\nattribute\n_t *mal_\nattribute\n_list_get_content(\n  mal_\nattribute\n_list_t *self);\n\n\n\n\nDestructor\n\n\nDeletes the list and its contents (\npresence_flags\n and \ncontent\n tables).\n\n\nDeclaration:\n\n\nvoid mal_\nattribute\n_list_destroy(mal_\nattribute\n_list_t **self_p);\n\n\n\n\nList of pointer attribute\n\n\nData structures defined to represent lists of \nattribute\n types which are represented by a \nC\n pointer\n(see section 2.6).\n\n\nConstructor\n\n\nDeclaration:\n\n\nmal_\nattribute\n_list_t *mal_\nattribute\n_list_new(\n  unsigned int element_count);\n\n\n\n\nParameters:\n\n\n\n\nelement_count\n: Number of items in the list.\n\n\n\n\nGetters\n\n\nGetter functions are defined to access the fields:\n\n\nunsigned int mal_\nattribute\n_list_get_element_count(\n  mal_\nattribute\n_list_t *self);\n\nmal_\nattribute\n_t **mal_\nattribute\n_list_get_content(\n  mal_\nattribute\n_list_t *self);\n\n\n\n\nDestructor\n\n\nDeletes the list, its contents (pointers table) and the list items.\n\n\nDeclaration:\n\n\nvoid mal_\nattribute\n_list_destroy(mal_\nattribute\n_list_t **self_p);\n\n\n\n\nList of Composite\n\n\nCf section 9.6.\n\n\nList of Enumerated\n\n\nCf section 9.7.\n\n\nInteraction stage\n\n\nA constant is defined for each stage of each interaction:\n\n\n#define MAL_IP_STAGE_SEND 1\n#define MAL_IP_STAGE_SUBMIT 1\n#define MAL_IP_STAGE_SUBMIT_ACK 2\n#define MAL_IP_STAGE_REQUEST 1\n#define MAL_IP_STAGE_REQUEST_RESPONSE 2\n#define MAL_IP_STAGE_INVOKE 1\n#define MAL_IP_STAGE_INVOKE_ACK 2\n#define MAL_IP_STAGE_INVOKE_RESPONSE 3\n#define MAL_IP_STAGE_PROGRESS 1\n#define MAL_IP_STAGE_PROGRESS_ACK 2\n#define MAL_IP_STAGE_PROGRESS_UPDATE 3\n#define MAL_IP_STAGE_PROGRESS_RESPONSE 4\n#define MAL_IP_STAGE_PUBSUB_REGISTER 1\n#define MAL_IP_STAGE_PUBSUB_REGISTER_ACK 2\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER 3\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER_ACK 4\n#define MAL_IP_STAGE_PUBSUB_PUBLISH 5\n#define MAL_IP_STAGE_PUBSUB_NOTIFY 6\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER 7\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER_ACK 8\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER 9\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER_ACK 10", 
            "title": "MAL"
        }, 
        {
            "location": "/mal_api/#mal-api", 
            "text": "MAL API allows the use of MAL-level concepts:   concepts defined by the MAL specification (Blue Book).  specific concepts to the C API, defined in section 2.   The MAL API contains the Area API generated from the definition of the MAL Area.", 
            "title": "MAL API"
        }, 
        {
            "location": "/mal_api/#definition", 
            "text": "mal.h", 
            "title": "Definition"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-create-an-uri", 
            "text": "Function to be provided by a MAL binding to create a URI.  Declaration:  typedef mal_uri_t *mal_binding_ctx_create_uri_fn(\n  void *mal_binding_ctx,\n  char *id);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.   id : unique identifier to include in the created URI.   Result:    Created URI.", 
            "title": "Virtual function to create an URI"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-create-an-end-point", 
            "text": "Function to be provided by a MAL binding to create an end-point.  Declaration:  typedef void *mal_binding_ctx_create_endpoint_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  mal_endpoint : MAL end-point corresponding to the physical transport end-point to create.   Result:   The pointer to the physical end-point created (untyped to allow the use of multiple bindings, for example ZMQ socket).", 
            "title": "Virtual function to create an end-point"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-delete-an-end-point", 
            "text": "Function to be provided by a MAL binding to destroy an end-point.  Declaration:  typedef void mal_binding_ctx_destroy_endpoint_fn(\n  void *mal_binding_ctx,\n  void **endpoint_p);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  endpoint_p : the end-point to delete.", 
            "title": "Virtual function to delete an end-point"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-create-a-poller", 
            "text": "Function to be provided by a MAL binding to create a poller.  Declaration:  typedef void *mal_binding_ctx_create_poller_fn(\n  void *mal_binding_ctx,\n  mal_poller_t *mal_poller);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  mal_poller : the MAL poller corresponding to the physical transport poller to create.   Result:    The pointer to the physical poller created (untyped to allow the use of multiple bindings, for example ZMQ zpoller).", 
            "title": "Virtual function to create a poller"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-destroy-a-poller", 
            "text": "Function to be provided by a MAL binding to destroy a poller.  Declaration:  typedef void mal_binding_ctx_destroy_poller_fn(\n  void *mal_binding_ctx,\n  void **poller_p);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  poller_p : poller to destroy.", 
            "title": "Virtual function to destroy a poller"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-add-resp-remove-an-end-point-to-a-poller", 
            "text": "Functions to be provided by a MAL binding to add or remove an end-point to a poller.  Declaration:  typedef int mal_binding_ctx_poller_add_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\ntypedef int mal_binding_ctx_poller_del_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  mal_poller : MAL poller to use.  mal_endpoint : MAL end-point to add (resp. remove) to the specified poller.   Result:   an error code.", 
            "title": "Virtual function to add (resp. remove) an end-point to a poller"
        }, 
        {
            "location": "/mal_api/#virtual-function-for-waiting-a-message-on-a-poller", 
            "text": "Function to be provided by a MAL binding to wait on a poller.  Declaration:  typedef int mal_binding_ctx_poller_wait_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  mal_poller : MAL poller to use.  mal_endpoint : MAL end-point on which a message is pending.  timeout : the maximum waiting time, possibly infinite (-1).   Result:   an error code.", 
            "title": "Virtual function for waiting a message on a poller"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-send-a-message", 
            "text": "Function to be provided by a MAL binding to send a message.\nThis function is called by  mal_ctx_send_message  (see section 7.4.2).  Declaration:  typedef int mal_binding_ctx_send_message_fn(\n    void *mal_binding_ctx,\n    mal_endpoint_t *mal_endpoint,\n    mal_message_t *message);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  mal_endpoint : MAL end-point sending the message.  message : MAL message to send.   Result:   an error code.", 
            "title": "Virtual function to send a message"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-receive-a-message", 
            "text": "Function to be provided by a MAL binding to receive a message.\nThis function is called by  mal_ctx_recv_message  (see section 7.4.3).  Declaration:  typedef int mal_binding_ctx_recv_message_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t **message);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  mal_endpoint : MAL end-point receiving the message.  message : receiving message.   Result:   an error code.", 
            "title": "Virtual function to receive a message"
        }, 
        {
            "location": "/mal_api/#virtual-function-to-delete-a-mal-message", 
            "text": "Function to be provided by a MAL binding to destroy a message.\nAllows the transport to free resources (field  body_owner ) that it has associated with the message before its destruction.  Declaration:  typedef int mal_binding_ctx_destroy_message_fn(\n    void *mal_binding_ctx,\n    mal_message_t *message);  Parameters:   mal_binding_ctx : transport context (binding) used by the MAL layer; untyped to allow the use of multiple bindings.  message : MAL message to delete.   Result:   an error code.", 
            "title": "Virtual function to delete a MAL message"
        }, 
        {
            "location": "/mal_api/#contexte-mal", 
            "text": "mal_ctx.h", 
            "title": "Contexte MAL"
        }, 
        {
            "location": "/mal_api/#constructor", 
            "text": "Declaration:  mal_ctx_t *mal_ctx_new(void);  Result:    The created MAL context.", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#uri-creation", 
            "text": "Declaration:  mal_uri_t *mal_ctx_create_uri(mal_ctx_t *self, char *id);  Parameters:   self : MAL context.  id : unique identifier in the transport context.   Result:    The created URI.", 
            "title": "URI creation"
        }, 
        {
            "location": "/mal_api/#poller-creation", 
            "text": "Declaration:  void *mal_ctx_create_poller(\n  mal_ctx_t *self,\n  mal_poller_t *poller);  Parameters:   self : MAL context.  poller : MAL poller corresponding to the new physical poller.   Result:    A pointer to the created physical poller (untyped to avoid dependence with physical concepts of transport, for example a ZMQ zpoller).", 
            "title": "Poller creation"
        }, 
        {
            "location": "/mal_api/#end-point-creation", 
            "text": "Declaration:  void *mal_ctx_create_endpoint(\n  mal_ctx_t *self,\n  mal_endpoint_t *endpoint);  Parameters:   self : MAL context.  endpoint : MAL end-point corresponding to the new physical end-point.   Result:    A pointer to the created physical end-point (untyped to avoid dependence with physical concepts of transport, for example a ZMQ socket).", 
            "title": "end-point creation"
        }, 
        {
            "location": "/mal_api/#mal-message-sending", 
            "text": "This function is used by message sending functions of MAL end-points (section 7.4.2). It calls the message sending function offered by the underlying transport (section 7.1.8).  The use of this function is restricted to MAL end-point.  Declaration:  int mal_ctx_send_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);  Parameters:   self : MAL context.  mal_endpoint : MAL end-point sending the message.  message : MAL message to send.   Result:   an error code.", 
            "title": "MAL message sending"
        }, 
        {
            "location": "/mal_api/#mal-message-reception", 
            "text": "This function is used by the message receiving functions of MAL end-points (section 7.4.3). It calls the message receiving function offered by underlying transport (7.1.9).  The use of this function is restricted to MAL end-point.  Declaration:  int mal_ctx_recv_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t **message);  Parameters:   self : MAL context.  mal_endpoint : MAL end-point receiving the message.  message : MAL message received.   Result:   an error code.", 
            "title": "MAL message reception"
        }, 
        {
            "location": "/mal_api/#destructor", 
            "text": "Deletes the MAL context.    void mal_ctx_destroy(mal_ctx_t **self_p);  Parameters:   self_p : Handle to the MAL context to delete.", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#mal-message", 
            "text": "", 
            "title": "MAL message"
        }, 
        {
            "location": "/mal_api/#constructor_1", 
            "text": "Allocate the memory chunk needed for the message body.  Declaration:  mal_message_t *mal_message_new(\n  mal_blob_t *authentication_id,\n  mal_qoslevel_t qoslevel, mal_uinteger_t priority, mal_list_t *domain,\n  mal_identifier_t *network_zone, mal_sessiontype_t session,\n  mal_identifier_t *session_name, unsigned int body_length);  Parameters:   MAL header fields.  Message body size in bytes.   Result:   The new MAL message.", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#initialisation", 
            "text": "Initialization of the header fields corresponding to the operation and interaction stage.  Declaration:  void mal_message_init(mal_message_t *self, mal_ushort_t service_area,\n  mal_uoctet_t area_version, mal_ushort_t service,\n  mal_ushort_t operation,\n  mal_interactiontype_t interaction_type,\n  mal_uoctet_t interaction_stage);  Parameters:   self : a pointer to the MAL message to initialize.  MAL header fields.", 
            "title": "Initialisation"
        }, 
        {
            "location": "/mal_api/#destructor_1", 
            "text": "Deletes the MAL message and the corresponding body.\nCalls the virtual function provided by the transport API.\nDeclaration:  void mal_message_destroy(mal_message_t **self_p, mal_ctx_t *mal_ctx);  Parameters:   self : an handle to the MAL message to destroy.  The MAL context needed to free associated resources in transport binding if needed.", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#getters-et-setters", 
            "text": "The fields defined in the following table are accessible through getter and setter methods.     Champ  Type  Description      mal header field  mal header field type  MAL header fields as described in the MAL blue book.    free_ header field  bool  Flags indicating whether the corresponding MAL header fields of type pointer must be destroyed when the MAL message is deleted.    body  char *  Message Body encoded.    body_offset  unsigned int  Start offset of the message body.    body_length  unsigned int  Size of the message body.    body_owner  void *  Resource associated with the message by the transport. Should be released during the destruction of the message.     Presence flags apply to the following fields:  URI To ,  Authentication Id ,  URI From ,  Domain ,  Network Zone ,  Session Name .\nBy default, the behavior is:   If the MAL message is created through the constructor then the flag is false. The MAL header fields are transmitted by the application when calling the constructor, so they do not have to be released.  If the MAL message is created by the transport during a reception and if the header fields have been decoded (not recovered from a configuration service) then the flag is true. The MAL header fields are owned by the message and should be destroyed with it.", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/mal_api/#end-point-mal", 
            "text": "Each endpoint should be handled by a single execution flow.", 
            "title": "End-Point MAL"
        }, 
        {
            "location": "/mal_api/#constructor_2", 
            "text": "Create an endpoint instance identified by a MAL URI.\nA  Transaction Id  counter is managed.  Declaration:  mal_endpoint_t *mal_endpoint_new(mal_ctx_t *mal_ctx, mal_uri_t *uri);  Parameters:   mal_ctx : a pointer to the MAL context.  uri : MAL URI identifying the MAL endpoint.   The API provides two functions to retrieve the URL and context MAL corresponding to an end-point:  mal_uri_t *mal_endpoint_get_uri(mal_endpoint_t *self);\nmal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#mal-message-sending_1", 
            "text": "Two message sending functions are defined:   A funtion to initiate an interaction (first stage). This function sets the URI fields of the message: the destination URI of the message is set with the  uri_to  parameter, and the source URI of the message is set with the endpoint URI. If the  set_tid  flag is true then the  Transaction Id  field is set with the next value of the  TransactionId  counter handled by the endpoint. Otherwise the original value of the  Transaction Id  field is left unchanged.  A function for the next stages of the interaction. This function sets the URI fields of the message: the destination URI of the message is set with the  uri_from  field of the initiation message, and the source URI of the message is set with the endpoint URI. The  Transaction Id  field of the message is set with the  Transaction Id  field of the initiation message. The field  Is Error Message  is set with the value of the  is_error_message  parameter. counter.   The  mal_ctx_send_message  function (section 7.2.5) is called to send the MAL message.  Declaration:  int mal_endpoint_init_operation(\n  mal_endpoint_t *self,\n  mal_message_t *message,\n  mal_uri_t *uri_to,\n  bool set_tid);\n\nint mal_endpoint_return_operation(\n  mal_endpoint_t *self,\n  mal_message_t *init_message,\n  mal_message_t *message,\n  bool is_error_message);  Parameters:   self : A pointer to the MAL endpoint sending the message.  message : A pointer to the MAL message to send.  init_message : A pointer to the MAL message initiating the interaction.  uri_to : The MAL URI of the message recipient.  set_tid : Boolean indicating whether the field 'Transaction ID' of the message MAL should be affected or not.  is_error_message :  Boolean indicating whether the message returns an error   Result:   Error code.", 
            "title": "MAL message sending"
        }, 
        {
            "location": "/mal_api/#mal-message-reception_1", 
            "text": "The  mal_endpoint_recv_message  function allows to receive a message on the end-point.\nThis function blocks until receiving a message.  Declaration:  int mal_endpoint_recv_message(\n    mal_endpoint_t *self,\n    mal_message_t **message);  Parameters:   self : A pointer to the MAL endpoint waiting for a message.  message : The message received.   Result:   Error code.", 
            "title": "MAL message reception"
        }, 
        {
            "location": "/mal_api/#destructor_2", 
            "text": "Delete the endpoint.  Declaration:  void mal_endpoint_destroy(mal_endpoint_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#mal-poller", 
            "text": "Each MAL poller should be handled by a single execution flow.", 
            "title": "MAL Poller"
        }, 
        {
            "location": "/mal_api/#constructor_3", 
            "text": "Create a poller instance identified by a MAL URI.  Declaration:    mal_poller_t *mal_poller_new(mal_ctx_t *mal_ctx);  Parameters:   mal_ctx : A pointer to the MAL context.   The API provides a function to retrieve the MAL context corresponding to the poller:  mal_ctx_t *mal_poller_get_mal_ctx(mal_poller_t *self);", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#add-remove-mal-endpoint", 
            "text": "Twos functions allow to add and remove a endpoint to the poller.  Declaration:  int mal_poller_add_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *endpoint);\n\nint mal_poller_del_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *mal_endpoint);  Parameters:   self : A pointer to the MAL poller.  endpoint : A pointer to the MAL endpoint to add or remove.   Result:  Error code.", 
            "title": "Add / Remove MAL endpoint"
        }, 
        {
            "location": "/mal_api/#attente-de-message-mal", 
            "text": "mal_poller_wait  function allows to wait the reception of a MAL message on one of the endpoint handled by the poller.\nThis is a blocking function, it takes a time-out parameter.  Declaration:  int mal_poller_wait(\n    mal_poller_t *self,\n    mal_endpoint_t **endpoint,\n    int timeout);  Parameters:   self : A pointer to the poller waiting a MAL message.  endpoint : An handle to the endpoint which received a message.  timeout : The maximum waiting time, possibly infinite (-1).   Result:  Error code.", 
            "title": "Attente de message MAL"
        }, 
        {
            "location": "/mal_api/#destructor_3", 
            "text": "Deletes the MAL poller. The associated endpoint should be destroyed explicitly.  Declaration:    void mal_poller_destroy(mal_oller_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#mal-handler-and-routing", 
            "text": "A handler is a logical structure composed of a set of MAL message processing functions.\nThis set of functions depends of its role (provider, consumer, etc.) and interaction in\nwhich it operates (send, submit, etc.). Handlers run in the context of a routing structure\n(i e, an object of the class  mal_routing , or router).  The router is linked to the MAL endpoint: it allows to register the handlers corresponding\nto different expected interactions, then on a message receipt it allows the activatation of\nthe corresponding handler to handle the message. The router shares its state with all its\nhandlers.", 
            "title": "MAL Handler and routing"
        }, 
        {
            "location": "/mal_api/#handler", 
            "text": "Each message processing function of the handler has the same signature defined below.   the state of the router,  a pointer to the MAL context,  a pointer the MAL endpoint,  a pointer to the message to process.   The corresponding signature is.  Declaration:  typedef int mal_routing_on_message_fn(\n  void *self,\n  mal_ctx_t *mal_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);  Parameters:   state : The state of the router (untyped to allow polymorphism).  mal_ctx : A pointer to the MAL context.  endpoint : A pointer to the MAL endpoint.  message : A pointer to the message to process.", 
            "title": "Handler"
        }, 
        {
            "location": "/mal_api/#constructor_4", 
            "text": "Create a router instance identified by the corresponding endpoint URI.\nNormally only a single router must be associated with a given MAL endpoint.  Declaration:  mal_routing_t *mal_routing_new(mal_endpoint_t *endpoint, void *state);  Parameters:   endpoint : A pointer to the MAL endpoint.  state : The state of the router (untyped to allow polymorphism).", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#handlers-registering", 
            "text": "The MAL router interface defines the set of functions for registering the interaction's handlers.\nEach function takes as parameters a pointer to the router's state itself, the identification of the area, version, identity of service and operation. Depending on the role of the handler and the operation type, the interface includes pointers to the functions allowing to process the messages corresponding to the interaction.  L'interface defines a function to register an handler of  Send  interaction, and two functions to register the  provider  and  consumer  handlers of each interactions  Submit ,  Request ,  Invoke  et  Progress :  int mal_routing_register_provider_send_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_send);\n\nint mal_routing_register_provider_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_submit);\n\nint mal_routing_register_consumer_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack);\n\nint mal_routing_register_provider_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_request);\n\nint mal_routing_register_consumer_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_invoke);\n\nint mal_routing_register_consumer_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_progress);\n\nint mal_routing_register_consumer_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_update,\n    mal_routing_on_message_fn *on_response);  L'interface also offers three functions to register  publisher ,  subscriber  and  broker  handlers for  Publish/Subscribe  interaction:  int mal_routing_register_provider_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_publish_error,\n    mal_routing_on_message_fn *on_publish_register_ack,\n    mal_routing_on_message_fn *on_publish_deregister_ack);\n\nint mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify);\n\nint mal_routing_register_broker_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_notify_error,\n    mal_routing_on_message_fn *on_register,\n    mal_routing_on_message_fn *on_deregister,\n    mal_routing_on_message_fn *on_publish);  Finally, the interface also provides a function to deregister a  handler :  int mal_routing_remove_handler(\n    mal_routing_t *mal_routing,\n    handler_type_t type,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation);", 
            "title": "Handlers registering"
        }, 
        {
            "location": "/mal_api/#handlers-execution", 
            "text": "The  router  interface provides a function to activate the rigth handler when receiving a MAL message.\nWhen called this function search the right handler in the list of registered handlers. If successful it\nactivates the handler by calling the function corresponding to the received message.  Declaration:  int mal_routing_handle(mal_routing_t *self, mal_message_t *message);  Parameters:   self : A pointer to the  router .  message : A pointer to the received message.", 
            "title": "Handlers execution"
        }, 
        {
            "location": "/mal_api/#destructor_4", 
            "text": "Deletes the  router  and its state.  void mal_routing_destroy(mal_routing_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#element-union", 
            "text": "A  mal_element_t   union is defined to allow the polymorphism of  Element .  union mal_element_t {\n  mal_blob_t *blob_value;\n  mal_boolean_t boolean_value;\n  mal_double_t double_value;\n  mal_float_t float_value;\n  mal_octet_t octet_value;\n  mal_uoctet_t uoctet_value;\n  mal_short_t short_value;\n  mal_ushort_t ushort_value;\n  mal_integer_t integer_value;\n  mal_uinteger_t uinteger_value;\n  mal_long_t long_value;\n  mal_ulong_t ulong_value;\n  mal_string_t *string_value;\n  mal_identifier_t *identifier_value;\n  mal_uri_t *uri_value;\n  mal_time_t time_value;\n  mal_finetime_t finetime_value;\n  mal_duration_t duration_value;\n  int enumerated_value;\n  void *composite_value;\n  void *list_value;\n};", 
            "title": "Element union"
        }, 
        {
            "location": "/mal_api/#element-holder", 
            "text": "This structure allows to manage the decoding in case of element polymorphism.", 
            "title": "Element holder"
        }, 
        {
            "location": "/mal_api/#constructor_5", 
            "text": "Declaration:  mal_element_holder_t *mal_element_holder_new(void);", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#getters-et-setters_1", 
            "text": "Declaration:  bool mal_element_holder_get_presence_flag(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_presence_flag(mal_element_holder_t *self,\n  bool presence_flag);\n\nlong mal_element_holder_get_short_form(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_short_form(mal_element_holder_t *self,\n  long short_form);\n\nunion mal_element_t mal_element_holder_get_value(\n  mal_element_holder_t *self);\n\nvoid mal_element_holder_set_value(mal_element_holder_t *self,\n  union mal_element_t value);", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/mal_api/#destructor_5", 
            "text": "This destructor frees only space allocated for the structure itself, not the union elements.  Declaration:  void mal_element_holder_destroy(mal_element_holder_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#list-of-non-pointer-attribute", 
            "text": "Data structures defined to represent lists of  attribute  types which are not represented by a  C  pointer\n(see section 2.6). These lists are specific to each type of non-pointer  Attribute .\nFor each list, two tables are defined:   presence_flags : Table of presence flags for each of the items in the list.  content : Table containing the values of each item of the list; if an item is null, its value in the\n  table can be assigned with any value.   The size of  presence_flags  and  content  tables should be the same.", 
            "title": "List of non-pointer attribute"
        }, 
        {
            "location": "/mal_api/#constructor_6", 
            "text": "Declaration:  mal_ attribute _list_t *mal_ attribute _list_new(\n  unsigned int element_count);  Parameters:   element_count : Number of items in the list.", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#getter", 
            "text": "Getter functions are defined to access the fields:  unsigned int mal_ attribute _list_get_element_count(\n  mal_ attribute _list_t *self);\n\nbool *mal_ attribute _list_get_presence_flags(\n  mal_ attribute _list_t *self);\n\nmal_ attribute _t *mal_ attribute _list_get_content(\n  mal_ attribute _list_t *self);", 
            "title": "Getter"
        }, 
        {
            "location": "/mal_api/#destructor_6", 
            "text": "Deletes the list and its contents ( presence_flags  and  content  tables).  Declaration:  void mal_ attribute _list_destroy(mal_ attribute _list_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#list-of-pointer-attribute", 
            "text": "Data structures defined to represent lists of  attribute  types which are represented by a  C  pointer\n(see section 2.6).", 
            "title": "List of pointer attribute"
        }, 
        {
            "location": "/mal_api/#constructor_7", 
            "text": "Declaration:  mal_ attribute _list_t *mal_ attribute _list_new(\n  unsigned int element_count);  Parameters:   element_count : Number of items in the list.", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_api/#getters", 
            "text": "Getter functions are defined to access the fields:  unsigned int mal_ attribute _list_get_element_count(\n  mal_ attribute _list_t *self);\n\nmal_ attribute _t **mal_ attribute _list_get_content(\n  mal_ attribute _list_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/mal_api/#destructor_7", 
            "text": "Deletes the list, its contents (pointers table) and the list items.  Declaration:  void mal_ attribute _list_destroy(mal_ attribute _list_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_api/#list-of-composite", 
            "text": "Cf section 9.6.", 
            "title": "List of Composite"
        }, 
        {
            "location": "/mal_api/#list-of-enumerated", 
            "text": "Cf section 9.7.", 
            "title": "List of Enumerated"
        }, 
        {
            "location": "/mal_api/#interaction-stage", 
            "text": "A constant is defined for each stage of each interaction:  #define MAL_IP_STAGE_SEND 1\n#define MAL_IP_STAGE_SUBMIT 1\n#define MAL_IP_STAGE_SUBMIT_ACK 2\n#define MAL_IP_STAGE_REQUEST 1\n#define MAL_IP_STAGE_REQUEST_RESPONSE 2\n#define MAL_IP_STAGE_INVOKE 1\n#define MAL_IP_STAGE_INVOKE_ACK 2\n#define MAL_IP_STAGE_INVOKE_RESPONSE 3\n#define MAL_IP_STAGE_PROGRESS 1\n#define MAL_IP_STAGE_PROGRESS_ACK 2\n#define MAL_IP_STAGE_PROGRESS_UPDATE 3\n#define MAL_IP_STAGE_PROGRESS_RESPONSE 4\n#define MAL_IP_STAGE_PUBSUB_REGISTER 1\n#define MAL_IP_STAGE_PUBSUB_REGISTER_ACK 2\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER 3\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER_ACK 4\n#define MAL_IP_STAGE_PUBSUB_PUBLISH 5\n#define MAL_IP_STAGE_PUBSUB_NOTIFY 6\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER 7\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER_ACK 8\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER 9\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER_ACK 10", 
            "title": "Interaction stage"
        }, 
        {
            "location": "/mal_transport/", 
            "text": "Transport API\n\n\nTransport APIs are defined in the context of a specific binding, for example MALZMQ.\nThese APIs are not directly used by the final user of the MAL API, these APIs are used by\nthe MAL/C itself to perform all actions related to the tranport. \n\n\nSeveral virtual functions are defined by the MAL layer, such as the message sending function (section 7.1.8).\nThus, the application code can send messages without dependence to specific transport API.\n\n\nThe code of the various services (consumer, provider) does not depend on the transport API. It only uses the MAL API.\nThe binding identifier corresponding to the MALZMQ transport is \nmalzmq\n. This identifier is a string used for naming APIs.\n\n\nBinding Context\n\n\nbinding\n_ctx.h\n\n\n\n\nConstructor\n\n\nDeclaration:\n\n\nbinding\n_ctx_t *\nbinding\n_ctx_new(mal_ctx_t *mal_ctx);\n\n\n\n\nParameters:\n\n\n\n\nmal_ctx\n: MAL context using the created transport.\n\n\n\n\nResult:\n\n\n\n\npointer to the created transport.\n\n\n\n\nURI creation\n\n\nThis function must conform to the virtual function defined by the MAL API to create a URI (see 7.1.1).\n\n\nDeclaration:\n\n\nmal_uri_t *\nbinding\n_ctx_create_uri(void *self, char *id);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nid\n: unique identifier in the transport context.\n\n\n\n\nResult:\n\n\n\n\nthe created URI\n\n\n\n\nEnd-point creation\n\n\nThis function must conform to the virtual function defined by the MAL API to create an end-point (see 7.1.2).\n\n\nDeclaration:\n\n\nvoid *\nbinding\n_ctx_create_endpoint(\n  void *self,\n  mal_endpoint_t *endpoint);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nmal_endpoint\n: MAL end-point corresponding to the physical transport end-point.\n\n\n\n\nResult:\n\n\n\n\na pointer to the created end-point.\n\n\n\n\nMAL message sending\n\n\nThis function must conform to the virtual function defined by the MAL API to send a MAL message (see 7.1.8).\n\n\nDeclaration:\n\n\nint \nbinding\n_ctx_send_message(void *self,\n  mal_endpoint_t *mal_endpoint, mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nmal_endpoint\n: MAL end-point sending the message.\n\n\nmessage\n: MAL message to send.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nMAL message deletion\n\n\nThis function must conform to the virtual function defined by the MAL API to delete a MAL message (see 7.1.10).\n\n\nDeclaration:\n\n\nint \nbinding\n_ctx_destroy_message(void *self, mal_message_t *message);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nmessage\n: MAL message to delete.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nEnd-point deletion\n\n\nThis function must conform to the virtual function defined by the MAL API to delete an end-point (see 7.1.3).\n\n\nDeclaration:\n\n\nvoid \nbinding\n_ctx_destroy_endpoint(void *self, void **endpoint_p);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nmal_endpoint\n: handle to the MAL end-point to delete.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nPoller creation\n\n\nThis function must conform to the virtual function defined by the MAL API to create a MAL poller (see 7.1.4).\n\n\nDeclaration:\n\n\nvoid *\nbinding\n_ctx_create_poller(\n  void *self,\n  mal_poller_t *poller);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nmal_poller\n: MAL poller corresponding to the physical transport poller.\n\n\n\n\nResult:\n\n\n-- pointer to the created poller.\n\n\nEnd-point adding / removing to the poller\n\n\nTheses functions must conform to the virtual functions defined by the MAL API to add and remove an end-point to a poller (see 7.1.5).\n\n\nDeclaration:\n\n\nint malzmq_ctx_poller_add_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\nint malzmq_ctx_poller_del_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\n\n\n\nParameters:\n\n\n\n\nself\n: pointer to the transport component.\n\n\nmal_poller\n: MAL poller corresponding to the physical transport poller.\n\n\nmal_endpoint\n: MAL end-point to add / remove to the specified poller.\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nMessage waiting trough the poller\n\n\nThis function must conform to the virtual function defined by the MAL API allowing to wait a MAL message through a poller's end-point (see 7.1.6).\n\n\nDeclaration:\n\n\nint malzmq_ctx_poller_wait(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);\n\n\n\n\nParameters:\n\n\n\n\nself\n : pointer to the transport component.\n\n\nmal_poller\n : MAL poller corresponding to the physical transport poller.\n\n\nmal_endpoint\n : MAL end-point that expect a message.\n\n\ntimeout\n : the maximum waiting time, possibly unlimited (-1)\n\n\n\n\nResult:\n\n\n\n\nan error code.\n\n\n\n\nPoller deletion\n\n\nThis function must conform to the virtual function defined by the MAL API to delete a poller (see 7.1.7).\n\n\nDeclaration:\n\n\nvoid \nbinding\n_ctx_destroy_poller(void *self, void **poller_p);\n\n\n\n\nDestructor\n\n\nDelete the transport context.\n\n\nDeclaration:\n\n\nvoid \nbinding\n_ctx_destroy(\nbinding\n_ctx_t **self_p);", 
            "title": "Transport"
        }, 
        {
            "location": "/mal_transport/#transport-api", 
            "text": "Transport APIs are defined in the context of a specific binding, for example MALZMQ.\nThese APIs are not directly used by the final user of the MAL API, these APIs are used by\nthe MAL/C itself to perform all actions related to the tranport.   Several virtual functions are defined by the MAL layer, such as the message sending function (section 7.1.8).\nThus, the application code can send messages without dependence to specific transport API.  The code of the various services (consumer, provider) does not depend on the transport API. It only uses the MAL API.\nThe binding identifier corresponding to the MALZMQ transport is  malzmq . This identifier is a string used for naming APIs.", 
            "title": "Transport API"
        }, 
        {
            "location": "/mal_transport/#binding-context", 
            "text": "binding _ctx.h", 
            "title": "Binding Context"
        }, 
        {
            "location": "/mal_transport/#constructor", 
            "text": "Declaration:  binding _ctx_t * binding _ctx_new(mal_ctx_t *mal_ctx);  Parameters:   mal_ctx : MAL context using the created transport.   Result:   pointer to the created transport.", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_transport/#uri-creation", 
            "text": "This function must conform to the virtual function defined by the MAL API to create a URI (see 7.1.1).  Declaration:  mal_uri_t * binding _ctx_create_uri(void *self, char *id);  Parameters:   self : pointer to the transport component.  id : unique identifier in the transport context.   Result:   the created URI", 
            "title": "URI creation"
        }, 
        {
            "location": "/mal_transport/#end-point-creation", 
            "text": "This function must conform to the virtual function defined by the MAL API to create an end-point (see 7.1.2).  Declaration:  void * binding _ctx_create_endpoint(\n  void *self,\n  mal_endpoint_t *endpoint);  Parameters:   self : pointer to the transport component.  mal_endpoint : MAL end-point corresponding to the physical transport end-point.   Result:   a pointer to the created end-point.", 
            "title": "End-point creation"
        }, 
        {
            "location": "/mal_transport/#mal-message-sending", 
            "text": "This function must conform to the virtual function defined by the MAL API to send a MAL message (see 7.1.8).  Declaration:  int  binding _ctx_send_message(void *self,\n  mal_endpoint_t *mal_endpoint, mal_message_t *message);  Parameters:   self : pointer to the transport component.  mal_endpoint : MAL end-point sending the message.  message : MAL message to send.   Result:   an error code.", 
            "title": "MAL message sending"
        }, 
        {
            "location": "/mal_transport/#mal-message-deletion", 
            "text": "This function must conform to the virtual function defined by the MAL API to delete a MAL message (see 7.1.10).  Declaration:  int  binding _ctx_destroy_message(void *self, mal_message_t *message);  Parameters:   self : pointer to the transport component.  message : MAL message to delete.   Result:   an error code.", 
            "title": "MAL message deletion"
        }, 
        {
            "location": "/mal_transport/#end-point-deletion", 
            "text": "This function must conform to the virtual function defined by the MAL API to delete an end-point (see 7.1.3).  Declaration:  void  binding _ctx_destroy_endpoint(void *self, void **endpoint_p);  Parameters:   self : pointer to the transport component.  mal_endpoint : handle to the MAL end-point to delete.   Result:   an error code.", 
            "title": "End-point deletion"
        }, 
        {
            "location": "/mal_transport/#poller-creation", 
            "text": "This function must conform to the virtual function defined by the MAL API to create a MAL poller (see 7.1.4).  Declaration:  void * binding _ctx_create_poller(\n  void *self,\n  mal_poller_t *poller);  Parameters:   self : pointer to the transport component.  mal_poller : MAL poller corresponding to the physical transport poller.   Result:  -- pointer to the created poller.", 
            "title": "Poller creation"
        }, 
        {
            "location": "/mal_transport/#end-point-adding-removing-to-the-poller", 
            "text": "Theses functions must conform to the virtual functions defined by the MAL API to add and remove an end-point to a poller (see 7.1.5).  Declaration:  int malzmq_ctx_poller_add_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\nint malzmq_ctx_poller_del_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);  Parameters:   self : pointer to the transport component.  mal_poller : MAL poller corresponding to the physical transport poller.  mal_endpoint : MAL end-point to add / remove to the specified poller.   Result:   an error code.", 
            "title": "End-point adding / removing to the poller"
        }, 
        {
            "location": "/mal_transport/#message-waiting-trough-the-poller", 
            "text": "This function must conform to the virtual function defined by the MAL API allowing to wait a MAL message through a poller's end-point (see 7.1.6).  Declaration:  int malzmq_ctx_poller_wait(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);  Parameters:   self  : pointer to the transport component.  mal_poller  : MAL poller corresponding to the physical transport poller.  mal_endpoint  : MAL end-point that expect a message.  timeout  : the maximum waiting time, possibly unlimited (-1)   Result:   an error code.", 
            "title": "Message waiting trough the poller"
        }, 
        {
            "location": "/mal_transport/#poller-deletion", 
            "text": "This function must conform to the virtual function defined by the MAL API to delete a poller (see 7.1.7).  Declaration:  void  binding _ctx_destroy_poller(void *self, void **poller_p);", 
            "title": "Poller deletion"
        }, 
        {
            "location": "/mal_transport/#destructor", 
            "text": "Delete the transport context.  Declaration:  void  binding _ctx_destroy( binding _ctx_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/area/", 
            "text": "APIs d'area\n\n\nLes noms de type (de donn\u00e9e) ou d'op\u00e9ration sont toujours pr\u00e9fix\u00e9s par les nom d'area et de service o\u00f9 est d\u00e9clar\u00e9 le type ou l'op\u00e9ration. Deux notations sont utilis\u00e9es pour sp\u00e9cifier ce format de nommage. La premi\u00e8re consiste \u00e0 inclure syst\u00e9matiquement les noms d'Area et de service, le nom de service n'existant pas pour les types d\u00e9finis dans des Areas (il est donc entre crochets pour les types) :\n\n\narea\n_[\nservice\n_]\ntype\n\n\narea\n_\nservice\n_\noperation\n\n\n\n\n\nLa seconde notation n'indique que le nom de type ou d'op\u00e9ration avec le pr\u00e9fix \nqf\n signifiant \u00ab qualified \u00bb c'est-\u00e0-dire incluant les noms d'Area et de service. Cette notation est plus compacte :\n\n\nqftype\n\n\nqfop\n\n\n\n\n\nD\u00e9finition de constantes\n\n\n#define \nAREA\n_AREA_NUMBER \narea number\n\n#define \nAREA\n_AREA_VERSION \nversion\n\n\n\n\n\nPour chaque service :\n\n\n#define \nAREA\n_\nSERVICE\n_SERVICE_NUMBER \nservice number\n\n\n\n\n\nPour chaque op\u00e9ration de service :\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER \noperation number\n\n\n\n\n\nPour chaque erreur lev\u00e9e par une op\u00e9ration :\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_\nERROR\n_ERROR_NUMBER \nerror number\n\n\n\n\n\nPour chaque type de donn\u00e9e :\n\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM \nshort form\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_LIST_SHORT_FORM \nshort form\n\n\n\n\n\nD\u00e9finition des types\n\n\nEnumeration\n\n\nLa valeur d'un \u00e9num\u00e9r\u00e9 est sa valeur ordinale, qui est \u00e9gale \u00e0 0 pour le premier \u00e9num\u00e9r\u00e9 et qui est incr\u00e9ment\u00e9e de 1 pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.\n\n\ntypedef enum {\n  \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_\nENUMERATED NAME\n,\n} \narea\n_[\nservice\n_]\nenumeration\n_t;\n\n\n\n\nLa valeur num\u00e9rique de l'\u00e9num\u00e9r\u00e9 (sp\u00e9cifi\u00e9e par la d\u00e9finition du service) est r\u00e9solue au travers d'un tableau d'entiers d\u00e9clar\u00e9 statiquement. Ce tableau contient la valeur num\u00e9rique pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.\n\n\nint \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_NUMERIC_VALUES[] = {\n  \nnumeric value\n,\n}\n\n\n\n\nComposite\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ncomposite\n_t\n  \narea\n_[\nservice\n_]\ncomposite\n_t;\n\n\n\n\nListes\n\n\nPour chaque Composite :\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ncomposite\n_list_t\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t;\n\n\n\n\nPour chaque Enumeration :\n\n\ntypedef struct _\narea\n_[\nservice\n_]\nenumeration\n_list_t\n    \narea\n_[\nservice\n_]\nenumeration\n_list_t;\n\n\n\n\nEnvoi de message\n\n\nOp\u00e9ration non Publish/Subscribe\n\n\nPour chaque op\u00e9ration, except\u00e9 si le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies. \n\n\nL'\u00e9tape et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction.\n\n\n\n\n\n\n\n\nFonction\n\n\nEtape\n\n\nR\u00f4le\n\n\n\n\n\n\n\n\n\n\nInitiation d'interaction\n\n\nsend, submit, request, invoke, progress\n\n\nConsumer\n\n\n\n\n\n\nR\u00e9sultat d'interaction\n\n\nsubmit_ack, request_response invoke_ack, invoke_response, progress_ack, progress_update, progress_response\n\n\nProvider\n\n\n\n\n\n\n\n\nD\u00e9clarations :\n\n\nint \narea\n_\nservice\n_\noperation\n_\nfirst stage\n(\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_uri_t *provider_uri);\n\nint \narea\n_\nservice\n_\noperation\n_\nresult stage\n(\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_message_t *result_message, bool is_error_message);\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `endpoint` : le end-point qui envoie le message\n    -   `init_message` : le message qui initie l'interaction (premi\u00e8re \u00e9tape)\n    -   `provider_uri` : l'URI du provider de service\n    -   `result_message` : le message r\u00e9sultat du traitement de l'interaction (seconde \u00e9tape et suivantes)\n    -   `is_error_message` : flag indiquant si le message renvoie une erreur\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nOp\u00e9ration Publish/Subscribe\n\n\nPour chaque op\u00e9ration dont le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies. \n\n\nL'\u00e9tape Pub/Sub et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction. Aucune fonction n'est g\u00e9n\u00e9r\u00e9e pour le r\u00f4le Broker car un Broker est un composant g\u00e9n\u00e9rique qui ne d\u00e9pend pas d'Area particuli\u00e8re (except\u00e9 l'Area MAL).\n\n\n\n\n\n\n\n\nFonction\n\n\nEtape Pub/Sub\n\n\nR\u00f4le\n\n\n\n\n\n\n\n\n\n\nAbonnement\n\n\nRegister\n\n\nSubscriber\n\n\n\n\n\n\nD\u00e9claration de publication\n\n\nPublish Register\n\n\nPublisher\n\n\n\n\n\n\nPublication\n\n\nPublish\n\n\nPublisher\n\n\n\n\n\n\nD\u00e9sabonnement\n\n\nDeregister\n\n\nSubscriber\n\n\n\n\n\n\nArr\u00eat de publication\n\n\nPublish Deregister\n\n\nPublisher\n\n\n\n\n\n\n\n\nD\u00e9clarations :\n\n\nint \narea\n_\nservice\n_\noperation\n_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint \narea\n_\nservice\n_\noperation\n_publish_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint \narea\n_\nservice\n_\noperation\n_publish(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri,\n  long initial_publish_register_tid);\n\nint \narea\n_\nservice\n_\noperation\n_deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint \narea\n_\nservice\n_\noperation\n_publish_deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `endpoint` : Le end-point qui envoie le message\n    -   `message` : le message relatif \u00e0 l'\u00e9tape Pub/Sub\n    -   `broker_uri` : l'URI du broker\n    -   `initial_publish_register_tid` : identifiant de transaction du premier message Publish Register envoy\u00e9\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nEncodage\n\n\nCes fonctions sont d\u00e9finies pour chaque op\u00e9ration, chaque \u00e9l\u00e9ment de corps de message et chaque erreur retourn\u00e9e par l'op\u00e9ration. Les \u00e9l\u00e9ments sont identifi\u00e9s par leur index dans le corps de message comme sp\u00e9cifi\u00e9 par la d\u00e9finition MAL (XML) du service.\n\n\nEn Pub/Sub, l'index des \u00e9l\u00e9ments commence \u00e0 0 avec la premi\u00e8re liste d'Update. Les \u00e9l\u00e9ments pr\u00e9c\u00e9dents comme par exemple l'Identifier (message Notify) ou l'UpdateHeaderList (messages Publish et Notify) ne sont pas compt\u00e9s.\n\n\nLes messages d'erreur n'ont au plus qu'un seul \u00e9l\u00e9ment (identifi\u00e9 par le champ extraInformation). Il n'y a donc pas d'index.\n\n\nPolymorphisme du dernier \u00e9l\u00e9ment de corps de message\n\n\nSi l'\u00e9l\u00e9ment est le dernier du corps de message :\n\n\n    -   Si le type d\u00e9clar\u00e9 est MAL::Attribute, alors l'\u00e9l\u00e9ment est transmis avec le type de l'union 'mal_attribute_t'.\n    -   Si le type d\u00e9clar\u00e9 est MAL::Element, un composite abstrait, ou une liste d'un type abstrait (y compris MAL::Attribute), alors une fonction doit \u00eatre d\u00e9finie pour chaque type final conforme au type abstrait. Le nom du type (qftype) est ajout\u00e9 au nom de la fonction apr\u00e8s un s\u00e9parateur '_' :\n\n\n\nnom de la fonction d encodage\n_\nqftype\n(\nparam\u00e8tres\n);\n\n\n\n\nLes fonctions d'encodage du message d'erreur suivront \u00e9galement la m\u00eame convention de nommage, que le type du champ extraInformation soit polymorphique ou non. Cela permet de distinguer les fonctions des \u00e9ventuelles erreurs multiples.\n\n\nCalcul de la taille d'encodage d'un \u00e9l\u00e9ment de corps de message\n\n\nFonction d'ajout de la taille d'encodage \u00e0 une valeur initiale.\n\n\nD\u00e9claration :\n\n\n    -   Si l'op\u00e9ration n'est pas Pub/Sub :\n\n    -   En cas de polymorphisme d'Attribut :\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length);\n\n\n\n\n    -   Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  \nqftype\n_t element, unsigned int *encoding_length);\n\n\n\n\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, \nqftype\n_[list_]t *element,\n  unsigned int *encoding_length);\n\n\n\n\n    -   Si l'op\u00e9ration est Pub/Sub :\n\n\n\nint \nqfop\n_update_add_encoding_length[_\nindex\n][_\nqftype\n_list](\n    int encoding_format_code, void * encoder,\n    \nqftype\n_list_t *element,\n    unsigned int *encoding_length);\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `encoding_format_code` : code du format d'encodage\n    -   `encoder` : configuration du module d'encodage\n    -   `presence_flag` : champ de pr\u00e9sence, n\u00e9cessaire si le type de l'\u00e9l\u00e9ment n'est pas un pointeur\n    -   `element` : \u00e9l\u00e9ment \u00e0 encoder\n    -   `encoding_length` : valeur initiale et r\u00e9sultat de la fonction d'ajout\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nEncodage d'un \u00e9l\u00e9ment de corps de message\n\n\nD\u00e9claration :\n\n\n    -   Si l'op\u00e9ration n'est pas Pub/Sub :\n    -   En cas de polymorphisme d'Attribut :\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, void *cursor,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);\n\n\n\n\n    -   Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *cursor,\n  void *encoder, bool presence_flag, \nqftype\n_t element);\n\n\n\n\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *cursor,\n  void *encoder, \nqftype\n_[list_]t *element);\n\n\n\n\n    -   Si l'op\u00e9ration est Pub/Sub :\n\n\n\nint \nqfop\n_update_encode[_\nindex\n][_\nqftype\n_list](\n    int encoding_format_code, void *cursor,\n    void *encoder, \nqftype\n_list_t *element) {\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `encoding_format_code` : code du format d'encodage\n    -   `cursor` : un index virtuel du fromat d'encodage\n    -   `encoder` : configuration du module d'encodage\n    -   `presence_flag` : flag de pr\u00e9sence \u00e0 encoder\n    -   `attribute_tag` : tag d'Attribut \u00e0 encoder\n    -   `element` : \u00e9l\u00e9ment \u00e0 encoder\n\n\n\nD\u00e9codage d'un \u00e9l\u00e9ment de corps de message\n\n\nD\u00e9claration :\n\n\n    -   Si l'op\u00e9ration n'est pas Pub/Sub :\n    -   En cas de polymorphisme d'Attribut :\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, void *cursor,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);\n\n\n\n\n    -   En cas de polymorphisme d'\u00e9l\u00e9ment et/ou pour un message d'erreur :\n\n\n\nint \nqfop\n_\nstage|error\n_decode[_\nindex\n](\n  int encoding_format_code,\n  void *cursor, void *decoder,\n  mal_element_holder_t *element_holder);\n\n\n\n\n    -   Si le type de l'\u00e9l\u00e9ment est connu :\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, void *cursor,\n  void *decoder, bool *presence_flag_res, \nqftype\n_t *element_res);\n\n\n\n\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, void *cursor,\n  void *decoder, \nqftype\n_[list_]t **element_res);\n\n\n\n\n    -   Si l'op\u00e9ration est Pub/Sub :\n    -   En cas de polymorphisme d'\u00e9l\u00e9ment :\n\n\n\nint \nqfop\n_update_decode[_\nindex\n](int encoding_format_code,\n  void *cursor, void *decoder,\n  mal_element_holder_t *element_holder);\n\n\n\n\n    -   Si le type de l'update est connu :\n\n\n\nint \nqfop\n_update_decode[_\nindex\n](int encoding_format_code,\n  void *cursor, void *decoder,\n  \nqftype\n_list_t **element_res);\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `encoding_format_code` : code du format d'encodage\n    -   `cursor` : un index virtuel du format d'encodage\n    -   `decoder` : configuration du module de d\u00e9codage\n    -   `presence_flag_res` : flag de pr\u00e9sence d\u00e9cod\u00e9\n    -   `attribute_tag_res` : tag d'Attribut d\u00e9cod\u00e9\n    -   `element_res` : \u00e9l\u00e9ment d\u00e9cod\u00e9\n    -   `element_holder` : \u00e9l\u00e9ment d\u00e9cod\u00e9\n\n\n\nAllocation m\u00e9moire\n\n\nLes primitives de d\u00e9codage allouent de la m\u00e9moire pour certains param\u00e8tres (attributs pointeurs, composites, listes, et ce r\u00e9cursivement. Ces param\u00e8tres doivent en final \u00eatre d\u00e9truits par l'appel des fonctions destroy adapt\u00e9es, qui assurent la lib\u00e9ration r\u00e9cursive de la m\u00e9moire.\n\n\nEn cas de retour en erreur d'une fonction de d\u00e9codage, il peut y avoir eu allocation partielle d'un ensemble d'\u00e9l\u00e9ments. Dans ce cas le param\u00e8tre partiellement d\u00e9cod\u00e9 est retourn\u00e9 et doit \u00e9galement \u00eatre d\u00e9truit par l'appel \u00e0 la fonction destroy.\n\n\nLa destruction de la m\u00e9moire allou\u00e9e lors du d\u00e9codage d'un \u00e9l\u00e9ment polymorphique au travers d'une structure mal_holder_t est particuli\u00e8re. Le destructeur de la structure ne lib\u00e9rant pas le contenu, il faut retrouv\u00e9 le type effectif de l'\u00e9l\u00e9ment allou\u00e9 et appeler le constructeur sp\u00e9cifique de l'\u00e9l\u00e9ment.\n\n\nComposite\n\n\nUne classe est g\u00e9n\u00e9r\u00e9e pour chaque Composite.\n\n\nConstructeur\n\n\narea\n_[\nservice\n_]\ncomposite\n_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_new(void);\n\n\n\n\nGetters et setters\n\n\nL'affectation du flag de pr\u00e9sence est r\u00e9alis\u00e9e de mani\u00e8re explicite par des fonctions \nsetter\n d\u00e9di\u00e9es. Le flag de pr\u00e9sence ne doit pas \u00eatre modifi\u00e9 implicitement par le \nsetter\n de la valeur du champ.\n\n\nPour chaque champ, les fonctions 'setter' et 'getter' d'acc\u00e8s \u00e0 la valeur du champ sont d\u00e9finies :\n\n\nfield type\n \narea\n_[\nservice\n_]\ncomposite\n_get_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\nvoid \narea\n_[\nservice\n_]\ncomposite\n_set_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nfield type\n \nfield\n);\n\n\n\n\nSi le champ n'est pas un pointeur (valeur NULL interdite), des fonctions 'setter' et 'getter' d'acc\u00e8s aux flags de pr\u00e9sence sont ajout\u00e9es :\n\n\nbool \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_is_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, bool is_present);\n\n\n\n\nEn cas de polymorphisme d'attribut, des fonctions 'setter' et 'getter' d'acc\u00e8s aux tags d'Attribut sont ajout\u00e9es :\n\n\nunsigned char \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_get_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, unsigned char attribute_tag);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la structure et les structures contenues dedans (composites, listes, Attributs pointeurs).\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_t **self_p);\n\n\n\n\nListes de Composite\n\n\nStructures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Composite.\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\narea\n_[\nservice\n_]\ncomposite\n_list_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_list_new(unsigned int element_count);\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `element_count`\n\n\n\nGetters\n\n\nDes fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :\n\n\nunsigned int \narea\n_[\nservice\n_]\ncomposite\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\narea\n_[\nservice\n_]\ncomposite\n_t **\narea\n_[\nservice\n_]\ncomposite\n_list_get_content(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste, son contenu et les \u00e9l\u00e9ments de la liste.\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t **self_p);\n\n\n\n\nListes d'\u00e9num\u00e9r\u00e9\n\n\nStructures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Enumeration.\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\narea\n_[\nservice\n_]\nenum\n_list_t\n  *\narea\n_[\nservice\n_]\nenum\n_list_new(unsigned int element_count);\n\n\n\n\nParam\u00e8tres :\n\n\n    -   `element_count`\n\n\n\nGetters\n\n\nDes fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :\n\n\nunsigned int \narea\n_[\nservice\n_]\nenum\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\nenum\n_list_t *self);\nbool *\narea\n_[\nservice\n_]\nenum\n_list_get_presence_flags(\n  \narea\n_[\nservice\n_]\nenum\n_list_t *self);\n\narea\n_[\nservice\n_]\nenum\n_t *\narea\n_[\nservice\n_]\nenum\n_list_get_content(\n  \narea\n_[\nservice\n_]\nenum\n_list_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste et son contenu.\n\n\nvoid \narea\n_[\nservice\n_]\nenum\n_list_destroy(\n    \narea\n_[\nservice\n_]\nenum\n_list_t **self_p);", 
            "title": "Area"
        }, 
        {
            "location": "/area/#apis-darea", 
            "text": "Les noms de type (de donn\u00e9e) ou d'op\u00e9ration sont toujours pr\u00e9fix\u00e9s par les nom d'area et de service o\u00f9 est d\u00e9clar\u00e9 le type ou l'op\u00e9ration. Deux notations sont utilis\u00e9es pour sp\u00e9cifier ce format de nommage. La premi\u00e8re consiste \u00e0 inclure syst\u00e9matiquement les noms d'Area et de service, le nom de service n'existant pas pour les types d\u00e9finis dans des Areas (il est donc entre crochets pour les types) :  area _[ service _] type  area _ service _ operation   La seconde notation n'indique que le nom de type ou d'op\u00e9ration avec le pr\u00e9fix  qf  signifiant \u00ab qualified \u00bb c'est-\u00e0-dire incluant les noms d'Area et de service. Cette notation est plus compacte :  qftype  qfop", 
            "title": "APIs d'area"
        }, 
        {
            "location": "/area/#definition-de-constantes", 
            "text": "#define  AREA _AREA_NUMBER  area number \n#define  AREA _AREA_VERSION  version   Pour chaque service :  #define  AREA _ SERVICE _SERVICE_NUMBER  service number   Pour chaque op\u00e9ration de service :  #define  AREA _ SERVICE _ OPERATION _OPERATION_NUMBER  operation number   Pour chaque erreur lev\u00e9e par une op\u00e9ration :  #define  AREA _ SERVICE _ OPERATION _ ERROR _ERROR_NUMBER  error number   Pour chaque type de donn\u00e9e :  #define  AREA _[ SERVICE _] TYPE _SHORT_FORM  short form \n#define  AREA _[ SERVICE _] TYPE _LIST_SHORT_FORM  short form", 
            "title": "D\u00e9finition de constantes"
        }, 
        {
            "location": "/area/#definition-des-types", 
            "text": "", 
            "title": "D\u00e9finition des types"
        }, 
        {
            "location": "/area/#enumeration", 
            "text": "La valeur d'un \u00e9num\u00e9r\u00e9 est sa valeur ordinale, qui est \u00e9gale \u00e0 0 pour le premier \u00e9num\u00e9r\u00e9 et qui est incr\u00e9ment\u00e9e de 1 pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.  typedef enum {\n   AREA _[ SERVICE _] ENUMERATION _ ENUMERATED NAME ,\n}  area _[ service _] enumeration _t;  La valeur num\u00e9rique de l'\u00e9num\u00e9r\u00e9 (sp\u00e9cifi\u00e9e par la d\u00e9finition du service) est r\u00e9solue au travers d'un tableau d'entiers d\u00e9clar\u00e9 statiquement. Ce tableau contient la valeur num\u00e9rique pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.  int  AREA _[ SERVICE _] ENUMERATION _NUMERIC_VALUES[] = {\n   numeric value ,\n}", 
            "title": "Enumeration"
        }, 
        {
            "location": "/area/#composite", 
            "text": "typedef struct _ area _[ service _] composite _t\n   area _[ service _] composite _t;", 
            "title": "Composite"
        }, 
        {
            "location": "/area/#listes", 
            "text": "Pour chaque Composite :  typedef struct _ area _[ service _] composite _list_t\n     area _[ service _] composite _list_t;  Pour chaque Enumeration :  typedef struct _ area _[ service _] enumeration _list_t\n     area _[ service _] enumeration _list_t;", 
            "title": "Listes"
        }, 
        {
            "location": "/area/#envoi-de-message", 
            "text": "", 
            "title": "Envoi de message"
        }, 
        {
            "location": "/area/#operation-non-publishsubscribe", 
            "text": "Pour chaque op\u00e9ration, except\u00e9 si le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies.   L'\u00e9tape et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction.     Fonction  Etape  R\u00f4le      Initiation d'interaction  send, submit, request, invoke, progress  Consumer    R\u00e9sultat d'interaction  submit_ack, request_response invoke_ack, invoke_response, progress_ack, progress_update, progress_response  Provider     D\u00e9clarations :  int  area _ service _ operation _ first stage (\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_uri_t *provider_uri);\n\nint  area _ service _ operation _ result stage (\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_message_t *result_message, bool is_error_message);  Param\u00e8tres :      -   `endpoint` : le end-point qui envoie le message\n    -   `init_message` : le message qui initie l'interaction (premi\u00e8re \u00e9tape)\n    -   `provider_uri` : l'URI du provider de service\n    -   `result_message` : le message r\u00e9sultat du traitement de l'interaction (seconde \u00e9tape et suivantes)\n    -   `is_error_message` : flag indiquant si le message renvoie une erreur  R\u00e9sultat :   code d'erreur", 
            "title": "Op\u00e9ration non Publish/Subscribe"
        }, 
        {
            "location": "/area/#operation-publishsubscribe", 
            "text": "Pour chaque op\u00e9ration dont le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies.   L'\u00e9tape Pub/Sub et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction. Aucune fonction n'est g\u00e9n\u00e9r\u00e9e pour le r\u00f4le Broker car un Broker est un composant g\u00e9n\u00e9rique qui ne d\u00e9pend pas d'Area particuli\u00e8re (except\u00e9 l'Area MAL).     Fonction  Etape Pub/Sub  R\u00f4le      Abonnement  Register  Subscriber    D\u00e9claration de publication  Publish Register  Publisher    Publication  Publish  Publisher    D\u00e9sabonnement  Deregister  Subscriber    Arr\u00eat de publication  Publish Deregister  Publisher     D\u00e9clarations :  int  area _ service _ operation _register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint  area _ service _ operation _publish_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint  area _ service _ operation _publish(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri,\n  long initial_publish_register_tid);\n\nint  area _ service _ operation _deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint  area _ service _ operation _publish_deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);  Param\u00e8tres :      -   `endpoint` : Le end-point qui envoie le message\n    -   `message` : le message relatif \u00e0 l'\u00e9tape Pub/Sub\n    -   `broker_uri` : l'URI du broker\n    -   `initial_publish_register_tid` : identifiant de transaction du premier message Publish Register envoy\u00e9  R\u00e9sultat :   code d'erreur", 
            "title": "Op\u00e9ration Publish/Subscribe"
        }, 
        {
            "location": "/area/#encodage", 
            "text": "Ces fonctions sont d\u00e9finies pour chaque op\u00e9ration, chaque \u00e9l\u00e9ment de corps de message et chaque erreur retourn\u00e9e par l'op\u00e9ration. Les \u00e9l\u00e9ments sont identifi\u00e9s par leur index dans le corps de message comme sp\u00e9cifi\u00e9 par la d\u00e9finition MAL (XML) du service.  En Pub/Sub, l'index des \u00e9l\u00e9ments commence \u00e0 0 avec la premi\u00e8re liste d'Update. Les \u00e9l\u00e9ments pr\u00e9c\u00e9dents comme par exemple l'Identifier (message Notify) ou l'UpdateHeaderList (messages Publish et Notify) ne sont pas compt\u00e9s.  Les messages d'erreur n'ont au plus qu'un seul \u00e9l\u00e9ment (identifi\u00e9 par le champ extraInformation). Il n'y a donc pas d'index.", 
            "title": "Encodage"
        }, 
        {
            "location": "/area/#polymorphisme-du-dernier-element-de-corps-de-message", 
            "text": "Si l'\u00e9l\u00e9ment est le dernier du corps de message :      -   Si le type d\u00e9clar\u00e9 est MAL::Attribute, alors l'\u00e9l\u00e9ment est transmis avec le type de l'union 'mal_attribute_t'.\n    -   Si le type d\u00e9clar\u00e9 est MAL::Element, un composite abstrait, ou une liste d'un type abstrait (y compris MAL::Attribute), alors une fonction doit \u00eatre d\u00e9finie pour chaque type final conforme au type abstrait. Le nom du type (qftype) est ajout\u00e9 au nom de la fonction apr\u00e8s un s\u00e9parateur '_' :  nom de la fonction d encodage _ qftype ( param\u00e8tres );  Les fonctions d'encodage du message d'erreur suivront \u00e9galement la m\u00eame convention de nommage, que le type du champ extraInformation soit polymorphique ou non. Cela permet de distinguer les fonctions des \u00e9ventuelles erreurs multiples.", 
            "title": "Polymorphisme du dernier \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#calcul-de-la-taille-dencodage-dun-element-de-corps-de-message", 
            "text": "Fonction d'ajout de la taille d'encodage \u00e0 une valeur initiale.  D\u00e9claration :      -   Si l'op\u00e9ration n'est pas Pub/Sub :\n\n    -   En cas de polymorphisme d'Attribut :  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length);      -   Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n   qftype _t element, unsigned int *encoding_length);      -   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder,  qftype _[list_]t *element,\n  unsigned int *encoding_length);      -   Si l'op\u00e9ration est Pub/Sub :  int  qfop _update_add_encoding_length[_ index ][_ qftype _list](\n    int encoding_format_code, void * encoder,\n     qftype _list_t *element,\n    unsigned int *encoding_length);  Param\u00e8tres :      -   `encoding_format_code` : code du format d'encodage\n    -   `encoder` : configuration du module d'encodage\n    -   `presence_flag` : champ de pr\u00e9sence, n\u00e9cessaire si le type de l'\u00e9l\u00e9ment n'est pas un pointeur\n    -   `element` : \u00e9l\u00e9ment \u00e0 encoder\n    -   `encoding_length` : valeur initiale et r\u00e9sultat de la fonction d'ajout  R\u00e9sultat :   code d'erreur", 
            "title": "Calcul de la taille d'encodage d'un \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#encodage-dun-element-de-corps-de-message", 
            "text": "D\u00e9claration :      -   Si l'op\u00e9ration n'est pas Pub/Sub :\n    -   En cas de polymorphisme d'Attribut :  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, void *cursor,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);      -   Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, void *cursor,\n  void *encoder, bool presence_flag,  qftype _t element);      -   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, void *cursor,\n  void *encoder,  qftype _[list_]t *element);      -   Si l'op\u00e9ration est Pub/Sub :  int  qfop _update_encode[_ index ][_ qftype _list](\n    int encoding_format_code, void *cursor,\n    void *encoder,  qftype _list_t *element) {  Param\u00e8tres :      -   `encoding_format_code` : code du format d'encodage\n    -   `cursor` : un index virtuel du fromat d'encodage\n    -   `encoder` : configuration du module d'encodage\n    -   `presence_flag` : flag de pr\u00e9sence \u00e0 encoder\n    -   `attribute_tag` : tag d'Attribut \u00e0 encoder\n    -   `element` : \u00e9l\u00e9ment \u00e0 encoder", 
            "title": "Encodage d'un \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#decodage-dun-element-de-corps-de-message", 
            "text": "D\u00e9claration :      -   Si l'op\u00e9ration n'est pas Pub/Sub :\n    -   En cas de polymorphisme d'Attribut :  int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, void *cursor,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);      -   En cas de polymorphisme d'\u00e9l\u00e9ment et/ou pour un message d'erreur :  int  qfop _ stage|error _decode[_ index ](\n  int encoding_format_code,\n  void *cursor, void *decoder,\n  mal_element_holder_t *element_holder);      -   Si le type de l'\u00e9l\u00e9ment est connu :\n    -   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :  int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, void *cursor,\n  void *decoder, bool *presence_flag_res,  qftype _t *element_res);      -   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :  int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, void *cursor,\n  void *decoder,  qftype _[list_]t **element_res);      -   Si l'op\u00e9ration est Pub/Sub :\n    -   En cas de polymorphisme d'\u00e9l\u00e9ment :  int  qfop _update_decode[_ index ](int encoding_format_code,\n  void *cursor, void *decoder,\n  mal_element_holder_t *element_holder);      -   Si le type de l'update est connu :  int  qfop _update_decode[_ index ](int encoding_format_code,\n  void *cursor, void *decoder,\n   qftype _list_t **element_res);  Param\u00e8tres :      -   `encoding_format_code` : code du format d'encodage\n    -   `cursor` : un index virtuel du format d'encodage\n    -   `decoder` : configuration du module de d\u00e9codage\n    -   `presence_flag_res` : flag de pr\u00e9sence d\u00e9cod\u00e9\n    -   `attribute_tag_res` : tag d'Attribut d\u00e9cod\u00e9\n    -   `element_res` : \u00e9l\u00e9ment d\u00e9cod\u00e9\n    -   `element_holder` : \u00e9l\u00e9ment d\u00e9cod\u00e9", 
            "title": "D\u00e9codage d'un \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#allocation-memoire", 
            "text": "Les primitives de d\u00e9codage allouent de la m\u00e9moire pour certains param\u00e8tres (attributs pointeurs, composites, listes, et ce r\u00e9cursivement. Ces param\u00e8tres doivent en final \u00eatre d\u00e9truits par l'appel des fonctions destroy adapt\u00e9es, qui assurent la lib\u00e9ration r\u00e9cursive de la m\u00e9moire.  En cas de retour en erreur d'une fonction de d\u00e9codage, il peut y avoir eu allocation partielle d'un ensemble d'\u00e9l\u00e9ments. Dans ce cas le param\u00e8tre partiellement d\u00e9cod\u00e9 est retourn\u00e9 et doit \u00e9galement \u00eatre d\u00e9truit par l'appel \u00e0 la fonction destroy.  La destruction de la m\u00e9moire allou\u00e9e lors du d\u00e9codage d'un \u00e9l\u00e9ment polymorphique au travers d'une structure mal_holder_t est particuli\u00e8re. Le destructeur de la structure ne lib\u00e9rant pas le contenu, il faut retrouv\u00e9 le type effectif de l'\u00e9l\u00e9ment allou\u00e9 et appeler le constructeur sp\u00e9cifique de l'\u00e9l\u00e9ment.", 
            "title": "Allocation m\u00e9moire"
        }, 
        {
            "location": "/area/#composite_1", 
            "text": "Une classe est g\u00e9n\u00e9r\u00e9e pour chaque Composite.", 
            "title": "Composite"
        }, 
        {
            "location": "/area/#constructeur", 
            "text": "area _[ service _] composite _t\n  * area _[ service _] composite _new(void);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/area/#getters-et-setters", 
            "text": "L'affectation du flag de pr\u00e9sence est r\u00e9alis\u00e9e de mani\u00e8re explicite par des fonctions  setter  d\u00e9di\u00e9es. Le flag de pr\u00e9sence ne doit pas \u00eatre modifi\u00e9 implicitement par le  setter  de la valeur du champ.  Pour chaque champ, les fonctions 'setter' et 'getter' d'acc\u00e8s \u00e0 la valeur du champ sont d\u00e9finies :  field type   area _[ service _] composite _get_ field (\n     area _[ service _] composite _t *self);\nvoid  area _[ service _] composite _set_ field (\n     area _[ service _] composite _t *self,  field type   field );  Si le champ n'est pas un pointeur (valeur NULL interdite), des fonctions 'setter' et 'getter' d'acc\u00e8s aux flags de pr\u00e9sence sont ajout\u00e9es :  bool  area _[ service _] composite _ field _is_present(\n     area _[ service _] composite _t *self);\nvoid  area _[ service _] composite _ field _set_present(\n     area _[ service _] composite _t *self, bool is_present);  En cas de polymorphisme d'attribut, des fonctions 'setter' et 'getter' d'acc\u00e8s aux tags d'Attribut sont ajout\u00e9es :  unsigned char  area _[ service _] composite _ field _get_attribute_tag(\n     area _[ service _] composite _t *self);\nvoid  area _[ service _] composite _ field _set_attribute_tag(\n     area _[ service _] composite _t *self, unsigned char attribute_tag);", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/area/#destructeur", 
            "text": "D\u00e9truit la structure et les structures contenues dedans (composites, listes, Attributs pointeurs).  void  area _[ service _] composite _destroy(\n     area _[ service _] composite _t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/area/#listes-de-composite", 
            "text": "Structures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Composite.", 
            "title": "Listes de Composite"
        }, 
        {
            "location": "/area/#constructeur_1", 
            "text": "D\u00e9claration :  area _[ service _] composite _list_t\n  * area _[ service _] composite _list_new(unsigned int element_count);  Param\u00e8tres :      -   `element_count`", 
            "title": "Constructeur"
        }, 
        {
            "location": "/area/#getters", 
            "text": "Des fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :  unsigned int  area _[ service _] composite _list_get_element_count(\n   area _[ service _] composite _list_t *self); area _[ service _] composite _t ** area _[ service _] composite _list_get_content(\n   area _[ service _] composite _list_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/area/#destructeur_1", 
            "text": "D\u00e9truit la liste, son contenu et les \u00e9l\u00e9ments de la liste.  void  area _[ service _] composite _list_destroy(\n     area _[ service _] composite _list_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/area/#listes-denumere", 
            "text": "Structures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Enumeration.", 
            "title": "Listes d'\u00e9num\u00e9r\u00e9"
        }, 
        {
            "location": "/area/#constructeur_2", 
            "text": "D\u00e9claration :  area _[ service _] enum _list_t\n  * area _[ service _] enum _list_new(unsigned int element_count);  Param\u00e8tres :      -   `element_count`", 
            "title": "Constructeur"
        }, 
        {
            "location": "/area/#getters_1", 
            "text": "Des fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :  unsigned int  area _[ service _] enum _list_get_element_count(\n   area _[ service _] enum _list_t *self);\nbool * area _[ service _] enum _list_get_presence_flags(\n   area _[ service _] enum _list_t *self); area _[ service _] enum _t * area _[ service _] enum _list_get_content(\n   area _[ service _] enum _list_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/area/#destructeur_2", 
            "text": "D\u00e9truit la liste et son contenu.  void  area _[ service _] enum _list_destroy(\n     area _[ service _] enum _list_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_actor/", 
            "text": "Actor / Handler Execution Model\n\n\nThe MAL actor uses the MAL C API and in particular the notions of \npoller\n, \nend-point\n and \nhandler\n. It is based on the notion of CZMQ actor.\n\n\nMAL Actor\n\n\nAn actor is in charge of the execution of a set of interaction handlers corresponding to the interactions of a given end-point. The API allows the dynamic addition and removal of handlers. To avoid problems related to parallelism, registering and deleting a handler can be made only from the actor himself.\nA handler can only be performed by an unique actor.\n\n\nAn actor reacts to MAL messages independently of any role in the interaction. When receiving a message it searches for the corresponding handler in the list of registered handlers. If successful, it activates the handler by calling the function corresponding to the received message, otherwise the message is destroyed.\n\n\nThe lifetime of an interaction exceeds the reaction of the actor.\n\n\nOnly the actor who received the message initiating an interaction can answer to this interaction.\n\n\nAn actor has the following features:\n-   It corresponds to a single a single endpoint, therefore:\n    - It can only use a single transport (binding) to receive and send MAL messages.\n    - It can use multiple encoding formats for the MAL message body.\n    - It is uniquely identified by a MAL URI relative to the MAL context, the format of this URI depends on the transport used.\n    - It handles a counter of \nTransaction Id\n (field of MAL header)\n-   It owns a state.\n-   Its life cycle has three states:\n      - When created the \ninitialize\n function is called before the launch of processing loop that handles incoming message.\n      - When receiving a message the processing loop calls the \nhandle\n function to search the handler corresponding to the received message and then activate it.\n      - When stopped the \nfinalize\n function is called before the actor destruction.\n-   The \ninitialize\n and \nfinalize\n functions are customizable by the user.\n-   It runs in single-threaded way.\n-   Its state can be changed only through the handlers reactions.\n-   Its state can not be transmitted to another actor.\n\n\nIf a multithreaded execution mode is needed, for example to perform a costly CPU processing, then the handler must delegate the execution of this task to different actors. The processing is then performed in parallel, and the associated load is shared between all these actors.\n\n\nEach actor defines a specific endpoint corresponding to the listen socket of the underlying C/ZMQ actor, it uses the concept of poller to simultaneously listen to the user end-point and this internal end-point. The internal end-point allows to receive commands sent to the actor by the \nmal_actor_send_command\n function.\n\n\nMAL Actor API\n\n\nConstructor\n\n\nCreate an actor instance identified by a MAL URI. Creating an actor will create the end-point corresponding to the MAL URI of this actor, and the router needed to manage handlers of this actor. The state of this router is the state of the actor.\n\n\nA \nTransaction Id\n counter is created.\n\n\nDeclaration:\n\n\nmal_actor_t *mal_actor_new(\n  mal_ctx_t *mal_ctx,\n  mal_uri_t *uri,\n  void *state,\n  mal_actor_initialize_fn *initialize,\n  mal_actor_finalize_fn *finalize);\n\n\n\n\nParameters:\n\n\n\n\nmal_ctx\n : MAL context\n\n\nuri\n : MAL URI that identify this actor\n\n\nstate\n : actor state; untyped to allow polymorphism\n\n\ninitialize\n : initialization function\n\n\nfinalize\n : finalization function\n\n\n\n\nVirtual initialization function of the MAL actor\n\n\nDeclaration:\n\n\ntypedef int mal_actor_initialize_fn(void *self, mal_ctx_t *mal_ctx, mal_actor_t *mal_actor);\n\n\n\n\nParameters:\n\n\n\n\nself\n : actor state\n\n\nmal_ctx\n : MAL context pointer\n\n\nmal_actor\n : MAL actor pointer\n\n\n\n\nResult:\n\n\n\n\nError code\n\n\n\n\nVirtual finalisation function of the MAL actor\n\n\nDeclaration:\n\n\ntypedef int mal_handler_finalize_fn(void *self, mal_ctx_t *mal_ctx, mal_actor_t *mal_actor);\n\n\n\n\nParameters:\n\n\n\n\nself\n : actor state\n\n\nmal_ctx\n : MAL context pointer\n\n\nmal_actor\n : MAL actor pointer\n\n\n\n\nResult:\n\n\n\n\nError code\n\n\n\n\nSending a MAL message\n\n\nMAL messages are sent through the actor's integrated endpoint (see interface defined in 7.4.2). The actor's interface defines a function to find the corresponding end-point:\n\n\nmal_endpoint_t *mal_actor_get_mal_endpoint(mal_actor_t *self);\n\n\n\n\nHandlers registration\n\n\nThe registration of the handlers is done through the actor's integrated router (see interface defined in 7.6.3).\nThe actor's interface defines a function to find the corresponding router:\n\n\nmal_routing_t *mal_actor_get_router(mal_actor_t *self);\n\n\n\n\nSending a command to the MAL actor\n\n\nSending commands to the an actor via its internal endpoint can be done through the following function:\n\n\nint mal_actor_send_command(mal_actor_t *to, char *cmd);\n\n\n\n\nThe parameters of this function are the recipient actor and the string containing the command.\nFor example, to request the termination of an actor:\n\n\nmal_actor_send_command(actor, \n$TERM\n);\n\n\n\n\nDestructor\n\n\nDeletes the actor and free its state.\n\n\nvoid mal_actor_destroy(mal_actor_t **self_p);\n\n\n\n\nSimple example of a MAL application\n\n\nIn this example we use the code already introduced in the tutorial but we use the library of actors described in this chapter.\nMost of the code is identical and we only detail the aspects specifically related to the use of MAL actors framework.\n\n\nConsumer component\n\n\nDuring the creation of the consumer component we also create a MAL actor for managing this component:\n\n\nsend_app_myconsumer_t *consumer = send_app_myconsumer_new(\n  provider_uri,\n  authentication_id, qoslevel, priority, domain, network_zone, session,\n  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);\n\n\n\n\nmal_uri_t *consumer_uri = mal_ctx_create_uri(mal_ctx, \nsend_app/myconsumer\n);\nmal_actor_t *consumer_actor = mal_actor_new(\n  mal_ctx,\n  consumer_uri, consumer,\n  send_app_myconsumer_initialize, send_app_myconsumer_finalize);\n\n\n\n\nThe initialization and termination functions are provided to the actor during its creation.\nThe initialization function allows us to initiate the SEND interaction to the provider. This code corresponds\nto the code the run method described in section 4.1.2.\n\n\nProvider component\n\n\nDuring the creation of the provider component we also create a MAL actor for managing this component:\n\n\nsend_app_myprovider_t *provider =\n  send_app_myprovider_new(MALBINARY_FORMAT_CODE, encoder, decoder);\n\n\n\n\nmal_actor_t *provider_actor = mal_actor_new(\n  mal_ctx,\n  provider_uri, provider,\n  send_app_myprovider_initialize, send_app_myprovider_finalize);\n\n\n\n\nThe initialization and termination functions are provided to the actor during its creation.\nThe initialization function allow to record the handlers of the provider.\nThe message reception is now handled automatically by the MAL actor:\n\n\n\n\nWhen a MAL message is received on the endpoint corresponding to the provider's URI the registered handler is automatically executed.\n\n\nOtherwise the message is destroyed.\n\n\n\n\nRun the application\n\n\nConsumer and provider components are now actors, they do not require explicit creation of a ZMQ an actor to run:\n\n\nsend_app_create_provider(verbose, mal_ctx, provider_uri, encoder, decoder);\nsend_app_create_consumer(verbose, mal_ctx, provider_uri, encoder, decoder);\n\n\n\n\nThe launch of the application code is identical:\n\n\n\n\ncreation of the MAL context,\n\n\ncreation of encoder and decoder components,\n\n\ninstantiation of the MALZMQ transport,\n\n\nstarting the MAL context.", 
            "title": "Actor"
        }, 
        {
            "location": "/mal_actor/#actor-handler-execution-model", 
            "text": "The MAL actor uses the MAL C API and in particular the notions of  poller ,  end-point  and  handler . It is based on the notion of CZMQ actor.", 
            "title": "Actor / Handler Execution Model"
        }, 
        {
            "location": "/mal_actor/#mal-actor", 
            "text": "An actor is in charge of the execution of a set of interaction handlers corresponding to the interactions of a given end-point. The API allows the dynamic addition and removal of handlers. To avoid problems related to parallelism, registering and deleting a handler can be made only from the actor himself.\nA handler can only be performed by an unique actor.  An actor reacts to MAL messages independently of any role in the interaction. When receiving a message it searches for the corresponding handler in the list of registered handlers. If successful, it activates the handler by calling the function corresponding to the received message, otherwise the message is destroyed.  The lifetime of an interaction exceeds the reaction of the actor.  Only the actor who received the message initiating an interaction can answer to this interaction.  An actor has the following features:\n-   It corresponds to a single a single endpoint, therefore:\n    - It can only use a single transport (binding) to receive and send MAL messages.\n    - It can use multiple encoding formats for the MAL message body.\n    - It is uniquely identified by a MAL URI relative to the MAL context, the format of this URI depends on the transport used.\n    - It handles a counter of  Transaction Id  (field of MAL header)\n-   It owns a state.\n-   Its life cycle has three states:\n      - When created the  initialize  function is called before the launch of processing loop that handles incoming message.\n      - When receiving a message the processing loop calls the  handle  function to search the handler corresponding to the received message and then activate it.\n      - When stopped the  finalize  function is called before the actor destruction.\n-   The  initialize  and  finalize  functions are customizable by the user.\n-   It runs in single-threaded way.\n-   Its state can be changed only through the handlers reactions.\n-   Its state can not be transmitted to another actor.  If a multithreaded execution mode is needed, for example to perform a costly CPU processing, then the handler must delegate the execution of this task to different actors. The processing is then performed in parallel, and the associated load is shared between all these actors.  Each actor defines a specific endpoint corresponding to the listen socket of the underlying C/ZMQ actor, it uses the concept of poller to simultaneously listen to the user end-point and this internal end-point. The internal end-point allows to receive commands sent to the actor by the  mal_actor_send_command  function.", 
            "title": "MAL Actor"
        }, 
        {
            "location": "/mal_actor/#mal-actor-api", 
            "text": "", 
            "title": "MAL Actor API"
        }, 
        {
            "location": "/mal_actor/#constructor", 
            "text": "Create an actor instance identified by a MAL URI. Creating an actor will create the end-point corresponding to the MAL URI of this actor, and the router needed to manage handlers of this actor. The state of this router is the state of the actor.  A  Transaction Id  counter is created.  Declaration:  mal_actor_t *mal_actor_new(\n  mal_ctx_t *mal_ctx,\n  mal_uri_t *uri,\n  void *state,\n  mal_actor_initialize_fn *initialize,\n  mal_actor_finalize_fn *finalize);  Parameters:   mal_ctx  : MAL context  uri  : MAL URI that identify this actor  state  : actor state; untyped to allow polymorphism  initialize  : initialization function  finalize  : finalization function", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_actor/#virtual-initialization-function-of-the-mal-actor", 
            "text": "Declaration:  typedef int mal_actor_initialize_fn(void *self, mal_ctx_t *mal_ctx, mal_actor_t *mal_actor);  Parameters:   self  : actor state  mal_ctx  : MAL context pointer  mal_actor  : MAL actor pointer   Result:   Error code", 
            "title": "Virtual initialization function of the MAL actor"
        }, 
        {
            "location": "/mal_actor/#virtual-finalisation-function-of-the-mal-actor", 
            "text": "Declaration:  typedef int mal_handler_finalize_fn(void *self, mal_ctx_t *mal_ctx, mal_actor_t *mal_actor);  Parameters:   self  : actor state  mal_ctx  : MAL context pointer  mal_actor  : MAL actor pointer   Result:   Error code", 
            "title": "Virtual finalisation function of the MAL actor"
        }, 
        {
            "location": "/mal_actor/#sending-a-mal-message", 
            "text": "MAL messages are sent through the actor's integrated endpoint (see interface defined in 7.4.2). The actor's interface defines a function to find the corresponding end-point:  mal_endpoint_t *mal_actor_get_mal_endpoint(mal_actor_t *self);", 
            "title": "Sending a MAL message"
        }, 
        {
            "location": "/mal_actor/#handlers-registration", 
            "text": "The registration of the handlers is done through the actor's integrated router (see interface defined in 7.6.3).\nThe actor's interface defines a function to find the corresponding router:  mal_routing_t *mal_actor_get_router(mal_actor_t *self);", 
            "title": "Handlers registration"
        }, 
        {
            "location": "/mal_actor/#sending-a-command-to-the-mal-actor", 
            "text": "Sending commands to the an actor via its internal endpoint can be done through the following function:  int mal_actor_send_command(mal_actor_t *to, char *cmd);  The parameters of this function are the recipient actor and the string containing the command.\nFor example, to request the termination of an actor:  mal_actor_send_command(actor,  $TERM );", 
            "title": "Sending a command to the MAL actor"
        }, 
        {
            "location": "/mal_actor/#destructor", 
            "text": "Deletes the actor and free its state.  void mal_actor_destroy(mal_actor_t **self_p);", 
            "title": "Destructor"
        }, 
        {
            "location": "/mal_actor/#simple-example-of-a-mal-application", 
            "text": "In this example we use the code already introduced in the tutorial but we use the library of actors described in this chapter.\nMost of the code is identical and we only detail the aspects specifically related to the use of MAL actors framework.", 
            "title": "Simple example of a MAL application"
        }, 
        {
            "location": "/mal_actor/#consumer-component", 
            "text": "During the creation of the consumer component we also create a MAL actor for managing this component:  send_app_myconsumer_t *consumer = send_app_myconsumer_new(\n  provider_uri,\n  authentication_id, qoslevel, priority, domain, network_zone, session,\n  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);  mal_uri_t *consumer_uri = mal_ctx_create_uri(mal_ctx,  send_app/myconsumer );\nmal_actor_t *consumer_actor = mal_actor_new(\n  mal_ctx,\n  consumer_uri, consumer,\n  send_app_myconsumer_initialize, send_app_myconsumer_finalize);  The initialization and termination functions are provided to the actor during its creation.\nThe initialization function allows us to initiate the SEND interaction to the provider. This code corresponds\nto the code the run method described in section 4.1.2.", 
            "title": "Consumer component"
        }, 
        {
            "location": "/mal_actor/#provider-component", 
            "text": "During the creation of the provider component we also create a MAL actor for managing this component:  send_app_myprovider_t *provider =\n  send_app_myprovider_new(MALBINARY_FORMAT_CODE, encoder, decoder);  mal_actor_t *provider_actor = mal_actor_new(\n  mal_ctx,\n  provider_uri, provider,\n  send_app_myprovider_initialize, send_app_myprovider_finalize);  The initialization and termination functions are provided to the actor during its creation.\nThe initialization function allow to record the handlers of the provider.\nThe message reception is now handled automatically by the MAL actor:   When a MAL message is received on the endpoint corresponding to the provider's URI the registered handler is automatically executed.  Otherwise the message is destroyed.", 
            "title": "Provider component"
        }, 
        {
            "location": "/mal_actor/#run-the-application", 
            "text": "Consumer and provider components are now actors, they do not require explicit creation of a ZMQ an actor to run:  send_app_create_provider(verbose, mal_ctx, provider_uri, encoder, decoder);\nsend_app_create_consumer(verbose, mal_ctx, provider_uri, encoder, decoder);  The launch of the application code is identical:   creation of the MAL context,  creation of encoder and decoder components,  instantiation of the MALZMQ transport,  starting the MAL context.", 
            "title": "Run the application"
        }, 
        {
            "location": "/mal_czmq/", 
            "text": "MAL/ZMQ Transport\n\n\nThis section describes the implementation of MAL binding to ZMTP transport on CZMQ API.\nIt is not a description as protocol terms (see the \nMission Operations - MAL binding to ZMTP\n CCSDS book) but as API.\n\n\nThe encoding format of the MAL header is given in the \nMission Operations - MAL binding to ZMTP\n CCSDS book.\n\n\nCurrently a MAL message is transmit in a single ZMQ frame (zframe).\n\n\nThe following sections describe the implementation of the MAL / CZMQ module:\n\n\n-  MALZMQ header configuration.\n-  MALZMQ context constructor.\n-  Boot.\n-  MAL message reception.\n-  Implementation of virtual functions needed by the MAL API.\n\n\n\nMALZMQ Header\n\n\nA class is defined to handle the specificities of MALZMQ header format:\n\n\n-  MALZMQ version number.\n-  Mapping directory.\n-  Presence flags for optional MALZMQ header fields.\n-  Value of non-present fields.\n\n\n\nConstructor\n\n\nmalzmq_header_t *malzmq_header_new(\n  malzmq_mapping_directory_t *mapping_directory,\n  bool priority_flag, mal_uinteger_t priority,\n  bool timestamp_flag, mal_identifier_t *network_zone,\n  mal_identifier_t *session_name, mal_identifier_list_t *domain,\n  mal_blob_t *authentication_id);\n\n\n\n\nParameters\n\n\n-  `mapping_directory`: Mapping directory to use by encoding, may be null.\n-  `priority_flag`: Boolean indicating the presence of the *Priority* field in the MALZMQ header.\n-  `priority`: Value of the *Priority* field if it is not present in the MALZMQ header.\n-  `timestamp_flag`: Boolean indicating the presence of the *TimeStamp* field in the MALZMQ header.\n-  `network_zone`: Value of the *Network Zone* field if it is not present in the MALZMQ header.\n    If NULL the *Network Zone* field should be present in the MALZMQ header.\n-  `session_name`: Value of the *Session Name* field if it is not present in the MALZMQ header.\n    If NULL the *Session Name* field should be present in the MALZMQ header.\n-  `domain`: Value of the *Domain* field if it is not present in the MALZMQ header.\n    If NULL the *Domain* field should be present in the MALZMQ header.\n-  `authentication_id`: Value of the *Authentication Id* field if it is not present in the MALZMQ header.\n    If NULL the *Authentication Id* field should be present in the MALZMQ header.\n\n\n\nConfiguration parameters\n\n\nSome MAL header fields can be always identical for a given application.\nTransmit their values with each call would be redundant, and thus we can optimize performance by\nomitting them in the MALZMQ header. These fields are: \nPRIORITY\n, \nNETWORK_ZONE\n, \nSESSION_NAME\n,\n\nDOMAIN\n, \nAUTHENTICATION_ID\n. The presence of these fields in the header MALZMQ and their potential\noverall value is defined in the MALZMQ header constructor.\n\n\nAnother field of the MAL header, \nTIMESTAMP\n, can also be omitted in the header MALZMQ. This possible\nomission is also defined in the MALZMQ header constructor. There is no replacement value defined for this\nfield.\n\n\nIt goes without saying that these configuration parameters must be provided in an identical manner to all\nentities of the application.\n\n\nMapping directory\n\n\nThe MAL message header contains several fields whose size can be important: URIs, strings, etc.\nTo optimize the performance messages exchanged between instances of MAL/CZMQ can contain fields encoded\nin smaller scalar types.\n\n\nTo maintain compatibility with the MAL, these encoded fields are systematically converted into their MAL\nequivalent when accessed by the user of the MAL API. To allow this transformation, informations must be\nmaintained in a directory on both sides (consumer and provider).\n\n\nThe purpose of this section is to describe the corresponding API and its use.\n\n\nPrinciples\n\n\nThe mapping directiry maintains a mapping between strings and numeric values. The numerical value is called\n\nMDK\n for \nMapping Key Directory\n.\n\n\nThe directory allows to find the MDK corresponding to a given string during encoding, and to find the string\ncorresponding to a  MDK during decoding.\n\n\nIt is not under the responsibility of the MAL/CZMQ to provide a consistent directory to each side of the\ninteraction. This responsibility relies to the application. The simplest way to achieve this is to provide\na static catalog to all components during the installation of the the application. However, nothing prevents\nan application to provide a more dynamic implementation of the directory.\n\n\nEncoding\n\n\nThe encoding of a string under his MDK form is optional, to handle the case where there is no MDK in the\ndirectory for the string to be encoded. This is why the mapping described in 14.3 refers to a type \nOptional MDK\n.\n\n\nThe principle of \nOptional MDK\n encoding is derived from the String \nMAL Binary\n encoding. This encoding\nconsists normally in the encoding of the string length (typed \nUInteger\n), followed by the encoding of the characters\nthemselves. The \nOptional MDK\n encoding converts the 32 bit length field in an Integer value to separately exploit\nthe sign and the absolute value. The sign describes the nature of the field represented by the absolute value,\na \nMDK\n if the sign is negative, or length if the sign is positive. In the second case the characters are encoded after\nthe length field as in \nMAL Binary\n encoding.\n\n\nAn encoded string in its MDK form therefore requires only 4 bytes, representing the negative value of the MDK.\nIf it is not encoded in its MDK form a chain complies with its \nMAL Binary\n encoding form.\n\n\nThe special case of a zero value for the initial Integer corresponds to the \nMAL Binary\n encoding of an empty\nstring. Consequently an MDK must be strictly positive.\n\n\nAPI\n\n\nThe directory mapping, typed \nmalzmq_mapping_directory_t\n, is provided as a functions table.\n\n\ntypedef struct _malzmq_mapping_directory_t malzmq_mapping_directory_t;\nstruct _malzmq_mapping_directory_t {\n  malzmq_md_get_key_fn *get_key_fn;\n  malzmq_md_get_string_fn *get_string_fn;\n  malzmq_md_put_string_fn *put_string_fn;\n};\n\n\n\n\nFields:\n\n\n- `get_key_fn`: Gets the MDK of a string if it exists in the directory.\n- `get_string_fn`: Gets the string corresponding to an MDK.\n- `put_string_fn`: Adds a string in the directory and return the corresponding MDK.\n\n\n\nBelow the detailed interface of these functions.\n\n\ntypedef int malzmq_md_get_key_fn(char *string, unsigned int *key);\n\n\n\n\nParameters\n\n\n    - `string`: String to search for a possible key correspondence. Should not be null.\n    - `key`: return value of the matching MDK for the string, if it exists.\n\n\n\nResult:\n\n\n    - 0: execution valid, the return key can be used.\n    - \n0: error code, the key parameter is undefined.\n\n\n\ntypedef int malzmq_md_get_string_fn(unsigned int key, char **string);\n\n\n\n\nParameters\n\n\n    - `key`: MDK to search for a possible string correspondence.\n    - `string`: return value of the matching string for the MDK, if it exists.\n     This string is allocated and should be released by free or various specific functions (mal_string_destroy, etc).\n\n\n\nResult:\n\n\n    - 0: execution valid, the return string can be used.\n    - \n0: error code, the string parameter is undefined.\n\n\n\ntypedef int malzmq_md_put_string_fn(char *string, unsigned int *key);\n\n\n\n\nParameters\n\n\n    - `string`: string for which we want to create a matching key, should not be null.\n     The directory must not retain the string beyond this call to allow the caller to release it if necessary.\n    - `key`: return value of the matching MDK for the string. Must be strictly positive and strictly less\n    than 231. A distinctive value is created if and only if an existing MDK does not exist for this string\n    in the directory.\n\n\n\nResult:\n\n\n    - 0: execution valid, the return key can be used.\n    - \n0: error code, the string is not registered in the directory and the key parameter is undefined.\n\n\n\nNote:\n\n\nThe directory functions only work on strings (char *), because the different target types \nmal_string_t\n,\n\nmal_uri_t\n and \nmal_identifier_t\n, are themselves defined as \nchar*\n. Otherwise, the catalog should \nprovide distinct functions for each of these types.\n\n\nUsage\n\n\nThe directory is currently used only for the following header fields: \nURI from\n, \nURI to\n, \nNetwork Zone\n,\n\nSession Name\n and \nDomain\n.\n\n\nUsing explicitly the directory for selected fields of the body is also possible, but it would break the current\ncompliance to the MAL binary encoding format of the body.\n\n\nMALZMQ context constructor\n\n\nmalzmq_ctx_t *malzmq_ctx_new(\n  mal_ctx_t *mal_ctx,\n  malzmq_mapping_uri_t *mapping_uri,\n  char *hostname, char *port, malzmq_header_t *malzmq_header,\n  malbinary_encoder_t *encoder, malbinary_decoder_t *decoder,\n  bool verbose);\n\n\n\n\nParameters\n\n\n    - `mal_ctx`: MAL context.\n    - `mapping_uri`: Processing fonctions to transform MAL URI in ZMQ URI. If this mapping is null, the\n    default URI mapping functions are used.\n    - `hostname`: IP address used to listen incoming connections.\n    - `port`: port used to listen incoming connections.\n    - `malzmq_header`: Flags and optional fields. The configuration of the MALZMQ header is global to the\n    MALZMQ context.\n    - `encoder`: Encoding context used to encode the MAL headers.\n    - `decoder`: Decoding context used to decode the MAL headers.\n    - `verbose`: Flag allowing to enable/disable the logging traces.\n\n\n\nThe constructor performs the following actions:\n\n\n    - Creating a ZMQ ROUTER socket for accepting connections initiated by other remote MALZMQ\n    contexts: `SOCKET_MAL_ROUTER`. The ZMQ URI used is built from `hostname` and `port` parameters,\n    and the URI mapping functions.\n    - Creating a ZMQ SUB socket for accepting messages published by other remote MALZMQ contexts: \n    `SOCKET_MAL_SUB`. The ZMQ URI used is built from `hostname` and `port` parameters, and the URI\n    mapping functions.\n    - Creating an `inproc` ZMQ ROUTER socket for communicating with the services registered in the\n    context: `SOCKET_Z_ROUTER`.\n    - Creating a `zloop` to handle the message routing between the external MALZMQ contexts\n    and the internal services.\n\n\n\nURI mapping functions\n\n\nThe mapping between MAL URI and ZMQ URI is ensured by 3 functions:\n\n\n    - The first function, `get_p2p_zm`, takes in parameter the MAL URI of a service and returns the \n    ZMQ URI to bind the ZMQ DEALER listening socket corresponding to the MAL context. For example:\n    `malzmq://host:port/service` to `tcp://*:port`.\n    - The second function, `get_ps_zmquri`, takes in parameter the MAL URI of a service and returns\n    the ZMQ URI to connect the ZMQ SUB listening socket corresponding to the MAL context. For example: \n    `malzmq://host:port/service` to `tcp://host:(port+1)` or `pgm://itf;mcast_addr:(port+1)`.\n    - The last function, `get_zmquri_to`, takes in parameter a MAL message to send and returns the \n    corresponding ZMQ URI to the interaction stage and MAL URI of the destination service. \n    For example, if the MAL URI of the destination service is `malzmq://host1:port1/service`:\n      - for `MAL_INTERACTIONTYPE_INVOKE`, `MAL_IP_STAGE_INVOKE` it returns `tcp://host1:port1`.\n      - for `MAL_INTERACTIONTYPE_PUBSUB`, `MAL_IP_STAGE_PUBSUB_PUBLISH` it returns `tcp://*:(port1+1)`\n      or `epgm://itf;mcast_addr:(port+1)`.\n\n\n\nFunctions for mapping MAL URI to ZMQ URI are given to the MALZMQ context through the malzmq_mapping_uri_t structure. If this\nparameter is null the default functions defined in the MALZMQ transport are used; these functions consider that TCPis used for\nall interactions and the port used for Publish/Subscribe interaction is the service port +1.\n\n\ntypedef mal_uri_t *malzmq_get_p2p_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_get_ps_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_getzmquri_to_fn(mal_message_t *message);\n\ntypedef struct _malzmq_mapping_uri_t malzmq_mapping_uri_t;\n\nstruct _malzmq_mapping_uri_t {\n  malzmq_get_p2p_zmquri_fn *get_p2p_zmquri_fn;\n  malzmq_get_ps_zmquri_fn *get_ps_zmquri_fn;\n  malzmq_getzmquri_to_fn *getzmquri_to_fn;\n};\n\n\n\n\nDefault mapping\n\n\nThe default mapping implemented in the POC for MALZMQ transport uses TCP communications for both Point-to-Point and\nPublish/Subscribe:\n\n\n    - `malzmq_get_p2p_zmquri_fn`: for `malzmq://host:port/service` it returns `tcp://*:port`.\n    - `malzmq_get_ps_zmquri_fn`: for `malzmq://host:port/service` it returns `tcp://host:port_ps`\n    with `port_ps=port+1`.\n    - `malzmq_getzmquri_to_fn`:\n       - If the `interaction_type` and `interaction_stage` fields of the sent message are\n       `MAL_INTERACTIONTYPE_PUBSUB` and `MAL_IP_STAGE_PUBSUB_PUBLISH`: for\n        `malzmq://host1:port1/service it returns `tcp://host1:port1_ps` with\n       `port1_ps=port1+1`\n       - In all other cases: for `malzmq://host1:port1/service` it returns `tcp://host1:port1`.\n\n\n\nStart-up\n\n\nThe following function will start the MALZMQ context. This function starts the zloop and blocks as the\nzloop did not complete.\n\n\nint malzmq_ctx_start(malzmq_ctx_t *self);\n\n\n\n\nzloop behavior\n\n\nThe zloop listens (\nSOCKET_MAL_ROUTER\n and \nSOCKET_MAL_SUB\n) to the messages sent by remote MALZMQ\ncontexts. When ZMQ message is received, the following actions are performed:\n\n\n    - Gets and destroy of the first frame containing the identity of the caller (currently, the ZMQ\n    connections are only used in one direction, therefore the identity of the caller is not retained).\n    - The next frame is not extracted (zmsg_pop) from the ZMQ message, but only read (zmsg_next)\n    enabling to send this ZMQ message to the recipient endpoint.\n    - Only the `URI To` field is decoded, this field identifies the inproc `DEALER` socket used by the\n    recipient endpoint.\n    - The ZMQ message is forwarded to the recipient endpoint through the inproc `SOCKET_ACTOR_ROUTER`.\n\n\n\nMessage receiving\n\n\nWhen a MAL endpoint asks for receiving a message, the MALZMQ transport listens on the corrsponding ZMQ DEALER socket\nconnected to the ZMQ ROUTER socket of the zloop.\n\n\nWhen receiving a MAL message the following actions are performed:\n\n\n    - The unique frame of the ZMQ message is extracted.\n    - A `mal_message` structure is instanciated.\n    - The MAL header fields are decoded using MAL Binary encoding. The optional unencoded fields are set \n    using the global MALZMQ configuration header.\n    - The MAL message body is directly set from the ZMQ frame (`data` field of `zframe`) without copy. \n    Consequently, the ZMQ frame can only be destroyed at the time of the destruction of MAL message. The\n     `body_owner` field of the message is affected with the MAL ZMQ frame.\n    - The built message is returned to the caller, the destruction of the MAL message is the responsibility\n    of the handler of this message.\n\n\n\nVirtual function to build URI\n\n\nThe URI format is:\n\n\nmalzmq://\nhostname\n:\nport\n/\nid\n\n\n\n\n\nThe underlying transport protocol used by ZMQ is not specified in the URI. It is specified in the creation of MALZMQ context.\n\n\nIn some cases, the MALZMQ context could optimize communication using a more efficient transport protocol, for example:\n\n\n    - `ipc`: if both consumer and provider are on the same host.\n    - `inproc`: if both consumer and provider are in the same process. Be careful in this case to the \n    starting order as *inproc* does not ensure the temporal decoupling for ZMQ sockets.\n\n\n\nThis optimization is not currently implemented in the prototype.\n\n\nVirtual function to create an endpoint\n\n\nA MALZMQ endpoint is created and returned as an untyped pointer \nvoid *\n.\n\n\nSpecific MALZMQ endpoint datas are:\n\n\n    - the MALZMQ context,\n    - the corresponding MAL endpoint,\n    - the listening inproc ZMQ DEALER socket used to receive forwarded messages from the zloop,\n    - an hashtable containing the ZMQ sockets open to the remote MALZMQ contexts.\n\n\n\nDuring the initialization of the endpoint, the following actions are performed:\n\n\n    - creating a ZMQ DEALER socket,\n    - registering this socket identity with the endpoint URI,\n    - connection of this DEALER socket with the ROUTER socket handled by the zloop (ZLOOP_ENDPOINTS_SOCKET_URI)\n\n\n\nVirtual function to send a message\n\n\nThe message's MAL URI is converted into a ZMQ URI:\n\n\n    - MAL URI format: `malzmq://\nhostname\n:\nport\n/\nid\n`\n    - ZMQ URI format: `\nprotocole zmq\n://\nhostname\n:\nport\n`\n\n\n\nA ZMQ DEALER socket connected to this URI is searched in the hashtable owned by the endpoint. If the socket is not\nfound then a new one is created and registered in the table (the key is the ZMQ URI).\n\n\nThe MAL message is encoded and transmitted in a single frame ZMQ.\n\n\nVirtual function to create a poller\n\n\nA MALZMQ poller is created and returned as an untyped pointer \nvoid *\n.\n\n\nSpecific MALZMQ poller datas are:\n\n\n    - the MALZMQ context,\n    - the corresponding MAL poller,\n    - the ZMQ zpoller listening on sockets of endpoints,\n    - the list of endpoints associated to this poller.\n\n\n\nDuring the initialization of the poller, the following actions are performed:\n\n\n    - creation of a ZMQ zpoller,\n    - creation ofn empty list of endpoints.\n\n\n\nVirtual function to add an endpoint to a poller\n\n\nThis function adds to the poller the endpoint in parameter. The end-point is added to the list of\nendpoints, the corresponding socket is added to the zpoller.\n\n\nVirtual function to remove an endpoint to a poller\n\n\nThis function removes from the poller the endpoint in parameter. The end-point is removed from the\nlist of poller, the corresponding socket is removed from the zpoller.\n\n\nVirtual function to wait a message on a poller\n\n\nThis function waits to receive a message on the associated zpoller.\n\n\nIf a message arrives before the timeout expiration the corresponding endpoint is searched in the\nlist of endpoints and is returned in the corresponding parameter. If there is no matching endpoint\nregistered an error is returned.\n\n\nVirtual function to delete a message\n\n\nThis function checks if the \nbody_owner\n message field MAL is set. In this case, it means that the\nMAL message was created (decoded) from a ZMQ frame (\nzframe\n) and must be destroyed (\nzframe_destroy\n).", 
            "title": "MAL/CZMQ"
        }, 
        {
            "location": "/mal_czmq/#malzmq-transport", 
            "text": "This section describes the implementation of MAL binding to ZMTP transport on CZMQ API.\nIt is not a description as protocol terms (see the  Mission Operations - MAL binding to ZMTP  CCSDS book) but as API.  The encoding format of the MAL header is given in the  Mission Operations - MAL binding to ZMTP  CCSDS book.  Currently a MAL message is transmit in a single ZMQ frame (zframe).  The following sections describe the implementation of the MAL / CZMQ module:  -  MALZMQ header configuration.\n-  MALZMQ context constructor.\n-  Boot.\n-  MAL message reception.\n-  Implementation of virtual functions needed by the MAL API.", 
            "title": "MAL/ZMQ Transport"
        }, 
        {
            "location": "/mal_czmq/#malzmq-header", 
            "text": "A class is defined to handle the specificities of MALZMQ header format:  -  MALZMQ version number.\n-  Mapping directory.\n-  Presence flags for optional MALZMQ header fields.\n-  Value of non-present fields.", 
            "title": "MALZMQ Header"
        }, 
        {
            "location": "/mal_czmq/#constructor", 
            "text": "malzmq_header_t *malzmq_header_new(\n  malzmq_mapping_directory_t *mapping_directory,\n  bool priority_flag, mal_uinteger_t priority,\n  bool timestamp_flag, mal_identifier_t *network_zone,\n  mal_identifier_t *session_name, mal_identifier_list_t *domain,\n  mal_blob_t *authentication_id);  Parameters  -  `mapping_directory`: Mapping directory to use by encoding, may be null.\n-  `priority_flag`: Boolean indicating the presence of the *Priority* field in the MALZMQ header.\n-  `priority`: Value of the *Priority* field if it is not present in the MALZMQ header.\n-  `timestamp_flag`: Boolean indicating the presence of the *TimeStamp* field in the MALZMQ header.\n-  `network_zone`: Value of the *Network Zone* field if it is not present in the MALZMQ header.\n    If NULL the *Network Zone* field should be present in the MALZMQ header.\n-  `session_name`: Value of the *Session Name* field if it is not present in the MALZMQ header.\n    If NULL the *Session Name* field should be present in the MALZMQ header.\n-  `domain`: Value of the *Domain* field if it is not present in the MALZMQ header.\n    If NULL the *Domain* field should be present in the MALZMQ header.\n-  `authentication_id`: Value of the *Authentication Id* field if it is not present in the MALZMQ header.\n    If NULL the *Authentication Id* field should be present in the MALZMQ header.", 
            "title": "Constructor"
        }, 
        {
            "location": "/mal_czmq/#configuration-parameters", 
            "text": "Some MAL header fields can be always identical for a given application.\nTransmit their values with each call would be redundant, and thus we can optimize performance by\nomitting them in the MALZMQ header. These fields are:  PRIORITY ,  NETWORK_ZONE ,  SESSION_NAME , DOMAIN ,  AUTHENTICATION_ID . The presence of these fields in the header MALZMQ and their potential\noverall value is defined in the MALZMQ header constructor.  Another field of the MAL header,  TIMESTAMP , can also be omitted in the header MALZMQ. This possible\nomission is also defined in the MALZMQ header constructor. There is no replacement value defined for this\nfield.  It goes without saying that these configuration parameters must be provided in an identical manner to all\nentities of the application.", 
            "title": "Configuration parameters"
        }, 
        {
            "location": "/mal_czmq/#mapping-directory", 
            "text": "The MAL message header contains several fields whose size can be important: URIs, strings, etc.\nTo optimize the performance messages exchanged between instances of MAL/CZMQ can contain fields encoded\nin smaller scalar types.  To maintain compatibility with the MAL, these encoded fields are systematically converted into their MAL\nequivalent when accessed by the user of the MAL API. To allow this transformation, informations must be\nmaintained in a directory on both sides (consumer and provider).  The purpose of this section is to describe the corresponding API and its use.", 
            "title": "Mapping directory"
        }, 
        {
            "location": "/mal_czmq/#principles", 
            "text": "The mapping directiry maintains a mapping between strings and numeric values. The numerical value is called MDK  for  Mapping Key Directory .  The directory allows to find the MDK corresponding to a given string during encoding, and to find the string\ncorresponding to a  MDK during decoding.  It is not under the responsibility of the MAL/CZMQ to provide a consistent directory to each side of the\ninteraction. This responsibility relies to the application. The simplest way to achieve this is to provide\na static catalog to all components during the installation of the the application. However, nothing prevents\nan application to provide a more dynamic implementation of the directory.", 
            "title": "Principles"
        }, 
        {
            "location": "/mal_czmq/#encoding", 
            "text": "The encoding of a string under his MDK form is optional, to handle the case where there is no MDK in the\ndirectory for the string to be encoded. This is why the mapping described in 14.3 refers to a type  Optional MDK .  The principle of  Optional MDK  encoding is derived from the String  MAL Binary  encoding. This encoding\nconsists normally in the encoding of the string length (typed  UInteger ), followed by the encoding of the characters\nthemselves. The  Optional MDK  encoding converts the 32 bit length field in an Integer value to separately exploit\nthe sign and the absolute value. The sign describes the nature of the field represented by the absolute value,\na  MDK  if the sign is negative, or length if the sign is positive. In the second case the characters are encoded after\nthe length field as in  MAL Binary  encoding.  An encoded string in its MDK form therefore requires only 4 bytes, representing the negative value of the MDK.\nIf it is not encoded in its MDK form a chain complies with its  MAL Binary  encoding form.  The special case of a zero value for the initial Integer corresponds to the  MAL Binary  encoding of an empty\nstring. Consequently an MDK must be strictly positive.", 
            "title": "Encoding"
        }, 
        {
            "location": "/mal_czmq/#api", 
            "text": "The directory mapping, typed  malzmq_mapping_directory_t , is provided as a functions table.  typedef struct _malzmq_mapping_directory_t malzmq_mapping_directory_t;\nstruct _malzmq_mapping_directory_t {\n  malzmq_md_get_key_fn *get_key_fn;\n  malzmq_md_get_string_fn *get_string_fn;\n  malzmq_md_put_string_fn *put_string_fn;\n};  Fields:  - `get_key_fn`: Gets the MDK of a string if it exists in the directory.\n- `get_string_fn`: Gets the string corresponding to an MDK.\n- `put_string_fn`: Adds a string in the directory and return the corresponding MDK.  Below the detailed interface of these functions.  typedef int malzmq_md_get_key_fn(char *string, unsigned int *key);  Parameters      - `string`: String to search for a possible key correspondence. Should not be null.\n    - `key`: return value of the matching MDK for the string, if it exists.  Result:      - 0: execution valid, the return key can be used.\n    -  0: error code, the key parameter is undefined.  typedef int malzmq_md_get_string_fn(unsigned int key, char **string);  Parameters      - `key`: MDK to search for a possible string correspondence.\n    - `string`: return value of the matching string for the MDK, if it exists.\n     This string is allocated and should be released by free or various specific functions (mal_string_destroy, etc).  Result:      - 0: execution valid, the return string can be used.\n    -  0: error code, the string parameter is undefined.  typedef int malzmq_md_put_string_fn(char *string, unsigned int *key);  Parameters      - `string`: string for which we want to create a matching key, should not be null.\n     The directory must not retain the string beyond this call to allow the caller to release it if necessary.\n    - `key`: return value of the matching MDK for the string. Must be strictly positive and strictly less\n    than 231. A distinctive value is created if and only if an existing MDK does not exist for this string\n    in the directory.  Result:      - 0: execution valid, the return key can be used.\n    -  0: error code, the string is not registered in the directory and the key parameter is undefined.  Note:  The directory functions only work on strings (char *), because the different target types  mal_string_t , mal_uri_t  and  mal_identifier_t , are themselves defined as  char* . Otherwise, the catalog should \nprovide distinct functions for each of these types.", 
            "title": "API"
        }, 
        {
            "location": "/mal_czmq/#usage", 
            "text": "The directory is currently used only for the following header fields:  URI from ,  URI to ,  Network Zone , Session Name  and  Domain .  Using explicitly the directory for selected fields of the body is also possible, but it would break the current\ncompliance to the MAL binary encoding format of the body.", 
            "title": "Usage"
        }, 
        {
            "location": "/mal_czmq/#malzmq-context-constructor", 
            "text": "malzmq_ctx_t *malzmq_ctx_new(\n  mal_ctx_t *mal_ctx,\n  malzmq_mapping_uri_t *mapping_uri,\n  char *hostname, char *port, malzmq_header_t *malzmq_header,\n  malbinary_encoder_t *encoder, malbinary_decoder_t *decoder,\n  bool verbose);  Parameters      - `mal_ctx`: MAL context.\n    - `mapping_uri`: Processing fonctions to transform MAL URI in ZMQ URI. If this mapping is null, the\n    default URI mapping functions are used.\n    - `hostname`: IP address used to listen incoming connections.\n    - `port`: port used to listen incoming connections.\n    - `malzmq_header`: Flags and optional fields. The configuration of the MALZMQ header is global to the\n    MALZMQ context.\n    - `encoder`: Encoding context used to encode the MAL headers.\n    - `decoder`: Decoding context used to decode the MAL headers.\n    - `verbose`: Flag allowing to enable/disable the logging traces.  The constructor performs the following actions:      - Creating a ZMQ ROUTER socket for accepting connections initiated by other remote MALZMQ\n    contexts: `SOCKET_MAL_ROUTER`. The ZMQ URI used is built from `hostname` and `port` parameters,\n    and the URI mapping functions.\n    - Creating a ZMQ SUB socket for accepting messages published by other remote MALZMQ contexts: \n    `SOCKET_MAL_SUB`. The ZMQ URI used is built from `hostname` and `port` parameters, and the URI\n    mapping functions.\n    - Creating an `inproc` ZMQ ROUTER socket for communicating with the services registered in the\n    context: `SOCKET_Z_ROUTER`.\n    - Creating a `zloop` to handle the message routing between the external MALZMQ contexts\n    and the internal services.", 
            "title": "MALZMQ context constructor"
        }, 
        {
            "location": "/mal_czmq/#uri-mapping-functions", 
            "text": "The mapping between MAL URI and ZMQ URI is ensured by 3 functions:      - The first function, `get_p2p_zm`, takes in parameter the MAL URI of a service and returns the \n    ZMQ URI to bind the ZMQ DEALER listening socket corresponding to the MAL context. For example:\n    `malzmq://host:port/service` to `tcp://*:port`.\n    - The second function, `get_ps_zmquri`, takes in parameter the MAL URI of a service and returns\n    the ZMQ URI to connect the ZMQ SUB listening socket corresponding to the MAL context. For example: \n    `malzmq://host:port/service` to `tcp://host:(port+1)` or `pgm://itf;mcast_addr:(port+1)`.\n    - The last function, `get_zmquri_to`, takes in parameter a MAL message to send and returns the \n    corresponding ZMQ URI to the interaction stage and MAL URI of the destination service. \n    For example, if the MAL URI of the destination service is `malzmq://host1:port1/service`:\n      - for `MAL_INTERACTIONTYPE_INVOKE`, `MAL_IP_STAGE_INVOKE` it returns `tcp://host1:port1`.\n      - for `MAL_INTERACTIONTYPE_PUBSUB`, `MAL_IP_STAGE_PUBSUB_PUBLISH` it returns `tcp://*:(port1+1)`\n      or `epgm://itf;mcast_addr:(port+1)`.  Functions for mapping MAL URI to ZMQ URI are given to the MALZMQ context through the malzmq_mapping_uri_t structure. If this\nparameter is null the default functions defined in the MALZMQ transport are used; these functions consider that TCPis used for\nall interactions and the port used for Publish/Subscribe interaction is the service port +1.  typedef mal_uri_t *malzmq_get_p2p_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_get_ps_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_getzmquri_to_fn(mal_message_t *message);\n\ntypedef struct _malzmq_mapping_uri_t malzmq_mapping_uri_t;\n\nstruct _malzmq_mapping_uri_t {\n  malzmq_get_p2p_zmquri_fn *get_p2p_zmquri_fn;\n  malzmq_get_ps_zmquri_fn *get_ps_zmquri_fn;\n  malzmq_getzmquri_to_fn *getzmquri_to_fn;\n};", 
            "title": "URI mapping functions"
        }, 
        {
            "location": "/mal_czmq/#default-mapping", 
            "text": "The default mapping implemented in the POC for MALZMQ transport uses TCP communications for both Point-to-Point and\nPublish/Subscribe:      - `malzmq_get_p2p_zmquri_fn`: for `malzmq://host:port/service` it returns `tcp://*:port`.\n    - `malzmq_get_ps_zmquri_fn`: for `malzmq://host:port/service` it returns `tcp://host:port_ps`\n    with `port_ps=port+1`.\n    - `malzmq_getzmquri_to_fn`:\n       - If the `interaction_type` and `interaction_stage` fields of the sent message are\n       `MAL_INTERACTIONTYPE_PUBSUB` and `MAL_IP_STAGE_PUBSUB_PUBLISH`: for\n        `malzmq://host1:port1/service it returns `tcp://host1:port1_ps` with\n       `port1_ps=port1+1`\n       - In all other cases: for `malzmq://host1:port1/service` it returns `tcp://host1:port1`.", 
            "title": "Default mapping"
        }, 
        {
            "location": "/mal_czmq/#start-up", 
            "text": "The following function will start the MALZMQ context. This function starts the zloop and blocks as the\nzloop did not complete.  int malzmq_ctx_start(malzmq_ctx_t *self);", 
            "title": "Start-up"
        }, 
        {
            "location": "/mal_czmq/#zloop-behavior", 
            "text": "The zloop listens ( SOCKET_MAL_ROUTER  and  SOCKET_MAL_SUB ) to the messages sent by remote MALZMQ\ncontexts. When ZMQ message is received, the following actions are performed:      - Gets and destroy of the first frame containing the identity of the caller (currently, the ZMQ\n    connections are only used in one direction, therefore the identity of the caller is not retained).\n    - The next frame is not extracted (zmsg_pop) from the ZMQ message, but only read (zmsg_next)\n    enabling to send this ZMQ message to the recipient endpoint.\n    - Only the `URI To` field is decoded, this field identifies the inproc `DEALER` socket used by the\n    recipient endpoint.\n    - The ZMQ message is forwarded to the recipient endpoint through the inproc `SOCKET_ACTOR_ROUTER`.", 
            "title": "zloop behavior"
        }, 
        {
            "location": "/mal_czmq/#message-receiving", 
            "text": "When a MAL endpoint asks for receiving a message, the MALZMQ transport listens on the corrsponding ZMQ DEALER socket\nconnected to the ZMQ ROUTER socket of the zloop.  When receiving a MAL message the following actions are performed:      - The unique frame of the ZMQ message is extracted.\n    - A `mal_message` structure is instanciated.\n    - The MAL header fields are decoded using MAL Binary encoding. The optional unencoded fields are set \n    using the global MALZMQ configuration header.\n    - The MAL message body is directly set from the ZMQ frame (`data` field of `zframe`) without copy. \n    Consequently, the ZMQ frame can only be destroyed at the time of the destruction of MAL message. The\n     `body_owner` field of the message is affected with the MAL ZMQ frame.\n    - The built message is returned to the caller, the destruction of the MAL message is the responsibility\n    of the handler of this message.", 
            "title": "Message receiving"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-build-uri", 
            "text": "The URI format is:  malzmq:// hostname : port / id   The underlying transport protocol used by ZMQ is not specified in the URI. It is specified in the creation of MALZMQ context.  In some cases, the MALZMQ context could optimize communication using a more efficient transport protocol, for example:      - `ipc`: if both consumer and provider are on the same host.\n    - `inproc`: if both consumer and provider are in the same process. Be careful in this case to the \n    starting order as *inproc* does not ensure the temporal decoupling for ZMQ sockets.  This optimization is not currently implemented in the prototype.", 
            "title": "Virtual function to build URI"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-create-an-endpoint", 
            "text": "A MALZMQ endpoint is created and returned as an untyped pointer  void * .  Specific MALZMQ endpoint datas are:      - the MALZMQ context,\n    - the corresponding MAL endpoint,\n    - the listening inproc ZMQ DEALER socket used to receive forwarded messages from the zloop,\n    - an hashtable containing the ZMQ sockets open to the remote MALZMQ contexts.  During the initialization of the endpoint, the following actions are performed:      - creating a ZMQ DEALER socket,\n    - registering this socket identity with the endpoint URI,\n    - connection of this DEALER socket with the ROUTER socket handled by the zloop (ZLOOP_ENDPOINTS_SOCKET_URI)", 
            "title": "Virtual function to create an endpoint"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-send-a-message", 
            "text": "The message's MAL URI is converted into a ZMQ URI:      - MAL URI format: `malzmq:// hostname : port / id `\n    - ZMQ URI format: ` protocole zmq :// hostname : port `  A ZMQ DEALER socket connected to this URI is searched in the hashtable owned by the endpoint. If the socket is not\nfound then a new one is created and registered in the table (the key is the ZMQ URI).  The MAL message is encoded and transmitted in a single frame ZMQ.", 
            "title": "Virtual function to send a message"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-create-a-poller", 
            "text": "A MALZMQ poller is created and returned as an untyped pointer  void * .  Specific MALZMQ poller datas are:      - the MALZMQ context,\n    - the corresponding MAL poller,\n    - the ZMQ zpoller listening on sockets of endpoints,\n    - the list of endpoints associated to this poller.  During the initialization of the poller, the following actions are performed:      - creation of a ZMQ zpoller,\n    - creation ofn empty list of endpoints.", 
            "title": "Virtual function to create a poller"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-add-an-endpoint-to-a-poller", 
            "text": "This function adds to the poller the endpoint in parameter. The end-point is added to the list of\nendpoints, the corresponding socket is added to the zpoller.", 
            "title": "Virtual function to add an endpoint to a poller"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-remove-an-endpoint-to-a-poller", 
            "text": "This function removes from the poller the endpoint in parameter. The end-point is removed from the\nlist of poller, the corresponding socket is removed from the zpoller.", 
            "title": "Virtual function to remove an endpoint to a poller"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-wait-a-message-on-a-poller", 
            "text": "This function waits to receive a message on the associated zpoller.  If a message arrives before the timeout expiration the corresponding endpoint is searched in the\nlist of endpoints and is returned in the corresponding parameter. If there is no matching endpoint\nregistered an error is returned.", 
            "title": "Virtual function to wait a message on a poller"
        }, 
        {
            "location": "/mal_czmq/#virtual-function-to-delete-a-message", 
            "text": "This function checks if the  body_owner  message field MAL is set. In this case, it means that the\nMAL message was created (decoded) from a ZMQ frame ( zframe ) and must be destroyed ( zframe_destroy ).", 
            "title": "Virtual function to delete a message"
        }, 
        {
            "location": "/stub_generator/", 
            "text": "Stubs code generation\n\n\nGenerated code is produced for a dedicated mission which uses a set of service Areas.\n\n\nThe C statement 'calloc' (initializes allocated bytes with 0) is used to allocate the structures and pointers arrays. It guarantees that the destructor will not free memory through false pointers when the initialization has not completed properly.\n\n\nArea\n\n\nA new project of type 'zproject' is created for each Area. Il is named as the area name in lower case: \narea\n\n\nInclude file (.h)\n\n\nA file \narea\n.h\n is defined for each area.\n\n\nHeader\n\n\n#ifndef __\nAREA\n_H_INCLUDED__\n#define __\nAREA\n_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nDeclare the dependency on the MAL Area:\n\n\n#include \nmal.h\n\n\n\n\n\nFor each required Area:\n\n\n#include \nrequired area\n.h\n\n\n\n\n\nConstants\n\n\nDefinition of area specific constants:\n\n\n#define \nAREA\n_AREA_NUMBER \narea number\n\n#define \nAREA\n_AREA_VERSION \nversion\n\n\n\n\n\nFor each service:\n\n\n#define \nAREA\n_\nSERVICE\n_SERVICE_NUMBER \nservice number\n\n\n\n\n\nFor each service operation:\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER \noperation number\n\n\n\n\n\nFor each error raised by an operation:\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_\nERROR\n_ERROR_NUMBER \nerror number\n\n\n\n\n\nTypes\n\n\nFor each Enumeration type:\n\n\ntypedef enum {\n  \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_\nENUMERATED NAME\n,\n} \narea\n_[\nservice\n_]\nenumeration\n_t;\n\n\n\n\nFor each Composite type:\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ncomposite\n_t\n  \narea\n_[\nservice\n_]\ncomposite\n_t;\n\n\n\n\nFor each data type defined above (Enumeration, Composite):\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ntype\n_list_t\n  \narea\n_[\nservice\n_]\ntype\n_list_t;\n\n\n\n\nFor each data type, define the numerical identifier 'short form' (typed as 'long') according to the definition in section 5.2.3 of the MAL/SPP book:\n\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM \nshort form\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_LIST_SHORT_FORM \nshort form\n\n\n\n\n\nOperations\n\n\nFor each service operation, except when the IP is Publish/Subscribe, the following functions are defined:\n\n\n\n\na function sending a message to initiate the interaction (first step);\n\n\na function sending a message for each result step of the interaction (second and following steps).\n\n\n\n\nInteraction initiation (except Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nfirst stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri);\n\n\n\n\nInteraction result (except Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nresult stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message, mal_message_t *result_message,\n  bool is_error_message);\n\n\n\n\nFor each service operation when the IP is Publish/Subscribe, functions are defined for the following interaction steps: register, publishRegister, publish, deregister, publishDeregister.\n\n\nSubscription (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_register(\n  mal_ctx_t *mal_ctx, mal_endpoint_t *endpoint, mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nDeclaration of publish (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nPublish (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid);\n\n\n\n\nUnsubscription (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nStop of publish (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nEncoding functions\n\n\nFor each message of an interaction step, the following functions are defined:\n\n\n\n\nfor each element of a message body (identified by its index), and for each type in case of polymorphism (cf 9.4.1):\n\n\na function to get the size required to encode the data\n\n\na function to encode the data\n\n\n\n\n\n\nfor each element of a message body (identified by its index and its declared type):\n\n\na function to decode the data\n\n\n\n\n\n\n\n\nThe operations with IP Publish/Subscribe are handled in a special way. The three en/decoding functions are only generated for a single fictional interaction step, the update step, which matches the two steps publish and notify. The parameters types of those interaction steps are defined in the operation specification as a publishNotify message. Moreover the actual parameters types used in the functions, and in the en/decoding functions, are lists of the types declared in the specification.\n\n\nThe en/decoding functions related to the error messages follow the general schema with the following specificities:\n\n\n\n\nthe name of the functions does not include an index,\n\n\nthe name of the encoding functions always includes the type suffix \n_qftype\n,\n\n\nthe decoding function follows the rule of decoding with polymorphism of Element.\n\n\n\n\nComputing the encoding length\n\n\nIn case of polymorphism of Attribute:\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  mal_encoder_t *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  void *cursor);\n\n\n\n\nElse the type of the element is known (even in case of polymorphism):\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  mal_encoder_t *encoder, bool presence_flag,\n  \nqftype\n_t element, void *cursor);\n\n\n\n\n\n\nIf the element is a pointer Attribute, a Composite or a list:\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  mal_encoder_t *encoder, \nqftype\n_[list_]t *element,\n  void *cursor);\n\n\n\n\nIf the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification:\n\n\nint \nqfop\n_update_add_encoding_length[_\nindex\n][_\nqftype\n_list](\n  mal_encoder_t *encoder,\n    \nqftype\n_list_t *element,\n    void *cursor);\n\n\n\n\nEncoding\n\n\nIn case of polymorphism of Attribute:\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);\n\n\n\n\nElse the type of the element is known (even in case of polymorphism):\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag, \nqftype\n_t element);\n\n\n\n\n\n\nIf the element is a pointer Attribute, a Composite or a list:\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  void *cursor, mal_encoder_t *encoder,\n  \nqftype\n_[list_]t *element);\n\n\n\n\nIf the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification:\n\n\nint \nqfop\n_update_encode[_\nindex\n][_\nqftype\n_list](\n  void *cursor, mal_encoder_t *encoder,\n  \nqftype\n_list_t *element);\n\n\n\n\nDecoding\n\n\nIn case of polymorphism of Attribute:\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res, unsigned char *attribute_tag_res,\n  union mal_attribute_t *element_res);\n\n\n\n\nIn case of polymorphism of Element, including if the operation is PubSub (stage = update), and/or for an error message:\n\n\nint \nqfop\n_\nstage|error\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  mal_element_holder_t *element_holder);\n\n\n\n\nIf the element type is known:\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res, \nqftype\n_t *element_res);\n\n\n\n\n\n\nIf the element is a pointer Attribute, a Composite or a list:\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  \nqftype\n_[list_]t **element_res);\n\n\n\n\nIf the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification, except in case of polymorphism where the standard case of polymorphism of Element is reused.\n\n\nint \nqfop\n_update_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  \nqftype\n_list_t **element_res);\n\n\n\n\nEnd of file\n\n\nA test function:\n\n\nvoid \narea\n_test(bool verbose);\n\n\n\n\nFor each Composite structure:\n\n\n#include \narea\n_[\nservice\n_]\ncomposite\n.h\n\n\n\n\n\nFor each list of Composite:\n\n\n#include \narea\n_[\nservice\n_]\ncomposite\n_list.h\n\n\n\n\n\nFor each list of enumrated values:\n\n\n#include \narea\n_[\nservice\n_]\nenumeration\n_list.h\n\n\n\n\n\nend of file:\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nSource file (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nFor each enumeration:\n\n\nint \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_NUMERIC_VALUES[] = {\n  \nnumeric value\n,\n}\n\n\n\n\nInteraction initiation (except Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nfirst stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(init_message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_\nIP\n,\n    MAL_IP_STAGE_\nSTAGE\n);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_init_operation(\n    endpoint, init_message, provider_uri, true);\n  return rc;\n}\n\n\n\n\nInteraction result (except Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nresult stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_message_t *result_message,\n  bool is_error_message) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(result_message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_\nIP\n,\n    MAL_IP_STAGE_\nSTAGE\n);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_return_operation(\n    endpoint, init_message, result_message, is_error_message);\n  return rc;\n}\n\n\n\n\nSubscription (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_REGISTER);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nDeclaration of publish (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nPublish (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH);\n\n\n\n\nSet the \nTransaction Id\n:\n\n\n  mal_message_set_transaction_id(message, initial_publish_register_tid);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, false);\n  return rc;\n}\n\n\n\n\nUnsubscription (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_DEREGISTER);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nStop of publish (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nSet the fields related to the called operation:\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER);\n\n\n\n\nSend the message:\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nComputing the encoding length\n\n\nIn case of polymorphism of Attribute:\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  mal_encoder_t *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  void *cursor) {\n\n\n\n\nElse the type of the element is known (even in case of polymorphism):\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  mal_encoder_t *encoder, bool presence_flag,\n  \nqftype\n_t element, void *cursor) {\n\n\n\n\n\n\nIf the element is a pointer Attribute, a Composite or a list:\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  mal_encoder_t *encoder, \nqftype\n_[list_]t *element,\n  void *cursor) {\n```c\n\nInitialize the error code:\n\n```c\n  int rc = 0;\n\n\n\n\nTest the encoding format allowing for format specific encoding:\n\n\n  switch (encoder-\nencoding_format_code) {\n\n\n\n\nFor each available format:\n\n\n  case \nFORMAT\n_FORMAT_CODE: {\n\n\n\n\nCompute the encoding length of an optional field:\n  - For the encoding format \nmalbinary\n, cf section 11.1.1.\n\n\n    break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}\n\n\n\n\nEncoding\n\n\nIn case of polymorphism of Attribute:\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element) {\n\n\n\n\nElse the type of the element is known (even in case of polymorphism):\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag, \nqftype\n_t element) {\n\n\n\n\n\n\nIf the element is a pointer Attribute, a Composite or a list:\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  void *cursor, mal_encoder_t *encoder,\n  \nqftype\n_[list_]t *element) {\n  bool presence_flag = (element != NULL);\n\n\n\n\nInitialize the error code:\n\n\n  int rc = 0;\n\n\n\n\nTest the encoding format allowing for format specific encoding:\n\n\n  switch (encoder-\nencoding_format_code) {\n\n\n\n\nFor each available format:\n\n\n  case \nFORMAT\n_FORMAT_CODE: {\n\n\n\n\nEncode an optional field:\n\n\n\n\nFor the encoding format \nmalbinary\n, cf section 11.2.2.\n\n\n\n\n    break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}\n\n\n\n\nDecoding\n\n\nIn case of polymorphism of Attribute:\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res, unsigned char *attribute_tag_res,\n  union mal_attribute_t *element_res) {\n\n\n\n\nIn case of polymorphism of Element and/or for an error message:\n\n\nint \nqfop\n_\nstage|error\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  mal_element_holder_t *element_holder) {\n\n\n\n\nIf the element type is known:\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res, \nqftype\n_t *element_res) {\n\n\n\n\n\n\nIf the element is a pointer Attribute, a Composite or a list:\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  void *cursor, mal_decoder_t *decoder,\n  \nqftype\n_[list_]t **element_res) {\n\n\n\n\nInitialize the error code:\n\n\n  int rc = 0;\n\n\n\n\nTest the decoding format allowing for format specific decoding:\n\n\n  switch (decoder-\nencoding_format_code) {\n\n\n\n\nFor each available format:\n\n\n  case \nFORMAT\n_FORMAT_CODE: {\n      bool presence_flag;\n\n\n\n\nDecode an optional field:\n\n\n\n\nFor the encoding format \nmalbinary\n, cf section 11.3.1.\n\n\nData are decoded directly into the result structure or pointer.\n\n\n\n\nIn case of polymorphism of Attribute or if the element is a non pointer Attribute or an enumerated value:\n\n\n    (*presence_flag_res) = presence_flag;\n\n\n\n\nIn case of polymorphism of Element:\n\n\n    mal_element_holder_set_presence_flag(element_holder, presence_flag);\n\n\n\n\nEnd of decoding.\n\n\n    break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}\n\n\n\n\nComposite\n\n\nInclude file (.h)\n\n\n#ifndef __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_H_INCLUDED__\n#define __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nEmpty constructor:\n\n\narea\n_[\nservice\n_]\ncomposite\n_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_new(void);\n\n\n\n\nFor each encoding format:\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_add_encoding_length_\nformat\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, mal_encoder_t *encoder,\n    void *cursor);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_encode_\nformat\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, mal_encoder_t *encoder,\n    void *cursor);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_decode_\nformat\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, mal_decoder_t *decoder,\n    void *cursor);\n\n\n\n\nFor each field in the composite (including nherited fields):\n\n\nfield type\n \narea\n_[\nservice\n_]\ncomposite\n_get_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_set_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nfield type\n \nfield\n);\n\n\n\n\nIf the field is not a pointer (cannot store a NULL value):\n\n\nbool \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_is_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, bool is_present);\n\n\n\n\nIn case of polymorphism of Attribute:\n\n\nunsigned char \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_get_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, unsigned char attribute_tag);\n\n\n\n\nDestructor:\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_t **self_p);\n\n\n\n\nTest function:\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_test(bool verbose);\n\n\n\n\nEnd of file:\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nSource file (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nDefine the structure\n\n\nstruct _\narea\n_[\nservice\n_]\ncomposite\n_t {\n\n\n\n\nFor each field (including inherited fields):\n\n\n\n\n\n\nIn case of polymorphism of Attribute:\n\n\n\n\n\n\nIf the field is not mandatory (canBeNull = 'true'):\n\n\nc\nbool \nfield\n_is_present;\n\n\n\n\n\n\nDeclare the field:\n\n\nc\nunsigned char \nfield\n_attribute_tag;\nunion mal_attribute_t \nfield\n;\n\n\n\n\n\n\n\n\n\n\nIf the element is a non pointer Attribute or an enumerated value:\n\n\n\n\n\n\nIf the field is not mandatory (canBeNull = 'true'):\n\n\nc\nbool \nfield\n_is_present;\n\n\n\n\n\n\nDeclare the field:\n\n\nc\n\nfield type\n \\\nfield\n;\n\n\n\n\n\n\n\n\n\n\nElse:\n\n\nc\n\nfield type\n *\\\nfield\n;\n\n\n\n\n\n\nEnd the structure definition*:\n\n\n};\n\n\n\n\nConstructor\n\n\narea\n_[\nservice\n_]\ncomposite\n_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_new(void) {\n  \narea\n_[\nservice\n_]\ncomposite\n_t *self =\n      (\narea\n_[\nservice\n_]\ncomposite\n_t *) calloc(\n          1, sizeof(\narea\n_[\nservice\n_]\ncomposite\n_t));\n  if (!self)\n    return NULL;\n  return self;\n}\n\n\n\n\nGetters and setters\n\n\nFor each field (including inherited fields):\n\n\nfield type\n \narea\n_[\nservice\n_]\ncomposite\n_get_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self) {\n  return self-\nfield\n;\n}\n\n\n\n\nThe \nsetter\n function only changes the field value. It shall leave the presence flag unchanged.\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_set_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nfield type\n \nfield\n) {\n  self-\nfield\n = \nfield\n;\n}\n\n\n\n\nIf the field is not mandatory (canBeNull = 'true') and if the field is not a pointer:\n\n\nbool \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_is_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self) {\n  return self-\nfield\n_is_present;\n}\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, bool is_present) {\n  self-\nfield\n_is_present = is_present;\n}\n\n\n\n\nIn case of polymorphism of Attribute:\n\n\nunsigned char \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_get_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self) {\n  return self-\nfield\n_attribute_tag;\n}\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_attribute_tag(\n  \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n  unsigned char attribute_tag) {\n  self-\nfield\n_attribute_tag = attribute_tag;\n}\n\n\n\n\nComputing the encoding length (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_add_encoding_length_malbinary(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, mal_encoder_t *mal_encoder,\n    void *cursor) {\n  int rc = 0;\n\n\n\n\nFor each field (inherited fields first):\n\n\n\n\nIf the field is not mandatory, cf section 11.1.1.\n\n\nElse cf section 11.1.2.\n\n\n\n\nEnd of function:\n\n\n  return rc;\n}\n\n\n\n\nEncoding (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_encode_malbinary(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, mal_encoder_t *mal_encoder,\n    void *cursor) {\n\n\n\n\nIf there is at least one non mandatory field:\n\n\n  bool presence_flag;\n\n\n\n\nFor each field (inherited fields first):\n\n\n\n\nIf the field is not mandatory:\n\n\nIf the field is a non pointer Attribute or an enumerated value: \n    \nc\n    presence_flag = self-\nfield\n_is_present;\n\n\nElse: \n    \nc\n    presence_flag = (self-\nfield\n != NULL);\n\n\nCf section 11.2.1.\n\n\n\n\n\n\nElse cf section 11.2.2.\n\n\n\n\nEnd of encoding:\n\n\n  return rc;\n}\n\n\n\n\nDecoding (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_decode_malbinary(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, mal_decoder_t *mal_decoder,\n    void *cursor) {\n\n\n\n\nIf there is at least one non mandatory field:\n\n\n  bool presence_flag;\n\n\n\n\nFor each field (inherited fields first):\n\n\n\n\nIf the field is not mandatory, cf section 11.3.1.\n\n\nElse cf section 11.3.2.\n\n\n\n\nData are decoded directly into the result structure or pointer.\n\n\nIf the field is not mandatory and is typed as an abstract Attribute, a non pointer Attribute or an enumerated value:\n\n\n    self-\nfield\n_is_present = presence_flag;\n\n\n\n\nEnd of decoding:\n\n\n  return rc;\n}\n\n\n\n\nDestructor\n\n\nFrees the composite structure and the structures embedded in the composite fields (composites, lists, Strings, Blobs).\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_t **self_p) {\n\n\n\n\nFor each field, including inherited fields:\n\n\n\n\nIn case of polymorphism of Attribute:\n\n\nif the field is not mandatory (canBeNull = 'true'):\n    \nc\n    if ((*self_p)-\nfield\n_is_present)\n\n\nfree the field:\n    \nc\n    mal_attribute_destroy(\n(*self_p)-\nfield\n,\n      (*self_p)-\nfield\n_attribute_tag);\n\n\n\n\n\n\nIf the field is a pointer Attribute:\n    \nc\n    if ((*self_p)-\nfield\n!= NULL)\n      mal_\nattribute\n_destroy(\n(*self_p)-\nfield\n);\n\n\nIf the field is a Composite:\n    \nc\n    if ((*self_p)-\nfield\n!= NULL)\n      \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n(*self_p)-\nfield\n);\n\n\nIf the field is a list:\n    \nc\n    if ((*self_p)-\nfield\n!= NULL)\n      \narea\n_[\nservice\n_]\ntype\n_list_destroy(\n(*self_p)-\nfield\n);\n\n\n\n\nFree the memory and reset the pointer:\n\n\n  free(*self_p);\n  (*self_p) = NULL;\n}\n\n\n\n\nLists of Composite\n\n\nInclude file (.h)\n\n\n#ifndef __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_LIST_H_INCLUDED__\n#define __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nConstructor:\n\n\narea\n_[\nservice\n_]\ncomposite\n_list_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_list_new(unsigned int element_count);\n\n\n\n\nGetters:\n\n\nunsigned int \narea\n_[\nservice\n_]\ncomposite\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\n\narea\n_[\nservice\n_]\ncomposite\n_t **mal_list_get_content(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\n\n\n\nFor each encoding format:\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_add_encoding_length_\nformat\n(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_encode_\nformat\n(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_decode_\nformat\n(\n  \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n  mal_decoder_t *decoder, void *cursor);\n\n\n\n\nDestructor:\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t **self_p);\n\n\n\n\nTest function:\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_test(bool verbose);\n\n\n\n\nEnd of file :\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nSource file (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nConstructor\n\n\nStructure definition:\n\n\nstruct _\narea\n_[\nservice\n_]\ncomposite\n_list_t {\n  unsigned int element_count;\n  \narea\n_[\nservice\n_]\ncomposite\n_t **content;\n};\n\n\n\n\nConstructor:\n\n\narea\n_[\nservice\n_]\ncomposite\n_list_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_list_new(unsigned int element_count) {\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self =\n    (\narea\n_[\nservice\n_]\ncomposite\n_list_t *) calloc(1,\n      sizeof(\narea\n_[\nservice\n_]\ncomposite\n_list_t));\n  if (!self) return NULL;\n  self-\nelement_count = element_count;\n  self-\ncontent = (\narea\n_[\nservice\n_]\ncomposite\n_t **) calloc(\n      element_count, sizeof(\narea\n_[\nservice\n_]\ncomposite\n_t *));\n  return self;\n}\n\n\n\n\nGetters\n\n\nunsigned int \narea\n_[\nservice\n_]\ncomposite\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self) {\n  return self-\nelement_count;\n}\n\n\narea\n_[\nservice\n_]\ncomposite\n_t **\n  \narea\n_[\nservice\n_]\ncomposite\n_list_get_content(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t *self) {\n  return self-\ncontent;\n}\n\n\n\n\nComputing the encoding length (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_add_encoding_length_malbinary(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n\n\n\n\nEncoding the list size:\n\n\n  mal_encoder_add_list_size_encoding_length(encoder, list_size, cursor);\n\n\n\n\nEncoding the list elements:\n\n\n  \narea\n_[\nservice\n_]\ncomposite\n_t **content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    \narea\n_[\nservice\n_]\ncomposite\n_t *element = content[i];\n\n\n\n\nAll the elements of the list may be null. A presence flag is encoded for each of them:\n\n\n    bool presence_flag = (element != NULL);\n    mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);\n\n\n\n\nCompute the encoding length of a non mandatory composite field: cf section 11.1.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nEncoding (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_encode_malbinary(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n  rc = mal_encoder_encode_list_size(encoder, cursor, list_size);\n  if (rc \n 0) return rc;\n  \narea\n_[\nservice\n_]\ncomposite\n_t **content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    \narea\n_[\nservice\n_]\ncomposite\n_t *element = content[i];\n\n\n\n\nEncoding a non mandatory Composite : cf section 11.2.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nDecoding (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_decode_malbinary(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  mal_decoder_t *decoder, void *cursor) {\n  int rc = 0;\n  int rc = mal_decoder_decode_list_size(decoder, cursor, \nself-\nelement_count);\n  if (rc \n 0) return rc;\n  if (self-\nelement_count == 0) {\n    self-\ncontent = NULL;\n    return 0;\n  }\n  self-\ncontent = (\narea\n_[\nservice\n_]\ncomposite\n_t **) calloc(\n      sizeof(\narea\n_[\nservice\n_]\ncomposite\n_t *) * self-\nelement_count);\n  if (self-\ncontent == NULL)\n    return -1;\n  for (int i = 0; i \n self-\nelement_count; i++) {\n\n\n\n\nDecoding a non mandatory Composite: cf section 11.3.1.\n\n\nData are decoded directly into the result structure or pointer (i.e. \nself-\ncontent[i]\n).\n\n\n  }\n  return rc;\n}\n\n\n\n\nDestructor\n\n\nFrees the list, its content, and the list elements.\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t **self_p) {\n  if ((*self_p)-\nelement_count \n 0) {\n    for (int i = 0; i \n (*self_p)-\nelement_count; i++) {\n      if ((*self_p)-\ncontent[i] != NULL)\n        \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n(*self_p)-\ncontent[i]);\n    }\n    free((*self_p)-\ncontent);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}\n\n\n\n\nLists of enumerated values\n\n\nInclude file (.h)\n\n\n#ifndef __\nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_LIST_H_INCLUDED__\n#define __\nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nConstructor:\n\n\narea\n_[\nservice\n_]\nenumeration\n_list_t\n  *\narea\n_[\nservice\n_]\nenumeration\n_list_new(\n    unsigned int element_count);\n\n\n\n\nGetters:\n\n\nunsigned int \narea\n_[\nservice\n_]\nenumeration\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self);\n\nbool *\narea\n_[\nservice\n_]\nenumeration\n_list_get_presence_flags(\n    \narea\n_[\nservice\n_]\nenumeration\n_list_t *self);\n\n\narea\n_[\nservice\n_]\nenumeration\n_t *mal_list_get_content(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self);\n\n\n\n\nFor each encoding format:\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_add_encoding_length_\nformat\n(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_encode_\nformat\n(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_decode_\nformat\n(\n  \narea\n_[\nservice\n_]\nenumeration\n_t *self,\n  \nformat\n_decoder_t *decoder, void *cursor);\n\n\n\n\nDestructor:\n\n\nvoid \narea\n_[\nservice\n_]\nenumeration\n_list_destroy(\n    \narea\n_[\nservice\n_]\nenumeration\n_list_t **self_p);\nFonction de test :\nvoid \narea\n_[\nservice\n_]\nenumeration\n_list_test(bool verbose);\n\n\n\n\nEnd of file:\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nSource file (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nConstructor\n\n\nDeclare the structure:\n\n\nstruct _\narea\n_[\nservice\n_]\nenumeration\n_list_t {\n  unsigned int element_count;\n  bool *presence_flags;\n  \narea\n_[\nservice\n_]\nenumeration\n_t *content;\n};\n\n\n\n\nConstructor:\n\n\narea\n_[\nservice\n_]\nenumeration\n_list_t\n  *\narea\n_[\nservice\n_]\nenumeration\n_list_new(\n    unsigned int element_count) {\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self =\n    (\narea\n_[\nservice\n_]\nenumeration\n_list_t *) calloc(1,\n      sizeof(\narea\n_[\nservice\n_]\nenumeration\n_list_t));\n  if (!self) return NULL;\n  self-\nelement_count = element_count;\n  if (element_count == 0) return self;\n  self-\npresence_flags = (bool *) calloc(element_count, sizeof(bool));\n  if (!self-\npresence_flags) {\n    free(self);\n    return NULL;\n  }\n  self-\ncontent = (\narea\n_[\nservice\n_]\nenumeration\n_t *) calloc(\n      element_count, sizeof(\narea\n_[\nservice\n_]\nenumeration\n_t));\n  if (!self-\ncontent) {\n    free(self-\npresence_flags);\n    free(self);\n    return NULL;\n  }\n  return self;\n}\n\n\n\n\nGetters\n\n\nunsigned int \narea\n_[\nservice\n_]\nenumeration\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self) {\n  return self-\nelement_count;\n}\n\nbool *\narea\n_[\nservice\n_]\nenumeration\n_list_get_presence_flags(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self) {\n  return self-\npresence_flags;\n}\n\n\narea\n_[\nservice\n_]\nenumeration\n_t\n  *\narea\n_[\nservice\n_]\nenumeration\n_list_get_content(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self) {\n  return self-\ncontent;\n}\n\n\n\n\nComputing the encoding length (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_add_encoding_length_malbinary(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n\n\n\n\nEncoding the list size:\n\n\n  mal_encoder_add_list_size_encoding_length(encoder, list_size, cursor);\n\n\n\n\nEncoding the list elements:\n\n\n  \narea\n_[\nservice\n_]\ncomposite\n_t **content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    \narea\n_[\nservice\n_]\ncomposite\n_t *element = content[i];\n\n\n\n\nAll the elements of the list may be null. A presence flag is encoded for each of them:\n\n\n    bool presence_flag = self-\npresence_flags[i];\n    mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);\n\n\n\n\nCompute the encoding length of a non mandatory enumeration field: cf section 11.1.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nEncoding (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_encode_malbinary(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n  rc = mal_encoder_encode_list_size(encoder, cursor, list_size);\n  if (rc \n 0) return rc;\n  for (int i = 0; i \n list_size; i++) {\n    bool presence_flag = self-\npresence_flags[i];\n    \narea\n_[\nservice\n_]\nenumeration\n_t element = self-\ncontent[i];\n\n\n\n\nEncoding a non mandatory enumerated value: cf section 11.2.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nDecoding (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_decode_malbinary(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  mal_decoder_t *decoder, void *cursor) {\n  int rc = 0;\n  rc = mal_decoder_decode_list_size(decoder, cursor, \nself-\nelement_count);\n  if (rc \n 0) return rc;\n  if (self-\nelement_count == 0) {\n    self-\npresence_flags = NULL;\n    self-\ncontent = NULL;\n    return 0;\n  }\n  self-\npresence_flags = (bool *) calloc(self-\nelement_count, sizeof(bool));\n  if (self-\npresence_flags == NULL)\n    return -1;\n  self-\ncontent = (\narea\n_[\nservice\n_]\nenumeration\n_t *) calloc(self-\nelement_count, sizeof(\narea\n_[\nservice\n_]\nenumeration\n_t));\n  if (self-\ncontent == NULL) {\n    free(self-\npresence_flags);\n    return -1;\n  }\n  for (int i = 0; i \n self-\nelement_count; i++) {\n\n\n\n\nDecoding a non mandatory enumerated value: cf section 11.3.1.\n\n\nData are decoded directly into the result structure or pointer (i.e. \nself-\npresence_flags[i]\n and \nself-\ncontent[i]\n).\n\n\n  }\n  return rc;\n}\n\n\n\n\nDestructor\n\n\nFree the list and its content.\n\n\nvoid \narea\n_[\nservice\n_]\nenum\n_list_destroy(\n    \narea\n_[\nservice\n_]\nenum\n_list_t **self_p) {\n  if ((*self_p)-\nelement_count \n 0) {\n    free((*self_p)-\npresence_flags);\n    free((*self_p)-\ncontent);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Stubs generator"
        }, 
        {
            "location": "/stub_generator/#stubs-code-generation", 
            "text": "Generated code is produced for a dedicated mission which uses a set of service Areas.  The C statement 'calloc' (initializes allocated bytes with 0) is used to allocate the structures and pointers arrays. It guarantees that the destructor will not free memory through false pointers when the initialization has not completed properly.", 
            "title": "Stubs code generation"
        }, 
        {
            "location": "/stub_generator/#area", 
            "text": "A new project of type 'zproject' is created for each Area. Il is named as the area name in lower case:  area", 
            "title": "Area"
        }, 
        {
            "location": "/stub_generator/#include-file-h", 
            "text": "A file  area .h  is defined for each area.", 
            "title": "Include file (.h)"
        }, 
        {
            "location": "/stub_generator/#header", 
            "text": "#ifndef __ AREA _H_INCLUDED__\n#define __ AREA _H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif  Declare the dependency on the MAL Area:  #include  mal.h   For each required Area:  #include  required area .h", 
            "title": "Header"
        }, 
        {
            "location": "/stub_generator/#constants", 
            "text": "Definition of area specific constants:  #define  AREA _AREA_NUMBER  area number \n#define  AREA _AREA_VERSION  version   For each service:  #define  AREA _ SERVICE _SERVICE_NUMBER  service number   For each service operation:  #define  AREA _ SERVICE _ OPERATION _OPERATION_NUMBER  operation number   For each error raised by an operation:  #define  AREA _ SERVICE _ OPERATION _ ERROR _ERROR_NUMBER  error number", 
            "title": "Constants"
        }, 
        {
            "location": "/stub_generator/#types", 
            "text": "For each Enumeration type:  typedef enum {\n   AREA _[ SERVICE _] ENUMERATION _ ENUMERATED NAME ,\n}  area _[ service _] enumeration _t;  For each Composite type:  typedef struct _ area _[ service _] composite _t\n   area _[ service _] composite _t;  For each data type defined above (Enumeration, Composite):  typedef struct _ area _[ service _] type _list_t\n   area _[ service _] type _list_t;  For each data type, define the numerical identifier 'short form' (typed as 'long') according to the definition in section 5.2.3 of the MAL/SPP book:  #define  AREA _[ SERVICE _] TYPE _SHORT_FORM  short form \n#define  AREA _[ SERVICE _] TYPE _LIST_SHORT_FORM  short form", 
            "title": "Types"
        }, 
        {
            "location": "/stub_generator/#operations", 
            "text": "For each service operation, except when the IP is Publish/Subscribe, the following functions are defined:   a function sending a message to initiate the interaction (first step);  a function sending a message for each result step of the interaction (second and following steps).   Interaction initiation (except Publish/Subscribe)  int  area _ service _ operation _ first stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri);  Interaction result (except Publish/Subscribe)  int  area _ service _ operation _ result stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message, mal_message_t *result_message,\n  bool is_error_message);  For each service operation when the IP is Publish/Subscribe, functions are defined for the following interaction steps: register, publishRegister, publish, deregister, publishDeregister.  Subscription (Publish/Subscribe)  int  area _ service _ operation _register(\n  mal_ctx_t *mal_ctx, mal_endpoint_t *endpoint, mal_message_t *message,\n  mal_uri_t *broker_uri);  Declaration of publish (Publish/Subscribe)  int  area _ service _ operation _publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);  Publish (Publish/Subscribe)  int  area _ service _ operation _publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid);  Unsubscription (Publish/Subscribe)  int  area _ service _ operation _deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);  Stop of publish (Publish/Subscribe)  int  area _ service _ operation _publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);", 
            "title": "Operations"
        }, 
        {
            "location": "/stub_generator/#encoding-functions", 
            "text": "For each message of an interaction step, the following functions are defined:   for each element of a message body (identified by its index), and for each type in case of polymorphism (cf 9.4.1):  a function to get the size required to encode the data  a function to encode the data    for each element of a message body (identified by its index and its declared type):  a function to decode the data     The operations with IP Publish/Subscribe are handled in a special way. The three en/decoding functions are only generated for a single fictional interaction step, the update step, which matches the two steps publish and notify. The parameters types of those interaction steps are defined in the operation specification as a publishNotify message. Moreover the actual parameters types used in the functions, and in the en/decoding functions, are lists of the types declared in the specification.  The en/decoding functions related to the error messages follow the general schema with the following specificities:   the name of the functions does not include an index,  the name of the encoding functions always includes the type suffix  _qftype ,  the decoding function follows the rule of decoding with polymorphism of Element.", 
            "title": "Encoding functions"
        }, 
        {
            "location": "/stub_generator/#computing-the-encoding-length", 
            "text": "In case of polymorphism of Attribute:  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  mal_encoder_t *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  void *cursor);  Else the type of the element is known (even in case of polymorphism):   If the element is a non pointer Attribute or an enumerated value:   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  mal_encoder_t *encoder, bool presence_flag,\n   qftype _t element, void *cursor);   If the element is a pointer Attribute, a Composite or a list:   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  mal_encoder_t *encoder,  qftype _[list_]t *element,\n  void *cursor);  If the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification:  int  qfop _update_add_encoding_length[_ index ][_ qftype _list](\n  mal_encoder_t *encoder,\n     qftype _list_t *element,\n    void *cursor);", 
            "title": "Computing the encoding length"
        }, 
        {
            "location": "/stub_generator/#encoding", 
            "text": "In case of polymorphism of Attribute:  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);  Else the type of the element is known (even in case of polymorphism):   If the element is a non pointer Attribute or an enumerated value:   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag,  qftype _t element);   If the element is a pointer Attribute, a Composite or a list:   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  void *cursor, mal_encoder_t *encoder,\n   qftype _[list_]t *element);  If the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification:  int  qfop _update_encode[_ index ][_ qftype _list](\n  void *cursor, mal_encoder_t *encoder,\n   qftype _list_t *element);", 
            "title": "Encoding"
        }, 
        {
            "location": "/stub_generator/#decoding", 
            "text": "In case of polymorphism of Attribute:  int  qfop _ stage _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res, unsigned char *attribute_tag_res,\n  union mal_attribute_t *element_res);  In case of polymorphism of Element, including if the operation is PubSub (stage = update), and/or for an error message:  int  qfop _ stage|error _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n  mal_element_holder_t *element_holder);  If the element type is known:   If the element is a non pointer Attribute or an enumerated value:   int  qfop _ stage _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res,  qftype _t *element_res);   If the element is a pointer Attribute, a Composite or a list:   int  qfop _ stage _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n   qftype _[list_]t **element_res);  If the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification, except in case of polymorphism where the standard case of polymorphism of Element is reused.  int  qfop _update_decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n   qftype _list_t **element_res);", 
            "title": "Decoding"
        }, 
        {
            "location": "/stub_generator/#end-of-file", 
            "text": "A test function:  void  area _test(bool verbose);  For each Composite structure:  #include  area _[ service _] composite .h   For each list of Composite:  #include  area _[ service _] composite _list.h   For each list of enumrated values:  #include  area _[ service _] enumeration _list.h   end of file:  #ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "End of file"
        }, 
        {
            "location": "/stub_generator/#source-file-c", 
            "text": "#include  area .h   For each enumeration:  int  AREA _[ SERVICE _] ENUMERATION _NUMERIC_VALUES[] = {\n   numeric value ,\n}", 
            "title": "Source file (.c)"
        }, 
        {
            "location": "/stub_generator/#interaction-initiation-except-publishsubscribe", 
            "text": "int  area _ service _ operation _ first stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(init_message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_ IP ,\n    MAL_IP_STAGE_ STAGE );  Send the message:    rc = mal_endpoint_init_operation(\n    endpoint, init_message, provider_uri, true);\n  return rc;\n}", 
            "title": "Interaction initiation (except Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#interaction-result-except-publishsubscribe", 
            "text": "int  area _ service _ operation _ result stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_message_t *result_message,\n  bool is_error_message) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(result_message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_ IP ,\n    MAL_IP_STAGE_ STAGE );  Send the message:    rc = mal_endpoint_return_operation(\n    endpoint, init_message, result_message, is_error_message);\n  return rc;\n}", 
            "title": "Interaction result (except Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#subscription-publishsubscribe", 
            "text": "int  area _ service _ operation _register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_REGISTER);  Send the message:    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "Subscription (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#declaration-of-publish-publishsubscribe", 
            "text": "int  area _ service _ operation _publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER);  Send the message:    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "Declaration of publish (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#publish-publishsubscribe", 
            "text": "int  area _ service _ operation _publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH);  Set the  Transaction Id :    mal_message_set_transaction_id(message, initial_publish_register_tid);  Send the message:    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, false);\n  return rc;\n}", 
            "title": "Publish (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#unsubscription-publishsubscribe", 
            "text": "int  area _ service _ operation _deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_DEREGISTER);  Send the message:    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "Unsubscription (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#stop-of-publish-publishsubscribe", 
            "text": "int  area _ service _ operation _publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;  Set the fields related to the called operation:    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER);  Send the message:    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "Stop of publish (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#computing-the-encoding-length_1", 
            "text": "In case of polymorphism of Attribute:  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  mal_encoder_t *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  void *cursor) {  Else the type of the element is known (even in case of polymorphism):   If the element is a non pointer Attribute or an enumerated value:   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  mal_encoder_t *encoder, bool presence_flag,\n   qftype _t element, void *cursor) {   If the element is a pointer Attribute, a Composite or a list:   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  mal_encoder_t *encoder,  qftype _[list_]t *element,\n  void *cursor) {\n```c\n\nInitialize the error code:\n\n```c\n  int rc = 0;  Test the encoding format allowing for format specific encoding:    switch (encoder- encoding_format_code) {  For each available format:    case  FORMAT _FORMAT_CODE: {  Compute the encoding length of an optional field:\n  - For the encoding format  malbinary , cf section 11.1.1.      break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}", 
            "title": "Computing the encoding length"
        }, 
        {
            "location": "/stub_generator/#encoding_1", 
            "text": "In case of polymorphism of Attribute:  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element) {  Else the type of the element is known (even in case of polymorphism):   If the element is a non pointer Attribute or an enumerated value:   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  void *cursor, mal_encoder_t *encoder,\n  bool presence_flag,  qftype _t element) {   If the element is a pointer Attribute, a Composite or a list:   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  void *cursor, mal_encoder_t *encoder,\n   qftype _[list_]t *element) {\n  bool presence_flag = (element != NULL);  Initialize the error code:    int rc = 0;  Test the encoding format allowing for format specific encoding:    switch (encoder- encoding_format_code) {  For each available format:    case  FORMAT _FORMAT_CODE: {  Encode an optional field:   For the encoding format  malbinary , cf section 11.2.2.       break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}", 
            "title": "Encoding"
        }, 
        {
            "location": "/stub_generator/#decoding_1", 
            "text": "In case of polymorphism of Attribute:  int  qfop _ stage _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res, unsigned char *attribute_tag_res,\n  union mal_attribute_t *element_res) {  In case of polymorphism of Element and/or for an error message:  int  qfop _ stage|error _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n  mal_element_holder_t *element_holder) {  If the element type is known:   If the element is a non pointer Attribute or an enumerated value:   int  qfop _ stage _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n  bool *presence_flag_res,  qftype _t *element_res) {   If the element is a pointer Attribute, a Composite or a list:   int  qfop _ stage _decode[_ index ](\n  void *cursor, mal_decoder_t *decoder,\n   qftype _[list_]t **element_res) {  Initialize the error code:    int rc = 0;  Test the decoding format allowing for format specific decoding:    switch (decoder- encoding_format_code) {  For each available format:    case  FORMAT _FORMAT_CODE: {\n      bool presence_flag;  Decode an optional field:   For the encoding format  malbinary , cf section 11.3.1.  Data are decoded directly into the result structure or pointer.   In case of polymorphism of Attribute or if the element is a non pointer Attribute or an enumerated value:      (*presence_flag_res) = presence_flag;  In case of polymorphism of Element:      mal_element_holder_set_presence_flag(element_holder, presence_flag);  End of decoding.      break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}", 
            "title": "Decoding"
        }, 
        {
            "location": "/stub_generator/#composite", 
            "text": "", 
            "title": "Composite"
        }, 
        {
            "location": "/stub_generator/#include-file-h_1", 
            "text": "#ifndef __ AREA _[ SERVICE _] COMPOSITE _H_INCLUDED__\n#define __ AREA _[ SERVICE _] COMPOSITE _H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif  Empty constructor:  area _[ service _] composite _t\n  * area _[ service _] composite _new(void);  For each encoding format:  int  area _[ service _] composite _add_encoding_length_ format (\n     area _[ service _] composite _t *self, mal_encoder_t *encoder,\n    void *cursor);\n\nint  area _[ service _] composite _encode_ format (\n     area _[ service _] composite _t *self, mal_encoder_t *encoder,\n    void *cursor);\n\nint  area _[ service _] composite _decode_ format (\n     area _[ service _] composite _t *self, mal_decoder_t *decoder,\n    void *cursor);  For each field in the composite (including nherited fields):  field type   area _[ service _] composite _get_ field (\n     area _[ service _] composite _t *self);\n\nvoid  area _[ service _] composite _set_ field (\n     area _[ service _] composite _t *self,  field type   field );  If the field is not a pointer (cannot store a NULL value):  bool  area _[ service _] composite _ field _is_present(\n     area _[ service _] composite _t *self);\n\nvoid  area _[ service _] composite _ field _set_present(\n     area _[ service _] composite _t *self, bool is_present);  In case of polymorphism of Attribute:  unsigned char  area _[ service _] composite _ field _get_attribute_tag(\n     area _[ service _] composite _t *self);\n\nvoid  area _[ service _] composite _ field _set_attribute_tag(\n     area _[ service _] composite _t *self, unsigned char attribute_tag);  Destructor:  void  area _[ service _] composite _destroy(\n     area _[ service _] composite _t **self_p);  Test function:  void  area _[ service _] composite _test(bool verbose);  End of file:  #ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "Include file (.h)"
        }, 
        {
            "location": "/stub_generator/#source-file-c_1", 
            "text": "#include  area .h", 
            "title": "Source file (.c)"
        }, 
        {
            "location": "/stub_generator/#define-the-structure", 
            "text": "struct _ area _[ service _] composite _t {  For each field (including inherited fields):    In case of polymorphism of Attribute:    If the field is not mandatory (canBeNull = 'true'):  c\nbool  field _is_present;    Declare the field:  c\nunsigned char  field _attribute_tag;\nunion mal_attribute_t  field ;      If the element is a non pointer Attribute or an enumerated value:    If the field is not mandatory (canBeNull = 'true'):  c\nbool  field _is_present;    Declare the field:  c field type  \\ field ;      Else:  c field type  *\\ field ;    End the structure definition*:  };", 
            "title": "Define the structure"
        }, 
        {
            "location": "/stub_generator/#constructor", 
            "text": "area _[ service _] composite _t\n  * area _[ service _] composite _new(void) {\n   area _[ service _] composite _t *self =\n      ( area _[ service _] composite _t *) calloc(\n          1, sizeof( area _[ service _] composite _t));\n  if (!self)\n    return NULL;\n  return self;\n}", 
            "title": "Constructor"
        }, 
        {
            "location": "/stub_generator/#getters-and-setters", 
            "text": "For each field (including inherited fields):  field type   area _[ service _] composite _get_ field (\n     area _[ service _] composite _t *self) {\n  return self- field ;\n}  The  setter  function only changes the field value. It shall leave the presence flag unchanged.  void  area _[ service _] composite _set_ field (\n     area _[ service _] composite _t *self,  field type   field ) {\n  self- field  =  field ;\n}  If the field is not mandatory (canBeNull = 'true') and if the field is not a pointer:  bool  area _[ service _] composite _ field _is_present(\n     area _[ service _] composite _t *self) {\n  return self- field _is_present;\n}\n\nvoid  area _[ service _] composite _ field _set_present(\n     area _[ service _] composite _t *self, bool is_present) {\n  self- field _is_present = is_present;\n}  In case of polymorphism of Attribute:  unsigned char  area _[ service _] composite _ field _get_attribute_tag(\n     area _[ service _] composite _t *self) {\n  return self- field _attribute_tag;\n}\n\nvoid  area _[ service _] composite _ field _set_attribute_tag(\n   area _[ service _] composite _t *self,\n  unsigned char attribute_tag) {\n  self- field _attribute_tag = attribute_tag;\n}", 
            "title": "Getters and setters"
        }, 
        {
            "location": "/stub_generator/#computing-the-encoding-length-malbinary", 
            "text": "int  area _[ service _] composite _add_encoding_length_malbinary(\n     area _[ service _] composite _t *self, mal_encoder_t *mal_encoder,\n    void *cursor) {\n  int rc = 0;  For each field (inherited fields first):   If the field is not mandatory, cf section 11.1.1.  Else cf section 11.1.2.   End of function:    return rc;\n}", 
            "title": "Computing the encoding length (malbinary)"
        }, 
        {
            "location": "/stub_generator/#encoding-malbinary", 
            "text": "int  area _[ service _] composite _encode_malbinary(\n     area _[ service _] composite _t *self, mal_encoder_t *mal_encoder,\n    void *cursor) {  If there is at least one non mandatory field:    bool presence_flag;  For each field (inherited fields first):   If the field is not mandatory:  If the field is a non pointer Attribute or an enumerated value: \n     c\n    presence_flag = self- field _is_present;  Else: \n     c\n    presence_flag = (self- field  != NULL);  Cf section 11.2.1.    Else cf section 11.2.2.   End of encoding:    return rc;\n}", 
            "title": "Encoding (malbinary)"
        }, 
        {
            "location": "/stub_generator/#decoding-malbinary", 
            "text": "int  area _[ service _] composite _decode_malbinary(\n     area _[ service _] composite _t *self, mal_decoder_t *mal_decoder,\n    void *cursor) {  If there is at least one non mandatory field:    bool presence_flag;  For each field (inherited fields first):   If the field is not mandatory, cf section 11.3.1.  Else cf section 11.3.2.   Data are decoded directly into the result structure or pointer.  If the field is not mandatory and is typed as an abstract Attribute, a non pointer Attribute or an enumerated value:      self- field _is_present = presence_flag;  End of decoding:    return rc;\n}", 
            "title": "Decoding (malbinary)"
        }, 
        {
            "location": "/stub_generator/#destructor", 
            "text": "Frees the composite structure and the structures embedded in the composite fields (composites, lists, Strings, Blobs).  void  area _[ service _] composite _destroy(\n     area _[ service _] composite _t **self_p) {  For each field, including inherited fields:   In case of polymorphism of Attribute:  if the field is not mandatory (canBeNull = 'true'):\n     c\n    if ((*self_p)- field _is_present)  free the field:\n     c\n    mal_attribute_destroy( (*self_p)- field ,\n      (*self_p)- field _attribute_tag);    If the field is a pointer Attribute:\n     c\n    if ((*self_p)- field != NULL)\n      mal_ attribute _destroy( (*self_p)- field );  If the field is a Composite:\n     c\n    if ((*self_p)- field != NULL)\n       area _[ service _] composite _destroy( (*self_p)- field );  If the field is a list:\n     c\n    if ((*self_p)- field != NULL)\n       area _[ service _] type _list_destroy( (*self_p)- field );   Free the memory and reset the pointer:    free(*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Destructor"
        }, 
        {
            "location": "/stub_generator/#lists-of-composite", 
            "text": "", 
            "title": "Lists of Composite"
        }, 
        {
            "location": "/stub_generator/#include-file-h_2", 
            "text": "#ifndef __ AREA _[ SERVICE _] COMPOSITE _LIST_H_INCLUDED__\n#define __ AREA _[ SERVICE _] COMPOSITE _LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif", 
            "title": "Include file (.h)"
        }, 
        {
            "location": "/stub_generator/#constructor_1", 
            "text": "area _[ service _] composite _list_t\n  * area _[ service _] composite _list_new(unsigned int element_count);", 
            "title": "Constructor:"
        }, 
        {
            "location": "/stub_generator/#getters", 
            "text": "unsigned int  area _[ service _] composite _list_get_element_count(\n   area _[ service _] composite _list_t *self); area _[ service _] composite _t **mal_list_get_content(\n   area _[ service _] composite _list_t *self);", 
            "title": "Getters:"
        }, 
        {
            "location": "/stub_generator/#for-each-encoding-format", 
            "text": "int  area _[ service _] composite _list_add_encoding_length_ format (\n   area _[ service _] composite _list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint  area _[ service _] composite _list_encode_ format (\n   area _[ service _] composite _list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint  area _[ service _] composite _list_decode_ format (\n   area _[ service _] composite _t *self,\n  mal_decoder_t *decoder, void *cursor);", 
            "title": "For each encoding format:"
        }, 
        {
            "location": "/stub_generator/#destructor_1", 
            "text": "void  area _[ service _] composite _list_destroy(\n     area _[ service _] composite _list_t **self_p);", 
            "title": "Destructor:"
        }, 
        {
            "location": "/stub_generator/#test-function", 
            "text": "void  area _[ service _] composite _list_test(bool verbose);", 
            "title": "Test function:"
        }, 
        {
            "location": "/stub_generator/#end-of-file_1", 
            "text": "#ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "End of file :"
        }, 
        {
            "location": "/stub_generator/#source-file-c_2", 
            "text": "#include  area .h", 
            "title": "Source file (.c)"
        }, 
        {
            "location": "/stub_generator/#constructor_2", 
            "text": "Structure definition:  struct _ area _[ service _] composite _list_t {\n  unsigned int element_count;\n   area _[ service _] composite _t **content;\n};  Constructor:  area _[ service _] composite _list_t\n  * area _[ service _] composite _list_new(unsigned int element_count) {\n   area _[ service _] composite _list_t *self =\n    ( area _[ service _] composite _list_t *) calloc(1,\n      sizeof( area _[ service _] composite _list_t));\n  if (!self) return NULL;\n  self- element_count = element_count;\n  self- content = ( area _[ service _] composite _t **) calloc(\n      element_count, sizeof( area _[ service _] composite _t *));\n  return self;\n}", 
            "title": "Constructor"
        }, 
        {
            "location": "/stub_generator/#getters_1", 
            "text": "unsigned int  area _[ service _] composite _list_get_element_count(\n   area _[ service _] composite _list_t *self) {\n  return self- element_count;\n} area _[ service _] composite _t **\n   area _[ service _] composite _list_get_content(\n     area _[ service _] composite _list_t *self) {\n  return self- content;\n}", 
            "title": "Getters"
        }, 
        {
            "location": "/stub_generator/#computing-the-encoding-length-malbinary_1", 
            "text": "int  area _[ service _] composite _list_add_encoding_length_malbinary(\n   area _[ service _] composite _list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;  Encoding the list size:    mal_encoder_add_list_size_encoding_length(encoder, list_size, cursor);  Encoding the list elements:     area _[ service _] composite _t **content = self- content;\n  for (int i = 0; i   list_size; i++) {\n     area _[ service _] composite _t *element = content[i];  All the elements of the list may be null. A presence flag is encoded for each of them:      bool presence_flag = (element != NULL);\n    mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);  Compute the encoding length of a non mandatory composite field: cf section 11.1.1.    }\n  return rc;\n}", 
            "title": "Computing the encoding length (malbinary)"
        }, 
        {
            "location": "/stub_generator/#encoding-malbinary_1", 
            "text": "int  area _[ service _] composite _list_encode_malbinary(\n   area _[ service _] composite _list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;\n  rc = mal_encoder_encode_list_size(encoder, cursor, list_size);\n  if (rc   0) return rc;\n   area _[ service _] composite _t **content = self- content;\n  for (int i = 0; i   list_size; i++) {\n     area _[ service _] composite _t *element = content[i];  Encoding a non mandatory Composite : cf section 11.2.1.    }\n  return rc;\n}", 
            "title": "Encoding (malbinary)"
        }, 
        {
            "location": "/stub_generator/#decoding-malbinary_1", 
            "text": "int  area _[ service _] composite _list_decode_malbinary(\n   area _[ service _] composite _list_t *self,\n  mal_decoder_t *decoder, void *cursor) {\n  int rc = 0;\n  int rc = mal_decoder_decode_list_size(decoder, cursor,  self- element_count);\n  if (rc   0) return rc;\n  if (self- element_count == 0) {\n    self- content = NULL;\n    return 0;\n  }\n  self- content = ( area _[ service _] composite _t **) calloc(\n      sizeof( area _[ service _] composite _t *) * self- element_count);\n  if (self- content == NULL)\n    return -1;\n  for (int i = 0; i   self- element_count; i++) {  Decoding a non mandatory Composite: cf section 11.3.1.  Data are decoded directly into the result structure or pointer (i.e.  self- content[i] ).    }\n  return rc;\n}", 
            "title": "Decoding (malbinary)"
        }, 
        {
            "location": "/stub_generator/#destructor_2", 
            "text": "Frees the list, its content, and the list elements.  void  area _[ service _] composite _list_destroy(\n     area _[ service _] composite _list_t **self_p) {\n  if ((*self_p)- element_count   0) {\n    for (int i = 0; i   (*self_p)- element_count; i++) {\n      if ((*self_p)- content[i] != NULL)\n         area _[ service _] composite _destroy( (*self_p)- content[i]);\n    }\n    free((*self_p)- content);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Destructor"
        }, 
        {
            "location": "/stub_generator/#lists-of-enumerated-values", 
            "text": "", 
            "title": "Lists of enumerated values"
        }, 
        {
            "location": "/stub_generator/#include-file-h_3", 
            "text": "#ifndef __ AREA _[ SERVICE _] ENUMERATION _LIST_H_INCLUDED__\n#define __ AREA _[ SERVICE _] ENUMERATION _LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif", 
            "title": "Include file (.h)"
        }, 
        {
            "location": "/stub_generator/#constructor_3", 
            "text": "area _[ service _] enumeration _list_t\n  * area _[ service _] enumeration _list_new(\n    unsigned int element_count);", 
            "title": "Constructor:"
        }, 
        {
            "location": "/stub_generator/#getters_2", 
            "text": "unsigned int  area _[ service _] enumeration _list_get_element_count(\n   area _[ service _] enumeration _list_t *self);\n\nbool * area _[ service _] enumeration _list_get_presence_flags(\n     area _[ service _] enumeration _list_t *self); area _[ service _] enumeration _t *mal_list_get_content(\n   area _[ service _] enumeration _list_t *self);", 
            "title": "Getters:"
        }, 
        {
            "location": "/stub_generator/#for-each-encoding-format_1", 
            "text": "int  area _[ service _] enumeration _list_add_encoding_length_ format (\n   area _[ service _] enumeration _list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint  area _[ service _] enumeration _list_encode_ format (\n   area _[ service _] enumeration _list_t *self,\n  mal_encoder_t *encoder, void *cursor);\n\nint  area _[ service _] enumeration _list_decode_ format (\n   area _[ service _] enumeration _t *self,\n   format _decoder_t *decoder, void *cursor);", 
            "title": "For each encoding format:"
        }, 
        {
            "location": "/stub_generator/#destructor_3", 
            "text": "void  area _[ service _] enumeration _list_destroy(\n     area _[ service _] enumeration _list_t **self_p);\nFonction de test :\nvoid  area _[ service _] enumeration _list_test(bool verbose);", 
            "title": "Destructor:"
        }, 
        {
            "location": "/stub_generator/#end-of-file_2", 
            "text": "#ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "End of file:"
        }, 
        {
            "location": "/stub_generator/#source-file-c_3", 
            "text": "#include  area .h", 
            "title": "Source file (.c)"
        }, 
        {
            "location": "/stub_generator/#constructor_4", 
            "text": "Declare the structure:  struct _ area _[ service _] enumeration _list_t {\n  unsigned int element_count;\n  bool *presence_flags;\n   area _[ service _] enumeration _t *content;\n};  Constructor:  area _[ service _] enumeration _list_t\n  * area _[ service _] enumeration _list_new(\n    unsigned int element_count) {\n   area _[ service _] enumeration _list_t *self =\n    ( area _[ service _] enumeration _list_t *) calloc(1,\n      sizeof( area _[ service _] enumeration _list_t));\n  if (!self) return NULL;\n  self- element_count = element_count;\n  if (element_count == 0) return self;\n  self- presence_flags = (bool *) calloc(element_count, sizeof(bool));\n  if (!self- presence_flags) {\n    free(self);\n    return NULL;\n  }\n  self- content = ( area _[ service _] enumeration _t *) calloc(\n      element_count, sizeof( area _[ service _] enumeration _t));\n  if (!self- content) {\n    free(self- presence_flags);\n    free(self);\n    return NULL;\n  }\n  return self;\n}", 
            "title": "Constructor"
        }, 
        {
            "location": "/stub_generator/#getters_3", 
            "text": "unsigned int  area _[ service _] enumeration _list_get_element_count(\n   area _[ service _] enumeration _list_t *self) {\n  return self- element_count;\n}\n\nbool * area _[ service _] enumeration _list_get_presence_flags(\n   area _[ service _] enumeration _list_t *self) {\n  return self- presence_flags;\n} area _[ service _] enumeration _t\n  * area _[ service _] enumeration _list_get_content(\n   area _[ service _] enumeration _list_t *self) {\n  return self- content;\n}", 
            "title": "Getters"
        }, 
        {
            "location": "/stub_generator/#computing-the-encoding-length-malbinary_2", 
            "text": "int  area _[ service _] enumeration _list_add_encoding_length_malbinary(\n   area _[ service _] enumeration _list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;  Encoding the list size:    mal_encoder_add_list_size_encoding_length(encoder, list_size, cursor);  Encoding the list elements:     area _[ service _] composite _t **content = self- content;\n  for (int i = 0; i   list_size; i++) {\n     area _[ service _] composite _t *element = content[i];  All the elements of the list may be null. A presence flag is encoded for each of them:      bool presence_flag = self- presence_flags[i];\n    mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);  Compute the encoding length of a non mandatory enumeration field: cf section 11.1.1.    }\n  return rc;\n}", 
            "title": "Computing the encoding length (malbinary)"
        }, 
        {
            "location": "/stub_generator/#encoding-malbinary_2", 
            "text": "int  area _[ service _] enumeration _list_encode_malbinary(\n   area _[ service _] enumeration _list_t *self,\n  mal_encoder_t *encoder, void *cursor) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;\n  rc = mal_encoder_encode_list_size(encoder, cursor, list_size);\n  if (rc   0) return rc;\n  for (int i = 0; i   list_size; i++) {\n    bool presence_flag = self- presence_flags[i];\n     area _[ service _] enumeration _t element = self- content[i];  Encoding a non mandatory enumerated value: cf section 11.2.1.    }\n  return rc;\n}", 
            "title": "Encoding (malbinary)"
        }, 
        {
            "location": "/stub_generator/#decoding-malbinary_2", 
            "text": "int  area _[ service _] enumeration _list_decode_malbinary(\n   area _[ service _] enumeration _list_t *self,\n  mal_decoder_t *decoder, void *cursor) {\n  int rc = 0;\n  rc = mal_decoder_decode_list_size(decoder, cursor,  self- element_count);\n  if (rc   0) return rc;\n  if (self- element_count == 0) {\n    self- presence_flags = NULL;\n    self- content = NULL;\n    return 0;\n  }\n  self- presence_flags = (bool *) calloc(self- element_count, sizeof(bool));\n  if (self- presence_flags == NULL)\n    return -1;\n  self- content = ( area _[ service _] enumeration _t *) calloc(self- element_count, sizeof( area _[ service _] enumeration _t));\n  if (self- content == NULL) {\n    free(self- presence_flags);\n    return -1;\n  }\n  for (int i = 0; i   self- element_count; i++) {  Decoding a non mandatory enumerated value: cf section 11.3.1.  Data are decoded directly into the result structure or pointer (i.e.  self- presence_flags[i]  and  self- content[i] ).    }\n  return rc;\n}", 
            "title": "Decoding (malbinary)"
        }, 
        {
            "location": "/stub_generator/#destructor_4", 
            "text": "Free the list and its content.  void  area _[ service _] enum _list_destroy(\n     area _[ service _] enum _list_t **self_p) {\n  if ((*self_p)- element_count   0) {\n    free((*self_p)- presence_flags);\n    free((*self_p)- content);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Destructor"
        }, 
        {
            "location": "/malbinary_generator/", 
            "text": "'malbinary' encoding code generation\n\n\nThis code is used for both Area and Composite encoding functions (cf sections 10.1.2 and 10.2.2).\n\n\nComputing the encoding length\n\n\nThe following parameters are provided by the calling code:\n\n\n\n\nelement\n: MAL element to encode depending on its type\n\n\npresence_flag: presence flag when the element is not of a pointer type\n\n\nattribute_tag: identifier of the Attribute type in case of polymorphism of Attribute\n\n\nshort_form: identifier of the type in case of polymorphism of Element\n\n\nencoder: configuration of the encoder, which should have been created as a malbinary encoder\n\n\ncursor: a virtual index in the encoding structures, holds the result of the encoding length computation\n\n\n\n\nNon mandatory field\n\n\nAdd the size of the presence flag:\n\n\nmal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);\n\n\n\n\nIf the field is of a pointer type:\n\n\nif (\nelement\n != NULL) {\n\n\n\n\nElse test the presence flag:\n\n\nif (presence_flag) {\n\n\n\n\nAdd the size of the encoded element. Cf section 11.1.2.\n\n\n}\n\n\n\n\nMandatory field\n\n\nPolymorphism\n\n\nIn case of polymorphisme of Attribute:\n\n\nmal_encoder_add_attribute_tag_encoding_length(encoder, attribute_tag, cursor);\n\n\n\n\nIn case of polymorphisme of Element:\n\n\nmal_encoder_add_short_form_encoding_length(encoder, short_form, cursor);\n\n\n\n\nElement value\n\n\nIf the declared type is \nMAL::Attribute\n:\n\n\nrc = mal_encoder_add_attribute_encoding_length(encoder,\n  attribute_tag, \nelement\n, cursor);\n\n\n\n\nIf the element type is an Attribute:\n\n\nrc = mal_encoder_add_\nattribute\n_encoding_length(encoder, \nelement\n, cursor);\n\n\n\n\nIf the element type is a Composite:\n\n\nrc = \narea\n_[\nservice\n_]\ncomposite\n_add_encoding_length_malbinary(\n  \nelement\n, encoder, cursor);\n\n\n\n\nIf the element type is a list:\n\n\nrc = \narea\n_[\nservice\n_]\ntype\n_list_add_encoding_length_malbinary(\n  \nelement\n, encoder, cursor);\n\n\n\n\nIf the element type is an Enumeration:\n\n\n\n\nIf the enumeration size is lower than 2^8:\n\n\n\n\n    rc = mal_encoder_add_small_enum_encoding_length(encoder, \nelement\n, cursor);\n\n\n\n\n\n\nIf the enumeration size is lower than 2^16:\n\n\n\n\n    rc = mal_encoder_add_medium_enum_encoding_length(encoder, \nelement\n, cursor);\n\n\n\n\n\n\nIf the enumeration size is lower than 2^32:\n\n\n\n\n    rc = mal_encoder_add_large_enum_encoding_length(encoder, \nelement\n, cursor);\n\n\n\n\nTest the error code:\n\n\nif (rc \n 0) return rc;\n\n\n\n\nEncoding\n\n\nThe following parameters are provided by the calling code:\n\n\n\n\nelement\n: MAL element to encode depending on its type\n\n\npresence_flag: presence flag when the element is not of a pointer type\n\n\nattribute_tag: identifier of the Attribute type in case of polymorphism of Attribute\n\n\nshort_form: identifier of the type in case of polymorphism of Element\n\n\nencoder: configuration of the encoder, which should have been created as a malbinary encoder\n\n\ncursor: a virtual index in the encoding structures, holds the result of the encoding length computation\n\n\n\n\nNon mandatory field\n\n\nEncoding the presence flag:\n\n\nrc = mal_encoder_encode_presence_flag(encoder, cursor, \npresence_flag\n);\nif (rc \n 0) return rc;\n\n\n\n\nTest the presence flag:\n\n\nif (\npresence_flag\n) {\n\n\n\n\nEncoding the element. Cf section 11.2.2.\n\n\n}\n\n\n\n\nMandatory field\n\n\nPolymorphism\n\n\nIn case of polymorphism of Attribute, encoding the attribute tag (cf section 5.2.2 of the MAL/SPP book):\n\n\nrc = mal_encoder_encode_attribute_tag(encoder, cursor, \nattribute_tag\n);\n\n\n\n\nIn case of polymorphism of Element:\n\n\nrc = mal_encoder_encode_short_form(encoder,\n  cursor, \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM);\n\n\n\n\nTest the error code:\n\n\nif (rc \n 0) return rc;\n\n\n\n\nElement value\n\n\nIf the declared type is \nMAL::Attribute\n:\n\n\nrc = mal_encoder_encode_attribute(encoder,\n  cursor, \nattribute_tag\n, \nelement\n);\n\n\n\n\nIf the element type is an Attribute:\n\n\nrc = mal_encoder_encode_\nattribute\n(encoder,\n  cursor, \nelement\n);\n\n\n\n\nIf the element type is a Composite:\n\n\nrc = \narea\n_[\nservice\n_]\ncomposite\n_encode_malbinary(\n  \nelement\n, encoder, cursor);\n\n\n\n\nIf the element type is a list:\n\n\nrc = \narea\n_[\nservice\n_]\ntype\n_list_encode_malbinary(\n  \nelement\n, encoder, cursor);\n\n\n\n\nIf the element type is an Enumeration:\n\n\n\n\nIf the enumeration size is lower than 2^8:\n\n\n\n\n    rc = mal_encoder_encode_small_enum(encoder, cursor, \nelement\n);\n\n\n\n\n\n\nIf the enumeration size is lower than 2^16:\n\n\n\n\n    rc = mal_encoder_encode_medium_enum(encoder, cursor, \nelement\n);\n\n\n\n\n\n\nIf the enumeration size is lower than 2^32:\n\n\n\n\n    rc = mal_encoder_encode_large_enum(encoder, cursor, \nelement\n);\n\n\n\n\nTest the error code:\n\n\nif (rc \n 0) return rc;\n\n\n\n\nDecoding\n\n\nThe following parameters are provided by the calling code:\n\n\n\n\npresence_flag: presence flag when the element is not of a pointer type\n\n\ndecoder: configuration of the decoder, which should have been created as a malbinary decoder\n\n\ncursor: a virtual index in the encoding structures\n\n\n\n\nNon mandatory field\n\n\nDecoding the presence flag:\n\n\nrc = mal_decoder_decode_presence_flag(decoder, cursor, \npresence_flag);\nif (rc \n 0) return rc;\nif (presence_flag) {\n\n\n\n\nDecoding the element. Cf section 11.3.2.\n\n\n}\n\n\n\n\nIf the field is of a pointer type:\n\n\nelse {\n  \nelement\n = NULL;\n}\n\n\n\n\nMandatory field\n\n\nPolymorphism of Attribute\n\n\nIn case of polymorphism of Attribute, decoding the Attribute tag:\n\n\nunsigned char attribute_tag;\n\n\n\n\n\nrc = mal_decoder_decode_attribute_tag(decoder,\n  cursor, \nattribute_tag\n);\n\n\n\n\nTest the error code:\n\n\nif (rc \n 0) return rc;\n\n\n\n\nDecoding the attribute:\n\n\nrc = mal_decoder_decode_attribute(decoder,\n    cursor, attribute_tag , \nelement\n);\n\n\n\n\nPolymorphism of Element\n\n\nIn case of polymorphism of Element, decoding the \nshort form\n:\n\n\nrc = mal_decoder_decode_short_form(decoder,\n  cursor, \nelement_holder-\nshort_form);\n\n\n\n\nTest the error code:\n\n\nif (rc \n 0) return rc;\n\n\n\n\nFor each possible value of 'short_form' corresponding to a concrete type conforming to the abstract type:\n\n\nif (element_holder-\nshort_form == \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM) {\n\n\n\n\nDecoding an element of the specified type. Cf section 11.3.2.3.\nThe element is decoded directly in the structure:\n\n\n\n\nIf the element type is an Attribute:\n\n\n\n\n    \nelement_holder-\nvalue.\nattribute\n_value\n\n\n\n\n\n\nIf the element type is a Composite:\n\n\n\n\n      \nelement_holder-\nvalue.composite_value\n\n\n\n\n\n\nIf the element type is a list:\n\n\n\n\n      \nelement_holder-\nvalue.list_value\n\n\n\n\n\n\nIf the element type is an Enumeration:\n\n\n\n\n      \nelement_holder-\nvalue.enumerated_value\n\n\n\n\n}[ else ]\n\n\n\n\nElement value\n\n\nIf the element type is an Attribute:\n\n\nrc = mal_decoder_decode_\nattribute\n(decoder,\n  cursor, \nelement\n);\n\n\n\n\nIf the element type is a Composite:\n\n\nelement\n = \narea\n_[\nservice\n_]\ncomposite\n_new();\nif (\nelement\n == NULL) return -1;\nrc = \narea\n_[\nservice\n_]\ncomposite\n_decode_malbinary(\n  \nelement\n, decoder, cursor);\n\n\n\n\nIf the element type is a list:\n\n\nelement\n = \narea\n_[\nservice\n_]\ntype\n_list_new(0);\nif (\nelement\n == NULL) return -1;\nrc = \narea\n_[\nservice\n_]\ntype\n_list_decode_malbinary(\n  \nelement\n, decoder, cursor);\n\n\n\n\nIf the element type is an Enumeration :\n\n\nint enumerated_value;\n\n\n\n\n\n\nIf the enumeration size is lower than 2^8:\n\n\n\n\n    rc = mal_decoder_decode_small_enum(decoder,\n  cursor, \nenumerated_value);\n\n\n\n\n\n\nIf the enumeration size is lower than 2^16:\n\n\n\n\n    rc = mal_decoder_decode_medium_enum(decoder,\n  cursor, \nenumerated_value);\n\n\n\n\n\n\nIf the enumeration size is lower than 2^32:\n\n\n\n\n    rc = mal_decoder_decode_large_enum(decoder,\n  cursor, \nenumerated_value);\n\n\n\n\nSetting the decoded value:\n\n\nelement\n = (\narea\n_[\nservice\n_]\nenum\n_t) enumerated_value;\n\n\n\n\nTest the error code:\n\n\nif (rc \n 0) return rc;", 
            "title": "MalBinary"
        }, 
        {
            "location": "/malbinary_generator/#malbinary-encoding-code-generation", 
            "text": "This code is used for both Area and Composite encoding functions (cf sections 10.1.2 and 10.2.2).", 
            "title": "'malbinary' encoding code generation"
        }, 
        {
            "location": "/malbinary_generator/#computing-the-encoding-length", 
            "text": "The following parameters are provided by the calling code:   element : MAL element to encode depending on its type  presence_flag: presence flag when the element is not of a pointer type  attribute_tag: identifier of the Attribute type in case of polymorphism of Attribute  short_form: identifier of the type in case of polymorphism of Element  encoder: configuration of the encoder, which should have been created as a malbinary encoder  cursor: a virtual index in the encoding structures, holds the result of the encoding length computation", 
            "title": "Computing the encoding length"
        }, 
        {
            "location": "/malbinary_generator/#non-mandatory-field", 
            "text": "Add the size of the presence flag:  mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);  If the field is of a pointer type:  if ( element  != NULL) {  Else test the presence flag:  if (presence_flag) {  Add the size of the encoded element. Cf section 11.1.2.  }", 
            "title": "Non mandatory field"
        }, 
        {
            "location": "/malbinary_generator/#mandatory-field", 
            "text": "", 
            "title": "Mandatory field"
        }, 
        {
            "location": "/malbinary_generator/#polymorphism", 
            "text": "In case of polymorphisme of Attribute:  mal_encoder_add_attribute_tag_encoding_length(encoder, attribute_tag, cursor);  In case of polymorphisme of Element:  mal_encoder_add_short_form_encoding_length(encoder, short_form, cursor);", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/malbinary_generator/#element-value", 
            "text": "If the declared type is  MAL::Attribute :  rc = mal_encoder_add_attribute_encoding_length(encoder,\n  attribute_tag,  element , cursor);  If the element type is an Attribute:  rc = mal_encoder_add_ attribute _encoding_length(encoder,  element , cursor);  If the element type is a Composite:  rc =  area _[ service _] composite _add_encoding_length_malbinary(\n   element , encoder, cursor);  If the element type is a list:  rc =  area _[ service _] type _list_add_encoding_length_malbinary(\n   element , encoder, cursor);  If the element type is an Enumeration:   If the enumeration size is lower than 2^8:       rc = mal_encoder_add_small_enum_encoding_length(encoder,  element , cursor);   If the enumeration size is lower than 2^16:       rc = mal_encoder_add_medium_enum_encoding_length(encoder,  element , cursor);   If the enumeration size is lower than 2^32:       rc = mal_encoder_add_large_enum_encoding_length(encoder,  element , cursor);  Test the error code:  if (rc   0) return rc;", 
            "title": "Element value"
        }, 
        {
            "location": "/malbinary_generator/#encoding", 
            "text": "The following parameters are provided by the calling code:   element : MAL element to encode depending on its type  presence_flag: presence flag when the element is not of a pointer type  attribute_tag: identifier of the Attribute type in case of polymorphism of Attribute  short_form: identifier of the type in case of polymorphism of Element  encoder: configuration of the encoder, which should have been created as a malbinary encoder  cursor: a virtual index in the encoding structures, holds the result of the encoding length computation", 
            "title": "Encoding"
        }, 
        {
            "location": "/malbinary_generator/#non-mandatory-field_1", 
            "text": "Encoding the presence flag:  rc = mal_encoder_encode_presence_flag(encoder, cursor,  presence_flag );\nif (rc   0) return rc;  Test the presence flag:  if ( presence_flag ) {  Encoding the element. Cf section 11.2.2.  }", 
            "title": "Non mandatory field"
        }, 
        {
            "location": "/malbinary_generator/#mandatory-field_1", 
            "text": "", 
            "title": "Mandatory field"
        }, 
        {
            "location": "/malbinary_generator/#polymorphism_1", 
            "text": "In case of polymorphism of Attribute, encoding the attribute tag (cf section 5.2.2 of the MAL/SPP book):  rc = mal_encoder_encode_attribute_tag(encoder, cursor,  attribute_tag );  In case of polymorphism of Element:  rc = mal_encoder_encode_short_form(encoder,\n  cursor,  AREA _[ SERVICE _] TYPE _SHORT_FORM);  Test the error code:  if (rc   0) return rc;", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/malbinary_generator/#element-value_1", 
            "text": "If the declared type is  MAL::Attribute :  rc = mal_encoder_encode_attribute(encoder,\n  cursor,  attribute_tag ,  element );  If the element type is an Attribute:  rc = mal_encoder_encode_ attribute (encoder,\n  cursor,  element );  If the element type is a Composite:  rc =  area _[ service _] composite _encode_malbinary(\n   element , encoder, cursor);  If the element type is a list:  rc =  area _[ service _] type _list_encode_malbinary(\n   element , encoder, cursor);  If the element type is an Enumeration:   If the enumeration size is lower than 2^8:       rc = mal_encoder_encode_small_enum(encoder, cursor,  element );   If the enumeration size is lower than 2^16:       rc = mal_encoder_encode_medium_enum(encoder, cursor,  element );   If the enumeration size is lower than 2^32:       rc = mal_encoder_encode_large_enum(encoder, cursor,  element );  Test the error code:  if (rc   0) return rc;", 
            "title": "Element value"
        }, 
        {
            "location": "/malbinary_generator/#decoding", 
            "text": "The following parameters are provided by the calling code:   presence_flag: presence flag when the element is not of a pointer type  decoder: configuration of the decoder, which should have been created as a malbinary decoder  cursor: a virtual index in the encoding structures", 
            "title": "Decoding"
        }, 
        {
            "location": "/malbinary_generator/#non-mandatory-field_2", 
            "text": "Decoding the presence flag:  rc = mal_decoder_decode_presence_flag(decoder, cursor,  presence_flag);\nif (rc   0) return rc;\nif (presence_flag) {  Decoding the element. Cf section 11.3.2.  }  If the field is of a pointer type:  else {\n   element  = NULL;\n}", 
            "title": "Non mandatory field"
        }, 
        {
            "location": "/malbinary_generator/#mandatory-field_2", 
            "text": "", 
            "title": "Mandatory field"
        }, 
        {
            "location": "/malbinary_generator/#polymorphism-of-attribute", 
            "text": "In case of polymorphism of Attribute, decoding the Attribute tag:  unsigned char attribute_tag;   rc = mal_decoder_decode_attribute_tag(decoder,\n  cursor,  attribute_tag );  Test the error code:  if (rc   0) return rc;  Decoding the attribute:  rc = mal_decoder_decode_attribute(decoder,\n    cursor, attribute_tag ,  element );", 
            "title": "Polymorphism of Attribute"
        }, 
        {
            "location": "/malbinary_generator/#polymorphism-of-element", 
            "text": "In case of polymorphism of Element, decoding the  short form :  rc = mal_decoder_decode_short_form(decoder,\n  cursor,  element_holder- short_form);  Test the error code:  if (rc   0) return rc;  For each possible value of 'short_form' corresponding to a concrete type conforming to the abstract type:  if (element_holder- short_form ==  AREA _[ SERVICE _] TYPE _SHORT_FORM) {  Decoding an element of the specified type. Cf section 11.3.2.3.\nThe element is decoded directly in the structure:   If the element type is an Attribute:        element_holder- value. attribute _value   If the element type is a Composite:          element_holder- value.composite_value   If the element type is a list:          element_holder- value.list_value   If the element type is an Enumeration:          element_holder- value.enumerated_value  }[ else ]", 
            "title": "Polymorphism of Element"
        }, 
        {
            "location": "/malbinary_generator/#element-value_2", 
            "text": "If the element type is an Attribute:  rc = mal_decoder_decode_ attribute (decoder,\n  cursor,  element );  If the element type is a Composite:  element  =  area _[ service _] composite _new();\nif ( element  == NULL) return -1;\nrc =  area _[ service _] composite _decode_malbinary(\n   element , decoder, cursor);  If the element type is a list:  element  =  area _[ service _] type _list_new(0);\nif ( element  == NULL) return -1;\nrc =  area _[ service _] type _list_decode_malbinary(\n   element , decoder, cursor);  If the element type is an Enumeration :  int enumerated_value;   If the enumeration size is lower than 2^8:       rc = mal_decoder_decode_small_enum(decoder,\n  cursor,  enumerated_value);   If the enumeration size is lower than 2^16:       rc = mal_decoder_decode_medium_enum(decoder,\n  cursor,  enumerated_value);   If the enumeration size is lower than 2^32:       rc = mal_decoder_decode_large_enum(decoder,\n  cursor,  enumerated_value);  Setting the decoded value:  element  = ( area _[ service _] enum _t) enumerated_value;  Test the error code:  if (rc   0) return rc;", 
            "title": "Element value"
        }, 
        {
            "location": "/annexes/", 
            "text": "Annexes\n\n\n\"TestArea\" area example\n\n\nThis example (see https://github.com/ccsdsmo/malc/blob/master/xml/TestArea.xml) allows to test\nvarious aspects of the MAL specification:\n\n\n    - Interaction patterns: SEND, SUBMIT, INVOKE, REQUEST, PROGRESS and PUBSUB.\n    - Composite structure.\n    - Element list.\n    - Message body with multiples elements.\n    - Optional field ('canBeNull=true')\n    - Polymorphism of the last element of the message body.\n\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nmal:specification xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n                   xmlns:mal=\nhttp://www.ccsds.org/schema/ServiceSchema\n\n  \nmal:area name=\nTestArea\n number=\n200\n version=\n1\n\n    \nmal:service name=\nTestService\n number=\n1\n\n      \nmal:capabilitySet number=\n100\n\n        \nmal:sendIP name=\ntestSend\n number=\n100\n supportInReplay=\nfalse\n\n         comment=\n\n          \nmal:messages\n\n            \nmal:send\n\n              \nmal:type area=\nTestArea\n service=\nTestService\n\n               name=\nTestComposite\n /\n\n              \nmal:type list=\ntrue\n area=\nMAL\n name=\nString\n /\n\n              \nmal:type area=\nTestArea\n service=\nTestService\n\n               name=\nTestAbstractComposite\n /\n\n            \n/mal:send\n\n          \n/mal:messages\n\n        \n/mal:sendIP\n\n      \n/mal:capabilitySet\n\n      \nmal:dataTypes\n\n        \nmal:composite name=\nTestComposite\n shortFormPart=\n1\n comment=\n\n          \nmal:extends\n\n            \nmal:type area=\nMAL\n name=\nComposite\n /\n\n          \n/mal:extends\n\n          \nmal:field name=\nstringField\n canBeNull=\ntrue\n comment=\n\n            \nmal:type area=\nMAL\n name=\nString\n /\n\n          \n/mal:field\n\n          \nmal:field name=\nintField\n canBeNull=\ntrue\n comment=\n\n            \nmal:type area=\nMAL\n name=\nInteger\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n        \nsmc:composite name=\nTestAbstractComposite\n comment=\n\n          \nsmc:extends\n\n            \nsmc:type area=\nMAL\n name=\nComposite\n /\n\n          \n/smc:extends\n\n          \nmal:field name=\nintField\n canBeNull=\nfalse\n comment=\n\n            \nmal:type area=\nMAL\n name=\nInteger\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n        \nsmc:composite name=\nTestFinalCompositeA\n shortFormPart=\n2\n\n         comment=\n\n          \nsmc:extends\n\n            \nsmc:type area=\nTestArea\n service=\nTestService\n\n                      name=\nTestAbstractComposite\n /\n\n          \n/smc:extends\n\n          \nmal:field name=\nintField2\n canBeNull=\nfalse\n comment=\n\n            \nmal:type area=\nMAL\n name=\nInteger\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n        \nsmc:composite name=\nTestFinalCompositeB\n shortFormPart=\n3\n\n         comment=\n\n          \nsmc:extends\n\n            \nsmc:type area=\nTestArea\n service=\nTestService\n\n                      name=\nTestAbstractComposite\n /\n\n          \n/smc:extends\n\n          \nmal:field name=\nstringField\n canBeNull=\nfalse\n comment=\n\n            \nmal:type area=\nMAL\n name=\nString\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n      \n/mal:dataTypes\n\n    \n/mal:service\n\n  \n/mal:area\n\n\n/mal:specification\n\n\n\n\n\nNames collision\n\n\nThis annex lists the different name collisions that could occur during the code generation.\nSolutions are proposed. They are currently not applied to the code generation.\n\n\nComposite fields\n\n\nAdd a \n_f\n suffix to the name of the field to avoid a possible collusion with the presence field\nif it exists. For example, two MAL fields named \ntoto\n and \ntoto_is_present\n.\n\n\nbool \nfield\n_is_present;\nunsigned int \nfield\n_attribute_tag;\n\nfield type\n \nfield\n_f;\n\n\n\n\nEncoding format of the MALZMQ header\n\n\nTo simplify the encoding format of the MAL header, the \nFrom URI\n and \nTo URI\n fields are encoded systematically and completely.\n\n\n\n\n\n\n\n\nVersion Number\n\n\nSDU Type\n\n\nService Area\n\n\nService\n\n\nOperation\n\n\nArea Version\n\n\nIs Error Message\n\n\nQoSlevel\n\n\nSession\n\n\nTransaction Id\n\n\n\n\n\n\n\n\n\n\nBinary value (3 bits)\n\n\nUnsigned 5-bit Integer (5 bits)\n\n\nUnsigned 16-bit Integer (16 bits)\n\n\nUnsigned 16-bit Integer (16 bits)\n\n\nUnsigned 16-bit Integer (16 bits)\n\n\nUnsigned 8-bit Integer (8 bits)\n\n\nBinary value (1 bit)\n\n\nUnsigned 3-bit Integer (3 bits)\n\n\nUnsigned 4-bit Integer (4 bits)\n\n\nUnsigned 64-bit Integer (64 bits)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpare\n\n\nPriority Flag\n\n\nTime-stamp Flag\n\n\nNetwork Zone Flag\n\n\nSession Name Flag\n\n\nDomain Flag\n\n\nAuthentication Id Flag\n\n\n\n\n\n\n\n\n\n\nBinary value (2 bits)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPriority\n\n\nURI From\n\n\nURI To\n\n\n\n\n\n\n\n\n\n\nUInteger (var. mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\n\n\n\n\nIf \u2018Priority Flag\u2019 is \u20181\u2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTimestamp\n\n\nNetwork Zone\n\n\nSession Name\n\n\nDomain\n\n\nAuthentication Id\n\n\n\n\n\n\n\n\n\n\nTime (var., mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\nList\n (var., mult. of octet)\n\n\nBlob (var., mult. of octet)\n\n\n\n\n\n\nIf \u2018Timestamp Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Network Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Session Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Domain Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Authentication Id Flag\u2019 is \u20181\u2019\n\n\n\n\n\n\n\n\nClasses description diagram\n\n\nThe diagram below shows the different implementation classes and their relationships. Classes are separated in two spaces: MAL/C and MAL/ZMQ transport. Most of these relationships are unitary, only \nmalzmq_poller_data_t\n class contains a reference list to the \nmalzmq_endpoint_data_t\n class.\n\n\n\n\n*Figure 1 - MAL classes diagram", 
            "title": "Annexs"
        }, 
        {
            "location": "/annexes/#annexes", 
            "text": "", 
            "title": "Annexes"
        }, 
        {
            "location": "/annexes/#testarea-area-example", 
            "text": "This example (see https://github.com/ccsdsmo/malc/blob/master/xml/TestArea.xml) allows to test\nvarious aspects of the MAL specification:      - Interaction patterns: SEND, SUBMIT, INVOKE, REQUEST, PROGRESS and PUBSUB.\n    - Composite structure.\n    - Element list.\n    - Message body with multiples elements.\n    - Optional field ('canBeNull=true')\n    - Polymorphism of the last element of the message body.  ?xml version= 1.0  encoding= UTF-8 ?  mal:specification xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n                   xmlns:mal= http://www.ccsds.org/schema/ServiceSchema \n   mal:area name= TestArea  number= 200  version= 1 \n     mal:service name= TestService  number= 1 \n       mal:capabilitySet number= 100 \n         mal:sendIP name= testSend  number= 100  supportInReplay= false \n         comment= \n           mal:messages \n             mal:send \n               mal:type area= TestArea  service= TestService \n               name= TestComposite  / \n               mal:type list= true  area= MAL  name= String  / \n               mal:type area= TestArea  service= TestService \n               name= TestAbstractComposite  / \n             /mal:send \n           /mal:messages \n         /mal:sendIP \n       /mal:capabilitySet \n       mal:dataTypes \n         mal:composite name= TestComposite  shortFormPart= 1  comment= \n           mal:extends \n             mal:type area= MAL  name= Composite  / \n           /mal:extends \n           mal:field name= stringField  canBeNull= true  comment= \n             mal:type area= MAL  name= String  / \n           /mal:field \n           mal:field name= intField  canBeNull= true  comment= \n             mal:type area= MAL  name= Integer  / \n           /mal:field \n         /mal:composite \n         smc:composite name= TestAbstractComposite  comment= \n           smc:extends \n             smc:type area= MAL  name= Composite  / \n           /smc:extends \n           mal:field name= intField  canBeNull= false  comment= \n             mal:type area= MAL  name= Integer  / \n           /mal:field \n         /mal:composite \n         smc:composite name= TestFinalCompositeA  shortFormPart= 2 \n         comment= \n           smc:extends \n             smc:type area= TestArea  service= TestService \n                      name= TestAbstractComposite  / \n           /smc:extends \n           mal:field name= intField2  canBeNull= false  comment= \n             mal:type area= MAL  name= Integer  / \n           /mal:field \n         /mal:composite \n         smc:composite name= TestFinalCompositeB  shortFormPart= 3 \n         comment= \n           smc:extends \n             smc:type area= TestArea  service= TestService \n                      name= TestAbstractComposite  / \n           /smc:extends \n           mal:field name= stringField  canBeNull= false  comment= \n             mal:type area= MAL  name= String  / \n           /mal:field \n         /mal:composite \n       /mal:dataTypes \n     /mal:service \n   /mal:area  /mal:specification", 
            "title": "\"TestArea\" area example"
        }, 
        {
            "location": "/annexes/#names-collision", 
            "text": "This annex lists the different name collisions that could occur during the code generation.\nSolutions are proposed. They are currently not applied to the code generation.", 
            "title": "Names collision"
        }, 
        {
            "location": "/annexes/#composite-fields", 
            "text": "Add a  _f  suffix to the name of the field to avoid a possible collusion with the presence field\nif it exists. For example, two MAL fields named  toto  and  toto_is_present .  bool  field _is_present;\nunsigned int  field _attribute_tag; field type   field _f;", 
            "title": "Composite fields"
        }, 
        {
            "location": "/annexes/#encoding-format-of-the-malzmq-header", 
            "text": "To simplify the encoding format of the MAL header, the  From URI  and  To URI  fields are encoded systematically and completely.     Version Number  SDU Type  Service Area  Service  Operation  Area Version  Is Error Message  QoSlevel  Session  Transaction Id      Binary value (3 bits)  Unsigned 5-bit Integer (5 bits)  Unsigned 16-bit Integer (16 bits)  Unsigned 16-bit Integer (16 bits)  Unsigned 16-bit Integer (16 bits)  Unsigned 8-bit Integer (8 bits)  Binary value (1 bit)  Unsigned 3-bit Integer (3 bits)  Unsigned 4-bit Integer (4 bits)  Unsigned 64-bit Integer (64 bits)        Spare  Priority Flag  Time-stamp Flag  Network Zone Flag  Session Name Flag  Domain Flag  Authentication Id Flag      Binary value (2 bits)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)        Priority  URI From  URI To      UInteger (var. mult. of octet)  Optional MDK (var., mult. of octet)  Optional MDK (var., mult. of octet)    If \u2018Priority Flag\u2019 is \u20181\u2019          Timestamp  Network Zone  Session Name  Domain  Authentication Id      Time (var., mult. of octet)  Optional MDK (var., mult. of octet)  Optional MDK (var., mult. of octet)  List  (var., mult. of octet)  Blob (var., mult. of octet)    If \u2018Timestamp Flag\u2019 is \u20181\u2019  If \u2018Network Flag\u2019 is \u20181\u2019  If \u2018Session Flag\u2019 is \u20181\u2019  If \u2018Domain Flag\u2019 is \u20181\u2019  If \u2018Authentication Id Flag\u2019 is \u20181\u2019", 
            "title": "Encoding format of the MALZMQ header"
        }, 
        {
            "location": "/annexes/#classes-description-diagram", 
            "text": "The diagram below shows the different implementation classes and their relationships. Classes are separated in two spaces: MAL/C and MAL/ZMQ transport. Most of these relationships are unitary, only  malzmq_poller_data_t  class contains a reference list to the  malzmq_endpoint_data_t  class.   *Figure 1 - MAL classes diagram", 
            "title": "Classes description diagram"
        }
    ]
}