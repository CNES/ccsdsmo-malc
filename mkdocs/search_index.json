{
    "docs": [
        {
            "location": "/", 
            "text": "API MAL en C et transport MAL/CZMQ\n\n\nIntroduction\n\n\nL'API C repr\u00e9sente tous les concepts MAL, en particulier les patterns d'interaction, le format de message MAL et le mod\u00e8le de donn\u00e9es.\nL'objectif principal de l'API C est d'offrir une version simplifi\u00e9e des fonctions de l'API MAL en Java. La complexit\u00e9 inh\u00e9rente au standard MAL doit \u00eatre conserv\u00e9e. Cependant, plusieurs aspects complexes de l'API MAL en Java peuvent \u00eatre simplifi\u00e9s ou abandonn\u00e9s, soit parce qu'ils ne sont pas indispensables, soit parce qu'ils sont li\u00e9s \u00e0 des choix de conception diff\u00e9rents (par exemple l'approche orient\u00e9e appel de proc\u00e9dure, RPC), soit parce qu'ils peuvent \u00eatre am\u00e9lior\u00e9s (par exemple la liaison forte entre transport et encodage).\n\n\nLes \u00e9l\u00e9ments de complexit\u00e9 suivants sont inh\u00e9rents au standard MAL. Ils doivent \u00eatre conserv\u00e9s :\n\n\n\n\nS\u00e9paration des fonctions de transport, d'encodage et de contr\u00f4le d'acc\u00e8s : multiples APIs et fonctions abstraites\n\n\nPatterns d'interaction complexes : \nInvoke\n, \nProgress\n, \nPublish-Subscribe\n\n\nPolymorphisme d'\u00e9l\u00e9ment MAL, limit\u00e9 au dernier \u00e9l\u00e9ment d'un corps de message\n\n\nPolymorphisme d'Attribut MAL\n\n\nH\u00e9ritage de structure\n\n\n\n\nPolymorphisme d'\u00e9l\u00e9ment MAL\n\n\nLe livre MAL autorise l'utilisation du polymorphisme d'\u00e9l\u00e9ment \u00e0 condition qu'il ne soit appliqu\u00e9 qu'au dernier \u00e9l\u00e9ment d'un corps de message. Ce dernier \u00e9l\u00e9ment peut \u00eatre d\u00e9clar\u00e9 avec les types suivants :\n\n\n\n\nMAL::Element\n\n\nun type \nComposite\n abstrait\n\n\nune liste d'\u00e9l\u00e9ments de type \nMAL::Element\n\n\nune liste d'\u00e9l\u00e9ments de type \nComposite\n abstrait\n\n\nune liste d'\u00e9l\u00e9ments de type \nMAL::Attribute\n\n\n\n\nLes types list\u00e9s ci-dessus sont r\u00e9serv\u00e9s au polymorphisme du dernier \u00e9l\u00e9ment d'un corps de message. Ils ne peuvent pas \u00eatre utilis\u00e9s pour un champ de Composite.\n\n\nLes listes d'\u00e9l\u00e9ments de type abstrait (\nComposite\n, \nMAL::Element\n ou \nMAL::Attribute\n) ne peuvent pas \u00eatre instanci\u00e9es : il n'y a pas de structure de liste pouvant contenir des \u00e9l\u00e9ments de type abstrait (et donc des \u00e9l\u00e9ments de plusieurs types conformes \u00e0 ce type abstrait). Par exemple :\n\n\n\n\nList\nMAL::Element\n, \nList\nMAL::Attribute\n ne peuvent pas \u00eatre instanci\u00e9es\n\n\nList\nMAL::UpdateHeader\n, \nList\nMAL::Boolean\n peuvent \u00eatre instanci\u00e9es\n\n\n\n\nEn cons\u00e9quence, une structure liste contient n\u00e9cessairement des \u00e9l\u00e9ments de m\u00eame type et de type non abstrait.\n\n\nPolymorphisme d'Attribut MAL\n\n\nLe livre MAL autorise l'utilisation du polymorphisme d'attribut pour le dernier \u00e9l\u00e9ment d'un corps de message et pour les champs de Composite.\nLe polymorphisme d'Attribut consiste \u00e0 d\u00e9clarer un \u00e9l\u00e9ment ou un champ avec le type MAL::Attribute.\n\n\nConcepts\n\n\nLa plupart des concepts de l'API MAL en C sont impos\u00e9s par la sp\u00e9cification MAL : message MAL, champs de header, types de donn\u00e9es. Cependant, la sp\u00e9cification MAL ne d\u00e9finit pas certains concepts qui sont propres \u00e0 l'impl\u00e9mentation de la sp\u00e9cification. Cette section pr\u00e9sente uniquement ces concepts.\n\n\nEnd-Point\n\n\nLe end-point MAL est l'entit\u00e9 qui permet d'\u00e9mettre et de recevoir des messages MAL. Chaque end-point est associ\u00e9 \u00e0 une unique URI de service MAL, l'API MAL permet la cr\u00e9ation et la suppression dynamique de end-point.\n\n\nSeul le end-point qui a re\u00e7u le message initiant une interaction peut r\u00e9pondre \u00e0 cette interaction.\n\n\nUn end-point poss\u00e8de les caract\u00e9ristiques suivantes :\n\n\n\n\nIl ne peut utiliser qu'un unique transport (binding) pour recevoir et envoyer des messages MAL.\n\n\nIl peut utiliser plusieurs formats d'encodage du corps de message MAL.\n\n\nIl est identifi\u00e9 de mani\u00e8re unique par une URI MAL relative au contexte MAL et dont le format d\u00e9pend du transport utilis\u00e9.\n\n\nIl doit \u00eatre ex\u00e9cut\u00e9 de mani\u00e8re mono-thread\u00e9e.\n\n\nIl g\u00e8re un compteur de \nTransaction Id\n (champ du header MAL).\n\n\n\n\nPoller\n\n\nLe poller MAL est une entit\u00e9 qui permet d'attendre l'arriv\u00e9e d'un message sur de multiples end-points. L'API MAL permet la cr\u00e9ation et la suppression dynamique de pollers, l'ajout et la suppression de end-point au poller.\n\n\nUn poller poss\u00e8de les caract\u00e9ristiques suivantes :\n\n\n\n\nL'ensemble des end-points d'un poller doivent d\u00e9pendre d'un m\u00eame contexte MAL et donc d'un unique transport (binding).\n\n\nIl doit \u00eatre ex\u00e9cut\u00e9 de mani\u00e8re mono-thread\u00e9e.\n\n\n\n\nL'usage du poller MAL n'est pas obligatoire, il est utile dans diff\u00e9rents cas :\n\n\n\n\nGestion de multiples end-points au travers d'un flot d'ex\u00e9cution unique,\n\n\nR\u00e9ception non bloquante de messages.\n\n\n\n\nHandler et Routage\n\n\nCes concepts sont offerts afin de faciliter la distribution des messages MAL re\u00e7us aux fonctions de traitement, leur utilisation est optionnelle.\n\n\nUn Handler est un traitant d'interaction MAL, il s'ex\u00e9cute de mani\u00e8re asynchrone quand il est notifi\u00e9 de l'arriv\u00e9e d'un message MAL et envoie en retour z\u00e9ro, un ou plusieurs messages MAL, soit pour initier de nouvelles interactions (r\u00f4le du consumer), soit pour r\u00e9pondre \u00e0 l'interaction en cours (r\u00f4le du provider).\n\n\nChaque handler poss\u00e8de une interface d\u00e9pendant de son r\u00f4le (provider, consumer, etc.) et de l'interaction dans laquelle il intervient (send, submit, etc.). Par exemple pour une interaction Progress :\n\n\n\n\nLe handler du provider doit offrir la fonction : \non_progress\n\n\nLe handler du consumer doit offrir les fonctions : \non_ack\n, \non_update\n et \non_response\n.\n\n\n\n\nChacune de ces fonctions est appel\u00e9e avec les param\u00e8tres suivants :\n\n\n\n\nun pointeur sur l'\u00e9tat du router (cf 7.6),\n\n\nun pointeur sur le contexte MAL (cf 7.2),\n\n\nun pointeur sur le end-point MAL (cf 7.4),\n\n\net un pointeur sur le message MAL (cf 7.3).\n\n\n\n\nL'API MAL offre une classe helper (mal_routing) qui simplifie la gestion des Handlers d'un end-point donn\u00e9, cette classe mal_routing permet d'enregistrer les handlers correspondants aux diff\u00e9rentes interactions attendues, puis lors de la r\u00e9ception d'un message par le end-point d'activer le handler correspondant pour qu'il traite le message.\n\n\nLes routeurs poss\u00e8dent un \u00e9tat partag\u00e9 par l'ensemble des handlers qu'ils g\u00e8rent.\n\n\nMAL Broker\n\n\nDans notre implantation du transport ZMQ le Publish/Subscribe est partiellement support\u00e9 par le transport ZMQ au travers des sockets PUB/SUB de ZMQ. Afin de respecter la s\u00e9mantique du pattern Publish/Subscribe du MAL il est cependant n\u00e9cessaire d'implanter un composant Broker g\u00e9rant les souscriptions et le filtrage des messages.\n\n\nAfin de respecter le mode de fonctionnement de ZMQ ce composant Broker sera localis\u00e9 cot\u00e9 Consumer. Actuellement il est implant\u00e9 sous la forme d'un Handler (section 2.3) particulier que l'utilisateur de l'API peut modifier.\n\n\nTransformation d'URI\n\n\nZMQ peut utiliser de multiples protocoles sous-jacents pour communiquer. Par exemple des communications point-\u00e0-point peuvent passer par TCP entre des processus de machines diff\u00e9rentes, des IPC entre processus de la m\u00eame machine ou des m\u00e9canismes internes dans un m\u00eame processus. De m\u00eame, le Publish/Subscribe peut \u00eatre mis en \u0153uvre au travers de TCP, PGM ou EPGM.\n\n\nLe transport MALZMQ utilise diff\u00e9rents flots de communication selon les interactions, dans notre prototype chaque contexte MAL \u00e9coute sur 2 sockets diff\u00e9rents :\n\n\n\n\nUn socket \nDEALER\n pour les communications point-\u00e0-point\n\n\nUn socket \nSUB\n pour les communications multicast.\n\n\n\n\nAfin d'assurer la transformation de l'URI MAL d'un service en URI ZMQ n\u00e9cessaire \u00e0 la r\u00e9alisation d'une interaction et afin d'offrir \u00e0 l'utilisateur une grande libert\u00e9 de configuration nous avons choisi d'externaliser cette transformation au travers d'upcalls (section 12.2.1).\n\n\nAttributs pointeurs\n\n\nLes attributs pointeurs sont les attributs MAL dont la repr\u00e9sentation en C est un type pointeur : \nMAL::Blob\n, \nMAL::Identifier\n, \nMAL::String\n et \nMAL::URI\n.\n\n\nPour ces attributs, la valeur \nNULL\n (pointeur nul) est autoris\u00e9e.\n\n\nPour les autres attributs (non pointeurs), la valeur nulle est repr\u00e9sent\u00e9e par un champ additionnel (de type bool\u00e9en) appel\u00e9 \u00ab flag de pr\u00e9sence \u00bb.\n\n\nVue d'ensemble de l'API C\n\n\nL'API C est constitu\u00e9e de plusieurs APIs :\n\n\n\n\nAPI d'attribut MAL\n : Les attributs MAL sont extraits de l'API MAL afin d'\u00e9viter une double-d\u00e9pendance entre l'API MAL (qui d\u00e9pend des APIs d'encodage) et les APIs d'encodage (qui d\u00e9pendent des attributs MAL).\n\n\nAPIs d'encodage\n : Les APIs d'encodage sont d\u00e9finies de mani\u00e8re sp\u00e9cifique \u00e0 un format d'encodage.\n\n\nAPI MAL\n : L'API MAL permet l'utilisation des concepts de niveau MAL.\n\n\nAPIs d'Area\n (g\u00e9n\u00e9r\u00e9es) : L'API MAL contient l'API d'Area g\u00e9n\u00e9r\u00e9e \u00e0 partir de la d\u00e9finition de l'Area MAL.\n\n\nAPIs de transport\n : qui g\u00e8re le mapping des concepts MAL sur les concepts sous-jacents du transport choisi.\n\n\nAPI d'extraction de param\u00e8tres de configuration\n.\n\n\n\n\nLa plupart des concepts sont repr\u00e9sent\u00e9s chacun par une classe conforme au mod\u00e8le Class de zproject :\n\n\n\n\nune structure opaque (seul le type est visible, pas le contenu) d\u00e9clar\u00e9e dans le header principal de l'API (\napi\n.h\n)\n\n\nun fichier \u00ab include \u00bb : \nnom de classe\n.h\n\n\nun fichier \u00ab source \u00bb : \nnom de classe\n.c\n\n\n\n\nLes noms de classe sont en caract\u00e8res minuscules, avec s\u00e9parateur '_', et sont pr\u00e9fix\u00e9s du nom de l'API. Par exemple, le concept de end-point, d\u00e9fini dans l'API MAL, est repr\u00e9sent\u00e9 par une classe nomm\u00e9e : \nmal_endpoint\n.\n\n\nLes noms des classes repr\u00e9sentant des types de donn\u00e9es sont pr\u00e9fix\u00e9s des noms de leur Area et leur Service (si existant). Par exemple le type MAL::Blob (d\u00e9fini dans l'area MAL, sans Service interm\u00e9diaire) est nomm\u00e9 : \nmal_blob\n.\n\n\nLes autres conventions sont propres au mod\u00e8le \nCLASS\n.", 
            "title": "Accueil"
        }, 
        {
            "location": "/#api-mal-en-c-et-transport-malczmq", 
            "text": "", 
            "title": "API MAL en C et transport MAL/CZMQ"
        }, 
        {
            "location": "/#introduction", 
            "text": "L'API C repr\u00e9sente tous les concepts MAL, en particulier les patterns d'interaction, le format de message MAL et le mod\u00e8le de donn\u00e9es.\nL'objectif principal de l'API C est d'offrir une version simplifi\u00e9e des fonctions de l'API MAL en Java. La complexit\u00e9 inh\u00e9rente au standard MAL doit \u00eatre conserv\u00e9e. Cependant, plusieurs aspects complexes de l'API MAL en Java peuvent \u00eatre simplifi\u00e9s ou abandonn\u00e9s, soit parce qu'ils ne sont pas indispensables, soit parce qu'ils sont li\u00e9s \u00e0 des choix de conception diff\u00e9rents (par exemple l'approche orient\u00e9e appel de proc\u00e9dure, RPC), soit parce qu'ils peuvent \u00eatre am\u00e9lior\u00e9s (par exemple la liaison forte entre transport et encodage).  Les \u00e9l\u00e9ments de complexit\u00e9 suivants sont inh\u00e9rents au standard MAL. Ils doivent \u00eatre conserv\u00e9s :   S\u00e9paration des fonctions de transport, d'encodage et de contr\u00f4le d'acc\u00e8s : multiples APIs et fonctions abstraites  Patterns d'interaction complexes :  Invoke ,  Progress ,  Publish-Subscribe  Polymorphisme d'\u00e9l\u00e9ment MAL, limit\u00e9 au dernier \u00e9l\u00e9ment d'un corps de message  Polymorphisme d'Attribut MAL  H\u00e9ritage de structure", 
            "title": "Introduction"
        }, 
        {
            "location": "/#polymorphisme-delement-mal", 
            "text": "Le livre MAL autorise l'utilisation du polymorphisme d'\u00e9l\u00e9ment \u00e0 condition qu'il ne soit appliqu\u00e9 qu'au dernier \u00e9l\u00e9ment d'un corps de message. Ce dernier \u00e9l\u00e9ment peut \u00eatre d\u00e9clar\u00e9 avec les types suivants :   MAL::Element  un type  Composite  abstrait  une liste d'\u00e9l\u00e9ments de type  MAL::Element  une liste d'\u00e9l\u00e9ments de type  Composite  abstrait  une liste d'\u00e9l\u00e9ments de type  MAL::Attribute   Les types list\u00e9s ci-dessus sont r\u00e9serv\u00e9s au polymorphisme du dernier \u00e9l\u00e9ment d'un corps de message. Ils ne peuvent pas \u00eatre utilis\u00e9s pour un champ de Composite.  Les listes d'\u00e9l\u00e9ments de type abstrait ( Composite ,  MAL::Element  ou  MAL::Attribute ) ne peuvent pas \u00eatre instanci\u00e9es : il n'y a pas de structure de liste pouvant contenir des \u00e9l\u00e9ments de type abstrait (et donc des \u00e9l\u00e9ments de plusieurs types conformes \u00e0 ce type abstrait). Par exemple :   List MAL::Element ,  List MAL::Attribute  ne peuvent pas \u00eatre instanci\u00e9es  List MAL::UpdateHeader ,  List MAL::Boolean  peuvent \u00eatre instanci\u00e9es   En cons\u00e9quence, une structure liste contient n\u00e9cessairement des \u00e9l\u00e9ments de m\u00eame type et de type non abstrait.", 
            "title": "Polymorphisme d'\u00e9l\u00e9ment MAL"
        }, 
        {
            "location": "/#polymorphisme-dattribut-mal", 
            "text": "Le livre MAL autorise l'utilisation du polymorphisme d'attribut pour le dernier \u00e9l\u00e9ment d'un corps de message et pour les champs de Composite.\nLe polymorphisme d'Attribut consiste \u00e0 d\u00e9clarer un \u00e9l\u00e9ment ou un champ avec le type MAL::Attribute.", 
            "title": "Polymorphisme d'Attribut MAL"
        }, 
        {
            "location": "/#concepts", 
            "text": "La plupart des concepts de l'API MAL en C sont impos\u00e9s par la sp\u00e9cification MAL : message MAL, champs de header, types de donn\u00e9es. Cependant, la sp\u00e9cification MAL ne d\u00e9finit pas certains concepts qui sont propres \u00e0 l'impl\u00e9mentation de la sp\u00e9cification. Cette section pr\u00e9sente uniquement ces concepts.", 
            "title": "Concepts"
        }, 
        {
            "location": "/#end-point", 
            "text": "Le end-point MAL est l'entit\u00e9 qui permet d'\u00e9mettre et de recevoir des messages MAL. Chaque end-point est associ\u00e9 \u00e0 une unique URI de service MAL, l'API MAL permet la cr\u00e9ation et la suppression dynamique de end-point.  Seul le end-point qui a re\u00e7u le message initiant une interaction peut r\u00e9pondre \u00e0 cette interaction.  Un end-point poss\u00e8de les caract\u00e9ristiques suivantes :   Il ne peut utiliser qu'un unique transport (binding) pour recevoir et envoyer des messages MAL.  Il peut utiliser plusieurs formats d'encodage du corps de message MAL.  Il est identifi\u00e9 de mani\u00e8re unique par une URI MAL relative au contexte MAL et dont le format d\u00e9pend du transport utilis\u00e9.  Il doit \u00eatre ex\u00e9cut\u00e9 de mani\u00e8re mono-thread\u00e9e.  Il g\u00e8re un compteur de  Transaction Id  (champ du header MAL).", 
            "title": "End-Point"
        }, 
        {
            "location": "/#poller", 
            "text": "Le poller MAL est une entit\u00e9 qui permet d'attendre l'arriv\u00e9e d'un message sur de multiples end-points. L'API MAL permet la cr\u00e9ation et la suppression dynamique de pollers, l'ajout et la suppression de end-point au poller.  Un poller poss\u00e8de les caract\u00e9ristiques suivantes :   L'ensemble des end-points d'un poller doivent d\u00e9pendre d'un m\u00eame contexte MAL et donc d'un unique transport (binding).  Il doit \u00eatre ex\u00e9cut\u00e9 de mani\u00e8re mono-thread\u00e9e.   L'usage du poller MAL n'est pas obligatoire, il est utile dans diff\u00e9rents cas :   Gestion de multiples end-points au travers d'un flot d'ex\u00e9cution unique,  R\u00e9ception non bloquante de messages.", 
            "title": "Poller"
        }, 
        {
            "location": "/#handler-et-routage", 
            "text": "Ces concepts sont offerts afin de faciliter la distribution des messages MAL re\u00e7us aux fonctions de traitement, leur utilisation est optionnelle.  Un Handler est un traitant d'interaction MAL, il s'ex\u00e9cute de mani\u00e8re asynchrone quand il est notifi\u00e9 de l'arriv\u00e9e d'un message MAL et envoie en retour z\u00e9ro, un ou plusieurs messages MAL, soit pour initier de nouvelles interactions (r\u00f4le du consumer), soit pour r\u00e9pondre \u00e0 l'interaction en cours (r\u00f4le du provider).  Chaque handler poss\u00e8de une interface d\u00e9pendant de son r\u00f4le (provider, consumer, etc.) et de l'interaction dans laquelle il intervient (send, submit, etc.). Par exemple pour une interaction Progress :   Le handler du provider doit offrir la fonction :  on_progress  Le handler du consumer doit offrir les fonctions :  on_ack ,  on_update  et  on_response .   Chacune de ces fonctions est appel\u00e9e avec les param\u00e8tres suivants :   un pointeur sur l'\u00e9tat du router (cf 7.6),  un pointeur sur le contexte MAL (cf 7.2),  un pointeur sur le end-point MAL (cf 7.4),  et un pointeur sur le message MAL (cf 7.3).   L'API MAL offre une classe helper (mal_routing) qui simplifie la gestion des Handlers d'un end-point donn\u00e9, cette classe mal_routing permet d'enregistrer les handlers correspondants aux diff\u00e9rentes interactions attendues, puis lors de la r\u00e9ception d'un message par le end-point d'activer le handler correspondant pour qu'il traite le message.  Les routeurs poss\u00e8dent un \u00e9tat partag\u00e9 par l'ensemble des handlers qu'ils g\u00e8rent.", 
            "title": "Handler et Routage"
        }, 
        {
            "location": "/#mal-broker", 
            "text": "Dans notre implantation du transport ZMQ le Publish/Subscribe est partiellement support\u00e9 par le transport ZMQ au travers des sockets PUB/SUB de ZMQ. Afin de respecter la s\u00e9mantique du pattern Publish/Subscribe du MAL il est cependant n\u00e9cessaire d'implanter un composant Broker g\u00e9rant les souscriptions et le filtrage des messages.  Afin de respecter le mode de fonctionnement de ZMQ ce composant Broker sera localis\u00e9 cot\u00e9 Consumer. Actuellement il est implant\u00e9 sous la forme d'un Handler (section 2.3) particulier que l'utilisateur de l'API peut modifier.", 
            "title": "MAL Broker"
        }, 
        {
            "location": "/#transformation-duri", 
            "text": "ZMQ peut utiliser de multiples protocoles sous-jacents pour communiquer. Par exemple des communications point-\u00e0-point peuvent passer par TCP entre des processus de machines diff\u00e9rentes, des IPC entre processus de la m\u00eame machine ou des m\u00e9canismes internes dans un m\u00eame processus. De m\u00eame, le Publish/Subscribe peut \u00eatre mis en \u0153uvre au travers de TCP, PGM ou EPGM.  Le transport MALZMQ utilise diff\u00e9rents flots de communication selon les interactions, dans notre prototype chaque contexte MAL \u00e9coute sur 2 sockets diff\u00e9rents :   Un socket  DEALER  pour les communications point-\u00e0-point  Un socket  SUB  pour les communications multicast.   Afin d'assurer la transformation de l'URI MAL d'un service en URI ZMQ n\u00e9cessaire \u00e0 la r\u00e9alisation d'une interaction et afin d'offrir \u00e0 l'utilisateur une grande libert\u00e9 de configuration nous avons choisi d'externaliser cette transformation au travers d'upcalls (section 12.2.1).", 
            "title": "Transformation d'URI"
        }, 
        {
            "location": "/#attributs-pointeurs", 
            "text": "Les attributs pointeurs sont les attributs MAL dont la repr\u00e9sentation en C est un type pointeur :  MAL::Blob ,  MAL::Identifier ,  MAL::String  et  MAL::URI .  Pour ces attributs, la valeur  NULL  (pointeur nul) est autoris\u00e9e.  Pour les autres attributs (non pointeurs), la valeur nulle est repr\u00e9sent\u00e9e par un champ additionnel (de type bool\u00e9en) appel\u00e9 \u00ab flag de pr\u00e9sence \u00bb.", 
            "title": "Attributs pointeurs"
        }, 
        {
            "location": "/#vue-densemble-de-lapi-c", 
            "text": "L'API C est constitu\u00e9e de plusieurs APIs :   API d'attribut MAL  : Les attributs MAL sont extraits de l'API MAL afin d'\u00e9viter une double-d\u00e9pendance entre l'API MAL (qui d\u00e9pend des APIs d'encodage) et les APIs d'encodage (qui d\u00e9pendent des attributs MAL).  APIs d'encodage  : Les APIs d'encodage sont d\u00e9finies de mani\u00e8re sp\u00e9cifique \u00e0 un format d'encodage.  API MAL  : L'API MAL permet l'utilisation des concepts de niveau MAL.  APIs d'Area  (g\u00e9n\u00e9r\u00e9es) : L'API MAL contient l'API d'Area g\u00e9n\u00e9r\u00e9e \u00e0 partir de la d\u00e9finition de l'Area MAL.  APIs de transport  : qui g\u00e8re le mapping des concepts MAL sur les concepts sous-jacents du transport choisi.  API d'extraction de param\u00e8tres de configuration .   La plupart des concepts sont repr\u00e9sent\u00e9s chacun par une classe conforme au mod\u00e8le Class de zproject :   une structure opaque (seul le type est visible, pas le contenu) d\u00e9clar\u00e9e dans le header principal de l'API ( api .h )  un fichier \u00ab include \u00bb :  nom de classe .h  un fichier \u00ab source \u00bb :  nom de classe .c   Les noms de classe sont en caract\u00e8res minuscules, avec s\u00e9parateur '_', et sont pr\u00e9fix\u00e9s du nom de l'API. Par exemple, le concept de end-point, d\u00e9fini dans l'API MAL, est repr\u00e9sent\u00e9 par une classe nomm\u00e9e :  mal_endpoint .  Les noms des classes repr\u00e9sentant des types de donn\u00e9es sont pr\u00e9fix\u00e9s des noms de leur Area et leur Service (si existant). Par exemple le type MAL::Blob (d\u00e9fini dans l'area MAL, sans Service interm\u00e9diaire) est nomm\u00e9 :  mal_blob .  Les autres conventions sont propres au mod\u00e8le  CLASS .", 
            "title": "Vue d'ensemble de l'API C"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Exemple simple d'application MAL\n\n\nCette section met en pratique les concepts de l'API MAL en C en programmant une application MAL tr\u00e8s simple qui s'ex\u00e9cute dans une unique fonction 'main'.\n\n\nDeux types de code sont distingu\u00e9s :\n\n\n\n\nle code des composants constituant l'application. Dans cet exemple, deux composants sont cr\u00e9\u00e9s. Pour simplifier l'application, chaque composant est limit\u00e9 \u00e0 un seul r\u00f4le : \u00ab provider \u00bb ou \u00ab consumer \u00bb de service. Un service de test tr\u00e8s simple est d\u00e9fini dans une area de service nomm\u00e9e \u00ab TestArea \u00bb (voir section 14.1).\n\n\nle code de lancement de l'application\n\n\n\n\nLe code des composants ne d\u00e9pend que de l'API MAL et de l'API g\u00e9n\u00e9r\u00e9e \u00e0 partir de la d\u00e9finition de TestArea.\n\n\nLe code de lancement de l'application (fonction 'main') d\u00e9pend de l'API MAL et \u00e9galement de l'API de transport 'malzmq'.\n\n\nCet exemple utilise le mod\u00e8le d'ex\u00e9cution des acteurs CZMQ.\n\n\nSeul le code non g\u00e9n\u00e9r\u00e9 est pr\u00e9sent\u00e9 dans les sections suivantes.\n\n\nComposant \u00ab consumer \u00bb\n\n\nD\u00e9pendances avec l'API MAL et l'API du service (code g\u00e9n\u00e9r\u00e9) :\n\n\n#include \"mal.h\"\n#include \"testarea.h\"\n\n\n\nConstructeur\n\n\nDans cet exemple de code, tous les param\u00e8tres n\u00e9cessaires au fonctionnement du consumer sont  donn\u00e9s lors de sa cr\u00e9ation :\n\n\n\n\nle end-point du consumer\n\n\nl'URI du provider (auquel le consumer s'adresse)\n\n\nles param\u00e8tres de l'ent\u00eate de message MAL, par exemple l'identifiant d'authentification\n\n\nl'identifiant du format d'encodage\n\n\nles contextes d'encodage (non typ\u00e9s pour \u00e9viter la d\u00e9pendance avec 'malbinary')\n\n\n\n\nD\u00e9claration :\n\n\n    simple_app_myconsumer_t *simple_app_myconsumer_new(\n      mal_endpoint_t *endpoint,\n      mal_uri_t *provider_uri,\n      mal_blob_t *authentication_id,\n      mal_qoslevel_t qoslevel,\n      mal_uinteger_t priority,\n      mal_identifier_list_t *domain,\n      mal_identifier_t *network_zone,\n      mal_sessiontype_t session,\n      mal_identifier_t *session_name,\n      int encoding_format_code,\n      void *encoder, void *decoder);\n\n\n\n\nImpl\u00e9mentation\n\n\nDans cet exemple un acteur CZMQ li\u00e9 au composant \u00ab consumer \u00bb initie une interaction MAL lors de son d\u00e9marrage. La signature doit \u00eatre conforme \u00e0 la fonction virtuelle de l'acteur d\u00e9finie dans l'API CZMQ :\n\n\n    void simple_app_myconsumer_run(zsock_t *pipe, void *self) {\n\n\n\n\nLa r\u00e9f\u00e9rence \nself\n est cast\u00e9e pour obtenir l'\u00e9tat de l'acteur (le \u00ab consumer \u00bb):\n\n\n    simple_app_myconsumer_t *consumer = (simple_app_myconsumer_t *) self;\n\n\n\n\nL'URI du provider est r\u00e9cup\u00e9r\u00e9e \u00e0 partir de l'\u00e9tat du consumer :\n\n\n    mal_uri_t *uri_to = consumer-\nprovider_uri;\n\n\n\n\nUne structure de donn\u00e9e \nTestComposite\n est instanci\u00e9e :\n\n\n    testarea_testservice_testcomposite_t *testcomposite =\n      testarea_testservice_testcomposite_new();\n\n\n\n\nAllocation d'une String MAL \u00e0 partir de la cha\u00eene statique \u00ab hello world \u00bb :\n\n\n    mal_string_t *str = mal_string_new(\nhello world\n);\n\n\n\n\nAffectation du champ \nstringField\n :\n\n\n    testarea_testservice_testcomposite_set_stringfield(testcomposite, str);\n\n\n\n\nA partir de ce point la structure testcomposite est responsable de la lib\u00e9ration de la String str. R\u00e9ciproquement l'usage de la String n'est possible que tant que la structure n'a pas \u00e9t\u00e9 lib\u00e9r\u00e9e.\n\n\nLe champ \nintField\n peut \u00eatre nul. Il est donc n\u00e9cessaire d'affecter le flag de pr\u00e9sence pour ce champ (\u00e0 la valeur \ntrue\n), puis d'affecter la valeur du champ (\n10\n) :\n\n\n    testarea_testservice_testcomposite_intfield_set_present(\n      testcomposite,\n      true);\n    testarea_testservice_testcomposite_set_intfield(testcomposite, 10);\n\n\n\n\nUne structure de donn\u00e9e \nList\nMAL::String\n est instanci\u00e9e :\n\n\n    mal_string_list_t *string_list = mal_string_list_new(2);\n    mal_string_t **string_list_content =\n      mal_string_list_get_content(string_list);\n    string_list_content[0] = mal_string_new(\nlist-element-1\n);\n    string_list_content[1] = mal_string_new(\nlist-element-2\n);\n\n\n\n\nPour tester le polymorphisme, une structure \nTestFinalCompositeA\n est instanci\u00e9e (elle h\u00e9rite de \nTestAbstractComposite\n) :\n\n\n    testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n      testarea_testservice_testfinalcompositea_new();\n    testarea_testservice_testfinalcompositea_set_intfield(\n      testfinalcompositea, 20);\n    testarea_testservice_testfinalcompositea_set_intfield2(\n      testfinalcompositea, 30);\n\n\n\n\nLa taille du corps de message encod\u00e9 est calcul\u00e9e en faisant appel \u00e0 une fonction g\u00e9n\u00e9r\u00e9e pour chaque \u00e9l\u00e9ment du corps de message.\n\n\nCalcul de la taille d'encodage du premier \u00e9l\u00e9ment (index '0' pour l'initiation de l'\u00e9tape \nsend\n de l'op\u00e9ration \ntestSend\n) :\n\n\n    unsigned int body_length = 0;\n    rc = testarea_testservice_testsend_send_add_encoding_length_0(\n      consumer-\nencoding_format_code,\n      consumer-\nencoder, testcomposite, \nbody_length);\n\n\n\n\nCalcul de la taille d'encodage du deuxi\u00e8me \u00e9l\u00e9ment (index '1') :\n\n\n    rc = testarea_testservice_testsend_send_add_encoding_length_1(\n      consumer-\nencoding_format_code,\n      consumer-\nencoder, string_list, \nbody_length);\n\n\n\n\nCalcul de la taille d'encodage du troisi\u00e8me \u00e9l\u00e9ment (index '2'), avec polymorphisme :\n\n\n    rc = testarea_testservice_testsend_send_add_encoding_length_2_testarea_\n    testservice_testfinalcompositea(\n      consumer-\nencoding_format_code,\n      consumer-\nencoder, testfinalcompositea, \nbody_length);\n\n\n\n\nCr\u00e9ation d'un message MAL, avec passage en param\u00e8tre :\n\n\n\n\ndes champs de header MAL contenus dans l'\u00e9tat du Handler\n\n\nde la taille d'encodage du corps de message : \nbody_length\n\n\n\n\n    mal_message_t *message = mal_message_new(uri_to,\n      consumer-\nauthentication_id,\n      consumer-\nqoslevel, consumer-\npriority, consumer-\ndomain,\n      consumer-\nnetwork_zone, consumer-\nsession, consumer-\nsession_name,\n      body_length);\n\n\n\n\nEncodage du premier \u00e9l\u00e9ment (index '0') :\n\n\n    unsigned int offset = mal_message_get_body_offset(message);\n    char *bytes = mal_message_get_body(message);\n    rc = testarea_testservice_testsend_send_encode_0(\n      consumer-\nencoding_format_code, bytes, \noffset,\n      consumer-\nencoder, testcomposite);\n\n\n\n\nEncodage du deuxi\u00e8me \u00e9l\u00e9ment (index '1') :\n\n\n    rc = testarea_testservice_testsend_send_encode_1(\n      consumer-\nencoding_format_code, bytes, \noffset,\n      consumer-\nencoder, string_list);\n\n\n\n\nEncodage du troisi\u00e8me \u00e9l\u00e9ment (index '2') :\n\n\n    rc = testarea_testservice_testsend_send_encode_2_testarea_testservice_\n    testfinalcompositea(\n      consumer-\nencoding_format_code, bytes, \noffset,\n      consumer-\nencoder, testfinalcompositea);\n\n\n\n\nEnvoi du message (initiation de l'\u00e9tape \nsend\n de l'op\u00e9ration \ntestSend\n) :\n\n\n    rc = testarea_testservice_testsend_send(\n      consumer-\nendpoint,\n      message,\n      consumer-\nprovider_uri);\n\n\n\n\nDestruction des donn\u00e9es allou\u00e9es :\n\n\n    testarea_testservice_testcomposite_destroy(\ntestcomposite);\n    mal_string_list_destroy(\nstring_list);\n    testarea_testservice_testfinalcompositea_destroy(\ntestfinalcompositea);\n\n\n\n\nComposant \u00ab provider \u00bb\n\n\nD\u00e9pendances avec l'API MAL et l'API du service (code g\u00e9n\u00e9r\u00e9) :\n\n\n#include \"mal.h\"\n#include \"testarea.h\"\n\n\n\nConstructeur\n\n\nDans cet exemple de code, tous les param\u00e8tres n\u00e9cessaires au fonctionnement du provider sont  donn\u00e9s lors de sa cr\u00e9ation :\n  - le end-point MAL du provider\n  - l'identifiant du format d'encodage\n  - les contextes d'encodage (non typ\u00e9s pour \u00e9viter la d\u00e9pendance avec 'malbinary')\n\n\nD\u00e9claration :\n\n\nsimple_app_myprovider_t simple_app_myprovider_new(\n  mal_endpoint_t *endpoint,\n  int encoding_format_code,\n  void *encoder, void *decoder);\n\n\n\nImpl\u00e9mentation\n\n\nDans cet exemple un acteur CZMQ est li\u00e9 au composant \u00ab provider \u00bb et enregistre un handler  lors de son d\u00e9marrage. La signature doit \u00eatre conforme \u00e0 la fonction virtuelle de l'acteur d\u00e9finie dans l'API CZMQ :\n\n\nvoid simple_app_myprovider_run(zsock_t *pipe, void *self) {\nAfin de faciliter la distribution des messages un routeur est cr\u00e9\u00e9 :\nmal_routing_t *router = mal_routing_new(self-\nendpoint, self);\n\n\n\nPuis pour permettre son fonctionnement un handler correspondant au r\u00f4le provider de l'interaction Send doit \u00eatre dynamiquement enregistr\u00e9 au pr\u00e8s de l'acteur :\n\n\nrc = mal_routing_register_provider_send_handler(\n     router,\n     TESTAREA_AREA_NUMBER,\n     TESTAREA_AREA_VERSION,\n     TESTAREA_TESTSERVICE_SERVICE_NUMBER,\n     TESTAREA_TESTSERVICE_TESTSEND_OPERATION_NUMBER,\n     simple_app_myprovider_testarea_testservice_testsend);\n\n\n\nCes appels sont r\u00e9alis\u00e9s dans la fonction d'initialisation de l'acteur.\nEnfin l'acteur se met en attente de r\u00e9ception d'un message sur le end-point :\n\n\nmal_message_t *message = NULL;\nrc = mal_endpoint_recv_message(self-\nendpoint, \nmessage);\n\n\n\nPuis il demande l'activation du handler correspondant au travers du routeur et d\u00e9truit ce message si il n'a pu \u00eatre trait\u00e9 par aucun handler :\n\n\nif (message != NULL) {\n  rc = mal_routing_handle(router, message);\n  if (rc != 0)\n    mal_message_destroy(\n      message,\n      mal_endpoint_get_mal_ctx(self-\nendpoint));\n\n\n\nLe handler peut alors r\u00e9agir \u00e0 la r\u00e9ception du message MAL correspondant via la fonction correspondante dont la signature doit \u00eatre conforme \u00e0 la fonction virtuelle de Handler d\u00e9finie dans l'API MAL (voir section 7.6.1). Le code de dispatch renvoie donc vers une fonction sp\u00e9cifique au traitement de l'op\u00e9ration 'testSend'. :\n\n\nint simple_app_myprovider_testarea_testservice_testsend(\n  void *self,\n  mal_ctx_t *mal_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message) {\n\n\n\nLa r\u00e9f\u00e9rence 'self' est cast\u00e9e pour obtenir l'\u00e9tat du router commun \u00e0 tous les handlers enregistr\u00e9s (le \u00ab provider \u00bb):\n\n\n  simple_app_myprovider_t *provider = (simple_app_myprovider_t *) self;\n\n\n\nD\u00e9codage du premier \u00e9l\u00e9ment du corps de message :\n\n\n  testarea_testservice_testcomposite_t *parameter_0 = NULL;\n  unsigned int offset = mal_message_get_body_offset(message);\n  char *bytes = mal_message_get_body(message);\n  rc = testarea_testservice_testsend_send_decode_0(\n    provider-\nencoding_format_code, bytes, \noffset,\n    provider-\ndecoder, \nparameter_0);\n  if (rc \n 0) {\n    // destruction des param\u00e8tres d\u00e9cod\u00e9s (voir plus bas)\n    return rc;\n  }\n\n\n\nD\u00e9codage du deuxi\u00e8me \u00e9l\u00e9ment du corps de message :\n\n\n  mal_string_list_t *parameter_1;\n  rc = testarea_testservice_testsend_send_decode_1(\n    provider-\nencoding_format_code, bytes, \noffset,\n    provider-\ndecoder, \nparameter_1);\n  if (rc \n 0) {\n    // destruction des param\u00e8tres d\u00e9cod\u00e9s (voir plus bas)\n    return rc;\n  }\n\n\n\nD\u00e9codage du troisi\u00e8me \u00e9l\u00e9ment du corps de message (avec polymorphisme) :\n\n\n  mal_element_holder_t parameter_2;\n  rc = testarea_testservice_testsend_send_decode_2(\n    provider-\nencoding_format_code, bytes, \noffset,\n    provider-\ndecoder, \nparameter_2);\n  if (rc \n 0) {\n    // destruction des param\u00e8tres d\u00e9cod\u00e9s (voir plus bas)\n    return rc;\n  }\n\n\n\nLa valeur des param\u00e8tres d\u00e9cod\u00e9s peut \u00eatre nulle.\n\n\nLe troisi\u00e8me param\u00e8tre n\u00e9cessite de tester la valeur du 'short_form' avant de faire le cast :\n\n\nif (parameter_2.presence_flag \n parameter_2.short_form ==\n    TESTAREA_TESTSERVICE_TESTFINALCOMPOSITEA_SHORT_FORM) {\n  testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n    (testarea_testservice_testfinalcompositea_t *) parameter_2;\n  ...\n\n\n\nDestruction de la donn\u00e9e :\n\n\n  testarea_testservice_testfinalcompositea_destroy(\ntestfinalcompositea);\n\n\n\nFin du traitement du troisi\u00e8me param\u00e8tre :\n\n\n}\n\n\n\nEnfin, les premier et deuxi\u00e8me param\u00e8tres sont d\u00e9truits :\n\n\n  testarea_testservice_testcomposite_destroy(\nparameter_0);\n  mal_string_list_destroy(\nparameter_1);\n\n\n\nLe message est \u00e9galement d\u00e9truit :\n\n\nmal_message_destroy(\nmessage, mal_ctx);\n\n\n\nLancement de l'application\n\n\nLes d\u00e9pendances n\u00e9cessaires sont :\n  - l'API MAL\n  - l'API du transport MALZMQ\n\n\n#include \"mal.h\"\n#include \"malzmq.h\"\n\n\n\nCr\u00e9ation d'un contexte MAL :\n\n\nmal_ctx_t *mal_ctx = mal_ctx_new();\n\n\n\nLes contextes d'encodage et de d\u00e9codage sont cr\u00e9\u00e9s pour le format 'malbinary'. Le format 'varint' n'est pas utilis\u00e9 et le flag 'verbose' est activ\u00e9 :\n\n\nmalbinary_encoder_t *encoder = malbinary_encoder_new(false, true);\nmalbinary_decoder_t *decoder = malbinary_decoder_new(false, true);\n\n\n\nConfiguration du catalogue de mapping (cf 12.1.3) et des flags de pr\u00e9sence (cf 12.1.2) dans le header MALZMQ : dans l'exemple il n'y a pas de catalogue et tous les champs optionnels sont pr\u00e9sents (encod\u00e9s) dans le header.\n\n\nmalzmq_header_t *malzmq_header = malzmq_header_new(NULL, true, 0, true, NULL,\n  NULL, NULL, NULL);\n\n\n\nUn contexte de transport MALZMQ est cr\u00e9\u00e9 \u00e0 partir du contexte MAL. Une fonction de mapping d'URI est fournie (cf 12.2). Dans l'exemple on utilise la fonction par d\u00e9faut. L'adresse et le port d'\u00e9coute de connexions entrantes sont 'localhost' et 5555.\n\n\nmalzmq_ctx_t *malzmq_ctx = malzmq_ctx_new(\n  mal_ctx, NULL,\n  \"localhost\", \"5555\",\n  malzmq_header,\n  encoder, decoder,\n  true);\n\n\n\nCr\u00e9ation du provider\n\n\nAllocation d'une URI MALZMQ. Un nom unique (dans le contexte MALZMQ) est pass\u00e9 en param\u00e8tre.\n\n\nmal_uri_t *provider_uri =\n  mal_ctx_create_uri(mal_ctx, \"simple_app/myprovider\");\n\n\n\nCr\u00e9ation du end-point du provider avec les param\u00e8tres suivants :\n  - la r\u00e9f\u00e9rence du contexte MAL,\n  - l'URI du provider allou\u00e9e pr\u00e9c\u00e9demment.\n\n\nmal_endpoint_t *provider_endpoint = mal_endpoint_new(mal_ctx, provider_uri);\n\n\n\nInstanciation du provider avec la r\u00e9f\u00e9rence du end-point correspondant et les param\u00e8tres li\u00e9s \u00e0 l'encodage :\n\n\nsimple_app_myprovider_t *provider = simple_app_myprovider_new(\n  provider_endpoint,\n  MALBINARY_FORMAT_CODE,\n  encoder, decoder);\n\n\n\nL'enregistrement du handler de l'op\u00e9ration sera effectu\u00e9e dans la fonction run de l'acteur CZMQ (voir section 4.2.2).\n\n\nCr\u00e9ation du consumer\n\n\nAllocation d'une URI MALZMQ. Un nom unique (dans le contexte MALZMQ) est pass\u00e9 en param\u00e8tre.\n\n\nmal_uri_t *consumer_uri =\n  mal_ctx_create_uri(mal_ctx, \"simple_app/myconsumer\");\n\n\n\nCr\u00e9ation du end-point du consumer avec les param\u00e8tres suivants :\n  - la r\u00e9f\u00e9rence du contexte MAL,\n  - l'URI du consumer allou\u00e9e pr\u00e9c\u00e9demment.\n\n\nmal_endpoint_t *consumer_endpoint = mal_endpoint_new(mal_ctx, consumer_uri);\n\n\n\nL'instanciation du consumer n\u00e9cessite de d\u00e9terminer certains param\u00e8tres du Header de message MAL :\n\n\nmal_blob_t *authentication_id = mal_blob_new(0);\nmal_qoslevel_t qoslevel = MAL_QOSLEVEL_ASSURED;\nmal_uinteger_t priority = 4;\nmal_identifier_list_t *domain = mal_identifier_list_new(0);\nmal_identifier_t *network_zone = mal_identifier_new(\"Network Zone\");\nmal_sessiontype_t session = MAL_SESSIONTYPE_LIVE;\nmal_identifier_t *session_name = mal_identifier_new(\"LIVE\");\n\nsimple_app_myconsumer_t *consumer =\nsimple_app_myconsumer_new(provider_uri,\n  authentication_id, qoslevel, priority, domain, network_zone, session,\n  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);\n\n\n\nLes m\u00eames contextes d'encodage et de d\u00e9codage que ceux du provider sont utilis\u00e9s par le consumer.\n\n\nL'op\u00e9ration Send ne n\u00e9cessitant pas de handler cot\u00e9 consumer il n'y aura pas d'enregistrement de handler pour ce consumer.\n\n\nLancement et fin de l'application\n\n\nCr\u00e9ation du provider et de l'acteur ZMQ correspondant :\n\n\nprovider = simple_app_create_provider(\n  verbose,\n  mal_ctx, provider_uri,\n  encoder, decoder);\nzactor_t *provider_actor = zactor_new(simple_app_myprovider_run, provider);\n\n\n\nCr\u00e9ation du consumer et de l'acteur ZMQ correspondant :\n\n\nconsumer = simple_app_create_consumer(\n  verbose,\n  mal_ctx, provider_uri,\n  encoder, decoder);\nzactor_t *consumer_actor = zactor_new(simple_app_myconsumer_run, consumer);\n\n\n\nD\u00e9marrage du contexte MALZMQ (appel bloquant jusqu'\u00e0 l'interruption du contexte) :\n\n\n  malzmq_ctx_start(malzmq_ctx);\n\n\n\nDestruction des contextes MAL et MALZMQ :\n\n\n  mal_ctx_destroy(\nmal_ctx);\n  malzmq_ctx_destroy(\nmalzmq_ctx);", 
            "title": "Tutoriel"
        }, 
        {
            "location": "/tutorial/#exemple-simple-dapplication-mal", 
            "text": "Cette section met en pratique les concepts de l'API MAL en C en programmant une application MAL tr\u00e8s simple qui s'ex\u00e9cute dans une unique fonction 'main'.  Deux types de code sont distingu\u00e9s :   le code des composants constituant l'application. Dans cet exemple, deux composants sont cr\u00e9\u00e9s. Pour simplifier l'application, chaque composant est limit\u00e9 \u00e0 un seul r\u00f4le : \u00ab provider \u00bb ou \u00ab consumer \u00bb de service. Un service de test tr\u00e8s simple est d\u00e9fini dans une area de service nomm\u00e9e \u00ab TestArea \u00bb (voir section 14.1).  le code de lancement de l'application   Le code des composants ne d\u00e9pend que de l'API MAL et de l'API g\u00e9n\u00e9r\u00e9e \u00e0 partir de la d\u00e9finition de TestArea.  Le code de lancement de l'application (fonction 'main') d\u00e9pend de l'API MAL et \u00e9galement de l'API de transport 'malzmq'.  Cet exemple utilise le mod\u00e8le d'ex\u00e9cution des acteurs CZMQ.  Seul le code non g\u00e9n\u00e9r\u00e9 est pr\u00e9sent\u00e9 dans les sections suivantes.", 
            "title": "Exemple simple d'application MAL"
        }, 
        {
            "location": "/tutorial/#composant-consumer", 
            "text": "D\u00e9pendances avec l'API MAL et l'API du service (code g\u00e9n\u00e9r\u00e9) :  #include \"mal.h\"\n#include \"testarea.h\"", 
            "title": "Composant \u00ab consumer \u00bb"
        }, 
        {
            "location": "/tutorial/#constructeur", 
            "text": "Dans cet exemple de code, tous les param\u00e8tres n\u00e9cessaires au fonctionnement du consumer sont  donn\u00e9s lors de sa cr\u00e9ation :   le end-point du consumer  l'URI du provider (auquel le consumer s'adresse)  les param\u00e8tres de l'ent\u00eate de message MAL, par exemple l'identifiant d'authentification  l'identifiant du format d'encodage  les contextes d'encodage (non typ\u00e9s pour \u00e9viter la d\u00e9pendance avec 'malbinary')   D\u00e9claration :      simple_app_myconsumer_t *simple_app_myconsumer_new(\n      mal_endpoint_t *endpoint,\n      mal_uri_t *provider_uri,\n      mal_blob_t *authentication_id,\n      mal_qoslevel_t qoslevel,\n      mal_uinteger_t priority,\n      mal_identifier_list_t *domain,\n      mal_identifier_t *network_zone,\n      mal_sessiontype_t session,\n      mal_identifier_t *session_name,\n      int encoding_format_code,\n      void *encoder, void *decoder);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/tutorial/#implementation", 
            "text": "Dans cet exemple un acteur CZMQ li\u00e9 au composant \u00ab consumer \u00bb initie une interaction MAL lors de son d\u00e9marrage. La signature doit \u00eatre conforme \u00e0 la fonction virtuelle de l'acteur d\u00e9finie dans l'API CZMQ :      void simple_app_myconsumer_run(zsock_t *pipe, void *self) {  La r\u00e9f\u00e9rence  self  est cast\u00e9e pour obtenir l'\u00e9tat de l'acteur (le \u00ab consumer \u00bb):      simple_app_myconsumer_t *consumer = (simple_app_myconsumer_t *) self;  L'URI du provider est r\u00e9cup\u00e9r\u00e9e \u00e0 partir de l'\u00e9tat du consumer :      mal_uri_t *uri_to = consumer- provider_uri;  Une structure de donn\u00e9e  TestComposite  est instanci\u00e9e :      testarea_testservice_testcomposite_t *testcomposite =\n      testarea_testservice_testcomposite_new();  Allocation d'une String MAL \u00e0 partir de la cha\u00eene statique \u00ab hello world \u00bb :      mal_string_t *str = mal_string_new( hello world );  Affectation du champ  stringField  :      testarea_testservice_testcomposite_set_stringfield(testcomposite, str);  A partir de ce point la structure testcomposite est responsable de la lib\u00e9ration de la String str. R\u00e9ciproquement l'usage de la String n'est possible que tant que la structure n'a pas \u00e9t\u00e9 lib\u00e9r\u00e9e.  Le champ  intField  peut \u00eatre nul. Il est donc n\u00e9cessaire d'affecter le flag de pr\u00e9sence pour ce champ (\u00e0 la valeur  true ), puis d'affecter la valeur du champ ( 10 ) :      testarea_testservice_testcomposite_intfield_set_present(\n      testcomposite,\n      true);\n    testarea_testservice_testcomposite_set_intfield(testcomposite, 10);  Une structure de donn\u00e9e  List MAL::String  est instanci\u00e9e :      mal_string_list_t *string_list = mal_string_list_new(2);\n    mal_string_t **string_list_content =\n      mal_string_list_get_content(string_list);\n    string_list_content[0] = mal_string_new( list-element-1 );\n    string_list_content[1] = mal_string_new( list-element-2 );  Pour tester le polymorphisme, une structure  TestFinalCompositeA  est instanci\u00e9e (elle h\u00e9rite de  TestAbstractComposite ) :      testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n      testarea_testservice_testfinalcompositea_new();\n    testarea_testservice_testfinalcompositea_set_intfield(\n      testfinalcompositea, 20);\n    testarea_testservice_testfinalcompositea_set_intfield2(\n      testfinalcompositea, 30);  La taille du corps de message encod\u00e9 est calcul\u00e9e en faisant appel \u00e0 une fonction g\u00e9n\u00e9r\u00e9e pour chaque \u00e9l\u00e9ment du corps de message.  Calcul de la taille d'encodage du premier \u00e9l\u00e9ment (index '0' pour l'initiation de l'\u00e9tape  send  de l'op\u00e9ration  testSend ) :      unsigned int body_length = 0;\n    rc = testarea_testservice_testsend_send_add_encoding_length_0(\n      consumer- encoding_format_code,\n      consumer- encoder, testcomposite,  body_length);  Calcul de la taille d'encodage du deuxi\u00e8me \u00e9l\u00e9ment (index '1') :      rc = testarea_testservice_testsend_send_add_encoding_length_1(\n      consumer- encoding_format_code,\n      consumer- encoder, string_list,  body_length);  Calcul de la taille d'encodage du troisi\u00e8me \u00e9l\u00e9ment (index '2'), avec polymorphisme :      rc = testarea_testservice_testsend_send_add_encoding_length_2_testarea_\n    testservice_testfinalcompositea(\n      consumer- encoding_format_code,\n      consumer- encoder, testfinalcompositea,  body_length);  Cr\u00e9ation d'un message MAL, avec passage en param\u00e8tre :   des champs de header MAL contenus dans l'\u00e9tat du Handler  de la taille d'encodage du corps de message :  body_length       mal_message_t *message = mal_message_new(uri_to,\n      consumer- authentication_id,\n      consumer- qoslevel, consumer- priority, consumer- domain,\n      consumer- network_zone, consumer- session, consumer- session_name,\n      body_length);  Encodage du premier \u00e9l\u00e9ment (index '0') :      unsigned int offset = mal_message_get_body_offset(message);\n    char *bytes = mal_message_get_body(message);\n    rc = testarea_testservice_testsend_send_encode_0(\n      consumer- encoding_format_code, bytes,  offset,\n      consumer- encoder, testcomposite);  Encodage du deuxi\u00e8me \u00e9l\u00e9ment (index '1') :      rc = testarea_testservice_testsend_send_encode_1(\n      consumer- encoding_format_code, bytes,  offset,\n      consumer- encoder, string_list);  Encodage du troisi\u00e8me \u00e9l\u00e9ment (index '2') :      rc = testarea_testservice_testsend_send_encode_2_testarea_testservice_\n    testfinalcompositea(\n      consumer- encoding_format_code, bytes,  offset,\n      consumer- encoder, testfinalcompositea);  Envoi du message (initiation de l'\u00e9tape  send  de l'op\u00e9ration  testSend ) :      rc = testarea_testservice_testsend_send(\n      consumer- endpoint,\n      message,\n      consumer- provider_uri);  Destruction des donn\u00e9es allou\u00e9es :      testarea_testservice_testcomposite_destroy( testcomposite);\n    mal_string_list_destroy( string_list);\n    testarea_testservice_testfinalcompositea_destroy( testfinalcompositea);", 
            "title": "Impl\u00e9mentation"
        }, 
        {
            "location": "/tutorial/#composant-provider", 
            "text": "D\u00e9pendances avec l'API MAL et l'API du service (code g\u00e9n\u00e9r\u00e9) :  #include \"mal.h\"\n#include \"testarea.h\"", 
            "title": "Composant \u00ab provider \u00bb"
        }, 
        {
            "location": "/tutorial/#constructeur_1", 
            "text": "Dans cet exemple de code, tous les param\u00e8tres n\u00e9cessaires au fonctionnement du provider sont  donn\u00e9s lors de sa cr\u00e9ation :\n  - le end-point MAL du provider\n  - l'identifiant du format d'encodage\n  - les contextes d'encodage (non typ\u00e9s pour \u00e9viter la d\u00e9pendance avec 'malbinary')  D\u00e9claration :  simple_app_myprovider_t simple_app_myprovider_new(\n  mal_endpoint_t *endpoint,\n  int encoding_format_code,\n  void *encoder, void *decoder);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/tutorial/#implementation_1", 
            "text": "Dans cet exemple un acteur CZMQ est li\u00e9 au composant \u00ab provider \u00bb et enregistre un handler  lors de son d\u00e9marrage. La signature doit \u00eatre conforme \u00e0 la fonction virtuelle de l'acteur d\u00e9finie dans l'API CZMQ :  void simple_app_myprovider_run(zsock_t *pipe, void *self) {\nAfin de faciliter la distribution des messages un routeur est cr\u00e9\u00e9 :\nmal_routing_t *router = mal_routing_new(self- endpoint, self);  Puis pour permettre son fonctionnement un handler correspondant au r\u00f4le provider de l'interaction Send doit \u00eatre dynamiquement enregistr\u00e9 au pr\u00e8s de l'acteur :  rc = mal_routing_register_provider_send_handler(\n     router,\n     TESTAREA_AREA_NUMBER,\n     TESTAREA_AREA_VERSION,\n     TESTAREA_TESTSERVICE_SERVICE_NUMBER,\n     TESTAREA_TESTSERVICE_TESTSEND_OPERATION_NUMBER,\n     simple_app_myprovider_testarea_testservice_testsend);  Ces appels sont r\u00e9alis\u00e9s dans la fonction d'initialisation de l'acteur.\nEnfin l'acteur se met en attente de r\u00e9ception d'un message sur le end-point :  mal_message_t *message = NULL;\nrc = mal_endpoint_recv_message(self- endpoint,  message);  Puis il demande l'activation du handler correspondant au travers du routeur et d\u00e9truit ce message si il n'a pu \u00eatre trait\u00e9 par aucun handler :  if (message != NULL) {\n  rc = mal_routing_handle(router, message);\n  if (rc != 0)\n    mal_message_destroy(\n      message,\n      mal_endpoint_get_mal_ctx(self- endpoint));  Le handler peut alors r\u00e9agir \u00e0 la r\u00e9ception du message MAL correspondant via la fonction correspondante dont la signature doit \u00eatre conforme \u00e0 la fonction virtuelle de Handler d\u00e9finie dans l'API MAL (voir section 7.6.1). Le code de dispatch renvoie donc vers une fonction sp\u00e9cifique au traitement de l'op\u00e9ration 'testSend'. :  int simple_app_myprovider_testarea_testservice_testsend(\n  void *self,\n  mal_ctx_t *mal_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message) {  La r\u00e9f\u00e9rence 'self' est cast\u00e9e pour obtenir l'\u00e9tat du router commun \u00e0 tous les handlers enregistr\u00e9s (le \u00ab provider \u00bb):    simple_app_myprovider_t *provider = (simple_app_myprovider_t *) self;  D\u00e9codage du premier \u00e9l\u00e9ment du corps de message :    testarea_testservice_testcomposite_t *parameter_0 = NULL;\n  unsigned int offset = mal_message_get_body_offset(message);\n  char *bytes = mal_message_get_body(message);\n  rc = testarea_testservice_testsend_send_decode_0(\n    provider- encoding_format_code, bytes,  offset,\n    provider- decoder,  parameter_0);\n  if (rc   0) {\n    // destruction des param\u00e8tres d\u00e9cod\u00e9s (voir plus bas)\n    return rc;\n  }  D\u00e9codage du deuxi\u00e8me \u00e9l\u00e9ment du corps de message :    mal_string_list_t *parameter_1;\n  rc = testarea_testservice_testsend_send_decode_1(\n    provider- encoding_format_code, bytes,  offset,\n    provider- decoder,  parameter_1);\n  if (rc   0) {\n    // destruction des param\u00e8tres d\u00e9cod\u00e9s (voir plus bas)\n    return rc;\n  }  D\u00e9codage du troisi\u00e8me \u00e9l\u00e9ment du corps de message (avec polymorphisme) :    mal_element_holder_t parameter_2;\n  rc = testarea_testservice_testsend_send_decode_2(\n    provider- encoding_format_code, bytes,  offset,\n    provider- decoder,  parameter_2);\n  if (rc   0) {\n    // destruction des param\u00e8tres d\u00e9cod\u00e9s (voir plus bas)\n    return rc;\n  }  La valeur des param\u00e8tres d\u00e9cod\u00e9s peut \u00eatre nulle.  Le troisi\u00e8me param\u00e8tre n\u00e9cessite de tester la valeur du 'short_form' avant de faire le cast :  if (parameter_2.presence_flag   parameter_2.short_form ==\n    TESTAREA_TESTSERVICE_TESTFINALCOMPOSITEA_SHORT_FORM) {\n  testarea_testservice_testfinalcompositea_t *testfinalcompositea =\n    (testarea_testservice_testfinalcompositea_t *) parameter_2;\n  ...  Destruction de la donn\u00e9e :    testarea_testservice_testfinalcompositea_destroy( testfinalcompositea);  Fin du traitement du troisi\u00e8me param\u00e8tre :  }  Enfin, les premier et deuxi\u00e8me param\u00e8tres sont d\u00e9truits :    testarea_testservice_testcomposite_destroy( parameter_0);\n  mal_string_list_destroy( parameter_1);  Le message est \u00e9galement d\u00e9truit :  mal_message_destroy( message, mal_ctx);", 
            "title": "Impl\u00e9mentation"
        }, 
        {
            "location": "/tutorial/#lancement-de-lapplication", 
            "text": "Les d\u00e9pendances n\u00e9cessaires sont :\n  - l'API MAL\n  - l'API du transport MALZMQ  #include \"mal.h\"\n#include \"malzmq.h\"", 
            "title": "Lancement de l'application"
        }, 
        {
            "location": "/tutorial/#creation-dun-contexte-mal", 
            "text": "mal_ctx_t *mal_ctx = mal_ctx_new();  Les contextes d'encodage et de d\u00e9codage sont cr\u00e9\u00e9s pour le format 'malbinary'. Le format 'varint' n'est pas utilis\u00e9 et le flag 'verbose' est activ\u00e9 :  malbinary_encoder_t *encoder = malbinary_encoder_new(false, true);\nmalbinary_decoder_t *decoder = malbinary_decoder_new(false, true);  Configuration du catalogue de mapping (cf 12.1.3) et des flags de pr\u00e9sence (cf 12.1.2) dans le header MALZMQ : dans l'exemple il n'y a pas de catalogue et tous les champs optionnels sont pr\u00e9sents (encod\u00e9s) dans le header.  malzmq_header_t *malzmq_header = malzmq_header_new(NULL, true, 0, true, NULL,\n  NULL, NULL, NULL);  Un contexte de transport MALZMQ est cr\u00e9\u00e9 \u00e0 partir du contexte MAL. Une fonction de mapping d'URI est fournie (cf 12.2). Dans l'exemple on utilise la fonction par d\u00e9faut. L'adresse et le port d'\u00e9coute de connexions entrantes sont 'localhost' et 5555.  malzmq_ctx_t *malzmq_ctx = malzmq_ctx_new(\n  mal_ctx, NULL,\n  \"localhost\", \"5555\",\n  malzmq_header,\n  encoder, decoder,\n  true);", 
            "title": "Cr\u00e9ation d'un contexte MAL :"
        }, 
        {
            "location": "/tutorial/#creation-du-provider", 
            "text": "Allocation d'une URI MALZMQ. Un nom unique (dans le contexte MALZMQ) est pass\u00e9 en param\u00e8tre.  mal_uri_t *provider_uri =\n  mal_ctx_create_uri(mal_ctx, \"simple_app/myprovider\");  Cr\u00e9ation du end-point du provider avec les param\u00e8tres suivants :\n  - la r\u00e9f\u00e9rence du contexte MAL,\n  - l'URI du provider allou\u00e9e pr\u00e9c\u00e9demment.  mal_endpoint_t *provider_endpoint = mal_endpoint_new(mal_ctx, provider_uri);  Instanciation du provider avec la r\u00e9f\u00e9rence du end-point correspondant et les param\u00e8tres li\u00e9s \u00e0 l'encodage :  simple_app_myprovider_t *provider = simple_app_myprovider_new(\n  provider_endpoint,\n  MALBINARY_FORMAT_CODE,\n  encoder, decoder);  L'enregistrement du handler de l'op\u00e9ration sera effectu\u00e9e dans la fonction run de l'acteur CZMQ (voir section 4.2.2).", 
            "title": "Cr\u00e9ation du provider"
        }, 
        {
            "location": "/tutorial/#creation-du-consumer", 
            "text": "Allocation d'une URI MALZMQ. Un nom unique (dans le contexte MALZMQ) est pass\u00e9 en param\u00e8tre.  mal_uri_t *consumer_uri =\n  mal_ctx_create_uri(mal_ctx, \"simple_app/myconsumer\");  Cr\u00e9ation du end-point du consumer avec les param\u00e8tres suivants :\n  - la r\u00e9f\u00e9rence du contexte MAL,\n  - l'URI du consumer allou\u00e9e pr\u00e9c\u00e9demment.  mal_endpoint_t *consumer_endpoint = mal_endpoint_new(mal_ctx, consumer_uri);  L'instanciation du consumer n\u00e9cessite de d\u00e9terminer certains param\u00e8tres du Header de message MAL :  mal_blob_t *authentication_id = mal_blob_new(0);\nmal_qoslevel_t qoslevel = MAL_QOSLEVEL_ASSURED;\nmal_uinteger_t priority = 4;\nmal_identifier_list_t *domain = mal_identifier_list_new(0);\nmal_identifier_t *network_zone = mal_identifier_new(\"Network Zone\");\nmal_sessiontype_t session = MAL_SESSIONTYPE_LIVE;\nmal_identifier_t *session_name = mal_identifier_new(\"LIVE\");\n\nsimple_app_myconsumer_t *consumer =\nsimple_app_myconsumer_new(provider_uri,\n  authentication_id, qoslevel, priority, domain, network_zone, session,\n  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);  Les m\u00eames contextes d'encodage et de d\u00e9codage que ceux du provider sont utilis\u00e9s par le consumer.  L'op\u00e9ration Send ne n\u00e9cessitant pas de handler cot\u00e9 consumer il n'y aura pas d'enregistrement de handler pour ce consumer.", 
            "title": "Cr\u00e9ation du consumer"
        }, 
        {
            "location": "/tutorial/#lancement-et-fin-de-lapplication", 
            "text": "Cr\u00e9ation du provider et de l'acteur ZMQ correspondant :  provider = simple_app_create_provider(\n  verbose,\n  mal_ctx, provider_uri,\n  encoder, decoder);\nzactor_t *provider_actor = zactor_new(simple_app_myprovider_run, provider);  Cr\u00e9ation du consumer et de l'acteur ZMQ correspondant :  consumer = simple_app_create_consumer(\n  verbose,\n  mal_ctx, provider_uri,\n  encoder, decoder);\nzactor_t *consumer_actor = zactor_new(simple_app_myconsumer_run, consumer);  D\u00e9marrage du contexte MALZMQ (appel bloquant jusqu'\u00e0 l'interruption du contexte) :    malzmq_ctx_start(malzmq_ctx);  Destruction des contextes MAL et MALZMQ :    mal_ctx_destroy( mal_ctx);\n  malzmq_ctx_destroy( malzmq_ctx);", 
            "title": "Lancement et fin de l'application"
        }, 
        {
            "location": "/mal_attributes/", 
            "text": "API d'Attributs MAL\n\n\nL'API d'Attributs MAL d\u00e9finit les types C utilis\u00e9s pour repr\u00e9senter les Attributs MAL.\n\n\nType bool\u00e9en\n\n\nD\u00e9finition du type \nMAL::Boolean\n :\n\n\n    typedef bool mal_boolean_t;\n\n\n\n\nTypes num\u00e9riques entiers\n\n\nD\u00e9finition des types \nMAL::Octet\n, \nMAL::UOctet\n, \nMAL::Short\n, \nMAL::UShort\n, \nMAL::Integer\n, \nMAL::UInteger\n, \nMAL::Long\n, \nMAL::ULong\n :\n\n\n    typedef char mal_octet_t;\n    typedef unsigned char mal_uoctet_t;\n    typedef short mal_short_t;\n    typedef unsigned short mal_ushort_t;\n    typedef int mal_integer_t;\n    typedef unsigned int mal_uinteger_t;\n    typedef long mal_long_t;\n    typedef unsigned long mal_ulong_t;\n\n\n\n\nTypes num\u00e9riques flotants\n\n\nD\u00e9finition des types \nMAL::Float\n, \nMAL::Double\n.\n\n\n    typedef float mal_float_t;\n    typedef double mal_double_t;\n\n\n\n\nDates\n\n\nD\u00e9finition des types \nMAL::Time\n, \nMAL::FineTime\n :\n\n\n    typedef unsigned long mal_time_t;\n    typedef unsigned long mal_finetime_t;\n\n\n\n\nDur\u00e9e\n\n\nD\u00e9finition du type \nMAL::Duration\n :\n\n\n    typedef float mal_duration_t;\n\n\n\n\nTypes cha\u00eene de caract\u00e8res\n\n\nLe type \nchar\n est utilis\u00e9 pour repr\u00e9senter les cha\u00eenes de caract\u00e8res. Si les caract\u00e8res n'appartiennent pas au format ASCII (MAL sp\u00e9cifie le format Unicode), alors un m\u00eame caract\u00e8re peut \u00eatre repr\u00e9sent\u00e9 par plusieurs octets . Dans ce cas, les fonctions C traitant les cha\u00eenes ASCII ne sont plus applicables.\n\n\nD\u00e9finition des types \nMAL::String\n, \nMAL::Identifier\n, \nMAL::URI\n :\n\n\n    typedef char mal_string_t;\n    typedef char mal_identifier_t;\n    typedef char mal_uri_t;\n\n\n\n\nConstructeur\n\n\nAlloue dynamiquement une nouvelle cha\u00eene de caract\u00e8res \u00e0 partir d'une cha\u00eene existante. Cette fonction doit \u00eatre appel\u00e9e quand une cha\u00eene MAL est construite \u00e0 partir d'une cha\u00eene d\u00e9finie statiquement.\n\n\n    mal_\nattribute\n_t *mal_\nattribute\n_new(char *char_content);\n\n\n\n\nNombre de caract\u00e8res (ASCII)\n\n\nRetourne le nombre de caract\u00e8res (encod\u00e9s sur 1 octet) dans la cha\u00eene, avant le caract\u00e8re nul final (\n\\0\n).\n\n\n    size_t mal_\nattribute\n_get_char_count(mal_\nattribute\n_t *self)\n\n\n\n\nCopie\n\n\nLorsqu'une m\u00eame cha\u00eene de caract\u00e8res doit \u00eatre affect\u00e9e \u00e0 deux champs distincts d'une m\u00eame structure MAL ou de deux structures MAL distinctes (composite, liste), alors il est n\u00e9cessaire de dupliquer la cha\u00eene MAL. Il ne faut pas affecter la m\u00eame cha\u00eene MAL aux deux champs.\n\n\n    mal_\nattribute\n_t *attribute2 = mal_\nattribute\n_new(attribute1);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la cha\u00eene de caract\u00e8res.\n\n\n    mal_\nattribute\n_destroy(mal_\nattribute\n_t **self_p);\n\n\n\n\nBlob\n\n\nUne classe est d\u00e9finie pour le type Blob afin de conserver la taille du tableau d'octets (non accessible en C).\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\n    mal_blob_t *mal_blob_new(unsigned int length);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nlength\n : nombre d'octets dans le Blob\n\n\n\n\nGetters\n\n\nDes fonctions sont d\u00e9finies pour acc\u00e9der aux champs de Blob :\n\n\n    char *mal_blob_get_content(mal_blob_t *self);\n    unsigned int mal_blob_get_length(mal_blob_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit le Blob et son contenu.\n\n\n    void mal_blob_destroy(mal_blob_t **self_p);\n\n\n\n\nPolymorphisme d'Attribut\n\n\nPour g\u00e9rer le cas du polymorphisme d'Attribut MAL, on d\u00e9finit une classe avec les \u00e9l\u00e9ments suivants :\n\n\n\n\ndes tags qui permettent d'identifier le type concret de l'attribut,\n\n\nun type C union qui permet de manipuler la valeur de l'attribut typ\u00e9e en fonction du tag associ\u00e9,\n\n\nun destructeur.\n\n\n\n\nUnion des Attributs\n\n\nUne union \nmal_attribute_t\n est d\u00e9finie pour permettre le polymorphisme d'Attribut.\n\n\n    union mal_attribute_t {\n      mal_blob_t *blob_value;\n      mal_boolean_t boolean_value;\n      mal_double_t double_value;\n      mal_float_t float_value;\n      mal_octet_t octet_value;\n      mal_uoctet_t uoctet_value;\n      mal_short_t short_value;\n      mal_ushort_t ushort_value;\n      mal_integer_t integer_value;\n      mal_uinteger_t uinteger_value;\n      mal_long_t long_value;\n      mal_ulong_t ulong_value;\n      mal_string_t *string_value;\n      mal_identifier_t *identifier_value;\n      mal_uri_t *uri_value;\n      mal_time_t time_value;\n      mal_finetime_t finetime_value;\n      mal_duration_t duration_value;\n    };\n\n\n\n\nTags d'Attribut\n\n\nCes identifiants sont transmis en cas de polymorphisme d'Attribut.\n\n\n    #define MAL_BLOB_ATTRIBUTE_TAG 0\n    #define MAL_BOOLEAN_ATTRIBUTE_TAG 1\n    #define MAL_DURATION_ATTRIBUTE_TAG 2\n    #define MAL_FLOAT_ATTRIBUTE_TAG 3\n    #define MAL_DOUBLE_ATTRIBUTE_TAG 4\n    #define MAL_IDENTIFIER_ATTRIBUTE_TAG 5\n    #define MAL_OCTET_ATTRIBUTE_TAG 6\n    #define MAL_UOCTET_ATTRIBUTE_TAG 7\n    #define MAL_SHORT_ATTRIBUTE_TAG 8\n    #define MAL_USHORT_ATTRIBUTE_TAG 9\n    #define MAL_INTEGER_ATTRIBUTE_TAG 10\n    #define MAL_UINTEGER_ATTRIBUTE_TAG 11\n    #define MAL_LONG_ATTRIBUTE_TAG 12\n    #define MAL_ULONG_ATTRIBUTE_TAG 13\n    #define MAL_STRING_ATTRIBUTE_TAG 14\n    #define MAL_TIME_ATTRIBUTE_TAG 15\n    #define MAL_FINETIME_ATTRIBUTE_TAG 16\n    #define MAL_URI_ATTRIBUTE_TAG 17\n\n\n\n\nDestructeur\n\n\nD\u00e9truit le contenu de l'union. Ne d\u00e9truit pas l'union elle-m\u00eame qui n'est pas une structure allou\u00e9e.\n\n\n    void mal_attribute_destroy(union mal_attribute_t *self_p,\n        unsigned char attribute_tag);\n\n\n\n\nShort forms d'Attribut\n\n\nCes identifiants sont transmis en cas de polymorphisme d'\u00e9l\u00e9ment MAL.\n\n\n    #define MAL_BLOB_SHORT_FORM 0x1000001000001L\n    #define MAL_BOOLEAN_SHORT_FORM 0x1000001000002L\n    #define MAL_DURATION_SHORT_FORM 0x1000001000003L\n    #define MAL_FLOAT_SHORT_FORM 0x1000001000004L\n    #define MAL_DOUBLE_SHORT_FORM 0x1000001000005L\n    #define MAL_IDENTIFIER_SHORT_FORM 0x1000001000006L\n    #define MAL_OCTET_SHORT_FORM 0x1000001000007L\n    #define MAL_UOCTET_SHORT_FORM 0x1000001000008L\n    #define MAL_SHORT_SHORT_FORM 0x1000001000009L\n    #define MAL_USHORT_SHORT_FORM 0x100000100000AL\n    #define MAL_INTEGER_SHORT_FORM 0x100000100000BL\n    #define MAL_UINTEGER_SHORT_FORM 0x100000100000CL\n    #define MAL_LONG_SHORT_FORM 0x100000100000DL\n    #define MAL_ULONG_SHORT_FORM 0x100000100000EL\n    #define MAL_STRING_SHORT_FORM 0x100000100000FL\n    #define MAL_TIME_SHORT_FORM 0x10000010000010L\n    #define MAL_FINETIME_SHORT_FORM 0x10000010000011L\n    #define MAL_URI_SHORT_FORM 0x10000010000012L", 
            "title": "Attributs"
        }, 
        {
            "location": "/mal_attributes/#api-dattributs-mal", 
            "text": "L'API d'Attributs MAL d\u00e9finit les types C utilis\u00e9s pour repr\u00e9senter les Attributs MAL.", 
            "title": "API d'Attributs MAL"
        }, 
        {
            "location": "/mal_attributes/#type-booleen", 
            "text": "D\u00e9finition du type  MAL::Boolean  :      typedef bool mal_boolean_t;", 
            "title": "Type bool\u00e9en"
        }, 
        {
            "location": "/mal_attributes/#types-numeriques-entiers", 
            "text": "D\u00e9finition des types  MAL::Octet ,  MAL::UOctet ,  MAL::Short ,  MAL::UShort ,  MAL::Integer ,  MAL::UInteger ,  MAL::Long ,  MAL::ULong  :      typedef char mal_octet_t;\n    typedef unsigned char mal_uoctet_t;\n    typedef short mal_short_t;\n    typedef unsigned short mal_ushort_t;\n    typedef int mal_integer_t;\n    typedef unsigned int mal_uinteger_t;\n    typedef long mal_long_t;\n    typedef unsigned long mal_ulong_t;", 
            "title": "Types num\u00e9riques entiers"
        }, 
        {
            "location": "/mal_attributes/#types-numeriques-flotants", 
            "text": "D\u00e9finition des types  MAL::Float ,  MAL::Double .      typedef float mal_float_t;\n    typedef double mal_double_t;", 
            "title": "Types num\u00e9riques flotants"
        }, 
        {
            "location": "/mal_attributes/#dates", 
            "text": "D\u00e9finition des types  MAL::Time ,  MAL::FineTime  :      typedef unsigned long mal_time_t;\n    typedef unsigned long mal_finetime_t;", 
            "title": "Dates"
        }, 
        {
            "location": "/mal_attributes/#duree", 
            "text": "D\u00e9finition du type  MAL::Duration  :      typedef float mal_duration_t;", 
            "title": "Dur\u00e9e"
        }, 
        {
            "location": "/mal_attributes/#types-chaine-de-caracteres", 
            "text": "Le type  char  est utilis\u00e9 pour repr\u00e9senter les cha\u00eenes de caract\u00e8res. Si les caract\u00e8res n'appartiennent pas au format ASCII (MAL sp\u00e9cifie le format Unicode), alors un m\u00eame caract\u00e8re peut \u00eatre repr\u00e9sent\u00e9 par plusieurs octets . Dans ce cas, les fonctions C traitant les cha\u00eenes ASCII ne sont plus applicables.  D\u00e9finition des types  MAL::String ,  MAL::Identifier ,  MAL::URI  :      typedef char mal_string_t;\n    typedef char mal_identifier_t;\n    typedef char mal_uri_t;", 
            "title": "Types cha\u00eene de caract\u00e8res"
        }, 
        {
            "location": "/mal_attributes/#constructeur", 
            "text": "Alloue dynamiquement une nouvelle cha\u00eene de caract\u00e8res \u00e0 partir d'une cha\u00eene existante. Cette fonction doit \u00eatre appel\u00e9e quand une cha\u00eene MAL est construite \u00e0 partir d'une cha\u00eene d\u00e9finie statiquement.      mal_ attribute _t *mal_ attribute _new(char *char_content);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_attributes/#nombre-de-caracteres-ascii", 
            "text": "Retourne le nombre de caract\u00e8res (encod\u00e9s sur 1 octet) dans la cha\u00eene, avant le caract\u00e8re nul final ( \\0 ).      size_t mal_ attribute _get_char_count(mal_ attribute _t *self)", 
            "title": "Nombre de caract\u00e8res (ASCII)"
        }, 
        {
            "location": "/mal_attributes/#copie", 
            "text": "Lorsqu'une m\u00eame cha\u00eene de caract\u00e8res doit \u00eatre affect\u00e9e \u00e0 deux champs distincts d'une m\u00eame structure MAL ou de deux structures MAL distinctes (composite, liste), alors il est n\u00e9cessaire de dupliquer la cha\u00eene MAL. Il ne faut pas affecter la m\u00eame cha\u00eene MAL aux deux champs.      mal_ attribute _t *attribute2 = mal_ attribute _new(attribute1);", 
            "title": "Copie"
        }, 
        {
            "location": "/mal_attributes/#destructeur", 
            "text": "D\u00e9truit la cha\u00eene de caract\u00e8res.      mal_ attribute _destroy(mal_ attribute _t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_attributes/#blob", 
            "text": "Une classe est d\u00e9finie pour le type Blob afin de conserver la taille du tableau d'octets (non accessible en C).", 
            "title": "Blob"
        }, 
        {
            "location": "/mal_attributes/#constructeur_1", 
            "text": "D\u00e9claration :      mal_blob_t *mal_blob_new(unsigned int length);  Param\u00e8tres :   length  : nombre d'octets dans le Blob", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_attributes/#getters", 
            "text": "Des fonctions sont d\u00e9finies pour acc\u00e9der aux champs de Blob :      char *mal_blob_get_content(mal_blob_t *self);\n    unsigned int mal_blob_get_length(mal_blob_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/mal_attributes/#destructeur_1", 
            "text": "D\u00e9truit le Blob et son contenu.      void mal_blob_destroy(mal_blob_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_attributes/#polymorphisme-dattribut", 
            "text": "Pour g\u00e9rer le cas du polymorphisme d'Attribut MAL, on d\u00e9finit une classe avec les \u00e9l\u00e9ments suivants :   des tags qui permettent d'identifier le type concret de l'attribut,  un type C union qui permet de manipuler la valeur de l'attribut typ\u00e9e en fonction du tag associ\u00e9,  un destructeur.", 
            "title": "Polymorphisme d'Attribut"
        }, 
        {
            "location": "/mal_attributes/#union-des-attributs", 
            "text": "Une union  mal_attribute_t  est d\u00e9finie pour permettre le polymorphisme d'Attribut.      union mal_attribute_t {\n      mal_blob_t *blob_value;\n      mal_boolean_t boolean_value;\n      mal_double_t double_value;\n      mal_float_t float_value;\n      mal_octet_t octet_value;\n      mal_uoctet_t uoctet_value;\n      mal_short_t short_value;\n      mal_ushort_t ushort_value;\n      mal_integer_t integer_value;\n      mal_uinteger_t uinteger_value;\n      mal_long_t long_value;\n      mal_ulong_t ulong_value;\n      mal_string_t *string_value;\n      mal_identifier_t *identifier_value;\n      mal_uri_t *uri_value;\n      mal_time_t time_value;\n      mal_finetime_t finetime_value;\n      mal_duration_t duration_value;\n    };", 
            "title": "Union des Attributs"
        }, 
        {
            "location": "/mal_attributes/#tags-dattribut", 
            "text": "Ces identifiants sont transmis en cas de polymorphisme d'Attribut.      #define MAL_BLOB_ATTRIBUTE_TAG 0\n    #define MAL_BOOLEAN_ATTRIBUTE_TAG 1\n    #define MAL_DURATION_ATTRIBUTE_TAG 2\n    #define MAL_FLOAT_ATTRIBUTE_TAG 3\n    #define MAL_DOUBLE_ATTRIBUTE_TAG 4\n    #define MAL_IDENTIFIER_ATTRIBUTE_TAG 5\n    #define MAL_OCTET_ATTRIBUTE_TAG 6\n    #define MAL_UOCTET_ATTRIBUTE_TAG 7\n    #define MAL_SHORT_ATTRIBUTE_TAG 8\n    #define MAL_USHORT_ATTRIBUTE_TAG 9\n    #define MAL_INTEGER_ATTRIBUTE_TAG 10\n    #define MAL_UINTEGER_ATTRIBUTE_TAG 11\n    #define MAL_LONG_ATTRIBUTE_TAG 12\n    #define MAL_ULONG_ATTRIBUTE_TAG 13\n    #define MAL_STRING_ATTRIBUTE_TAG 14\n    #define MAL_TIME_ATTRIBUTE_TAG 15\n    #define MAL_FINETIME_ATTRIBUTE_TAG 16\n    #define MAL_URI_ATTRIBUTE_TAG 17", 
            "title": "Tags d'Attribut"
        }, 
        {
            "location": "/mal_attributes/#destructeur_2", 
            "text": "D\u00e9truit le contenu de l'union. Ne d\u00e9truit pas l'union elle-m\u00eame qui n'est pas une structure allou\u00e9e.      void mal_attribute_destroy(union mal_attribute_t *self_p,\n        unsigned char attribute_tag);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_attributes/#short-forms-dattribut", 
            "text": "Ces identifiants sont transmis en cas de polymorphisme d'\u00e9l\u00e9ment MAL.      #define MAL_BLOB_SHORT_FORM 0x1000001000001L\n    #define MAL_BOOLEAN_SHORT_FORM 0x1000001000002L\n    #define MAL_DURATION_SHORT_FORM 0x1000001000003L\n    #define MAL_FLOAT_SHORT_FORM 0x1000001000004L\n    #define MAL_DOUBLE_SHORT_FORM 0x1000001000005L\n    #define MAL_IDENTIFIER_SHORT_FORM 0x1000001000006L\n    #define MAL_OCTET_SHORT_FORM 0x1000001000007L\n    #define MAL_UOCTET_SHORT_FORM 0x1000001000008L\n    #define MAL_SHORT_SHORT_FORM 0x1000001000009L\n    #define MAL_USHORT_SHORT_FORM 0x100000100000AL\n    #define MAL_INTEGER_SHORT_FORM 0x100000100000BL\n    #define MAL_UINTEGER_SHORT_FORM 0x100000100000CL\n    #define MAL_LONG_SHORT_FORM 0x100000100000DL\n    #define MAL_ULONG_SHORT_FORM 0x100000100000EL\n    #define MAL_STRING_SHORT_FORM 0x100000100000FL\n    #define MAL_TIME_SHORT_FORM 0x10000010000010L\n    #define MAL_FINETIME_SHORT_FORM 0x10000010000011L\n    #define MAL_URI_SHORT_FORM 0x10000010000012L", 
            "title": "Short forms d'Attribut"
        }, 
        {
            "location": "/mal_encoding/", 
            "text": "APIs d'encodage\n\n\nLes APIs d'encodage sont d\u00e9finies de mani\u00e8re sp\u00e9cifique \u00e0 un format d'encodage. Aucune fonction virtuelle n'est impos\u00e9e par l'API C. Seuls des patterns de fonction sont propos\u00e9s. Ces patterns sont le plus g\u00e9n\u00e9rique possible mais ils ne sont pas forc\u00e9ment applicables \u00e0 tous les formats d'encodage. D'autres patterns de fonction peuvent \u00eatre d\u00e9finis selon les besoins.\n\n\nLes fonctions d'encodage g\u00e9n\u00e9r\u00e9es pour chaque structure de donn\u00e9e appellent directement les fonctions sp\u00e9cifiques d'encodage. Donc le g\u00e9n\u00e9rateur de stub doit conna\u00eetre les fonctions sp\u00e9cifiques d'encodage offertes par chaque module d'encodage.\n\n\nLe code applicatif ne d\u00e9pend pas des APIs sp\u00e9cifiques d'encodage, sauf dans le cas o\u00f9 l'application a besoin d'encoder ou de d\u00e9coder des donn\u00e9es de mani\u00e8re explicite.\n\n\nLe nom donn\u00e9 en C au format d'encodage d\u00e9fini dans le livre MAL/SPP est : malbinary.\n\n\nCe nom est une cha\u00eene de caract\u00e8res utilis\u00e9e pour le nommage des APIs.\n\n\nD\u00e9finitions\n\n\n    \nformat\n.h\n\n\n\n\nUn code identifie de mani\u00e8re unique le format d'encodage doit \u00eatre d\u00e9fini.\n\n\n    #define \nFORMAT\n_FORMAT_CODE \nunique number\n\n\n\n\n\nDonn\u00e9es \u00e0 encoder\n\n\nLes donn\u00e9es \u00e0 encoder sont :\n\n\n\n\nles attributs MAL (dont les types C sont d\u00e9finis en section 5)\n\n\nle type d'union \nmal_attribute_t\n\n\ndes donn\u00e9es sp\u00e9cifiques \u00e0 certains format ; par exemple : le flag de pr\u00e9sence d'un champ, la taille de liste, la valeur d'un \u00e9num\u00e9r\u00e9.\n\n\n\n\nIl n'y a pas de fonction d'encodage d'\u00e9num\u00e9rations car seul le code g\u00e9n\u00e9r\u00e9 (stubs) a la connaissance de la taille des \u00e9num\u00e9r\u00e9s qui d\u00e9termine le format d'encodage (dans le cas du format \nmalbinary\n).\n\n\nIl n'y a pas non plus de fonction d'encodage de liste car l'encodage des \u00e9l\u00e9ments de la liste est sp\u00e9cifique \u00e0 leur type. Donc le code d'encodage d'une liste doit \u00eatre g\u00e9n\u00e9r\u00e9 dans les stubs.\n\n\nL'encodage/d\u00e9codage d'un code d'erreur est r\u00e9alis\u00e9 avec les fonctions d'encodage du type \nMAL Uinteger\n.\n\n\nPour chaque type de donn\u00e9e \u00e0 encoder, trois fonctions sont d\u00e9finies :\n\n\n\n\nune fonction permettant de calculer la taille requise par l'encodage de la donn\u00e9e ; cette fonction prend en param\u00e8tre une taille initiale (la taille d'encodage en cours de calcul) et ajoute la taille de la donn\u00e9e ;\n\n\nune fonction d'encodage de la donn\u00e9e ;\n\n\nune fonction de d\u00e9codage de la donn\u00e9e.\n\n\n\n\nEncodeur\n\n\n    \nformat\n_encoder.h\n\n\n\n\nCalcul de la taille d'encodage\n\n\nFonction d'ajout de la taille d'encodage \u00e0 une valeur initiale.\n\n\nD\u00e9claration :\n\n\n\n\nSi la donn\u00e9e n'est pas de type pointeur (Attributs non pointeurs ou donn\u00e9es sp\u00e9cifiques) :\n\n\n\n\n    int \nformat\n_encoder_add_\ndata\n_encoding_length(\n     \nformat\n_encoder_t *self, mal_\ndata type\n_t to_encode,\n     unsigned int *encoding_length);\n\n\n\n\n\n\nSi la donn\u00e9e est de type pointeur (Attributs pointeurs ou donn\u00e9es sp\u00e9cifiques) :\n\n\n\n\n    int \nformat\n_encoder_add_\ndata\n_encoding_length(\n     \nformat\n_encoder_t *self, mal_\ndata type\n_t *to_encode,\n     unsigned int *encoding_length);\n\n\n\n\n\n\nPour le type MAL::Attribute (polymorphisme d'Attribut) :\n\n\n\n\n    int \nformat\n_encoder_add_attribute_encoding_length(\n     \nformat\n_encoder_t *self, unsigned char attribute_tag,\n      union mal_attribute_t to_encode, unsigned int *encoding_length);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le contexte d'encodage\n\n\nattribute_tag\n : l'identifiant du type d'Attribut (en cas de polymorphisme d'Attribut)\n\n\nto_encode\n : la donn\u00e9e \u00e0 encoder\n\n\nencoding_length\n : valeur initiale et r\u00e9sultat de la fonction d'ajout\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nEncodage\n\n\nD\u00e9claration :\n\n\n\n\nSi la donn\u00e9e n'est pas de type pointeur (Attributs non pointeurs ou donn\u00e9es sp\u00e9cifiques) :\n\n\n\n\n    int \nformat\n_encoder_encode_\ndata\n(\nformat\n_encoder_t *self,\n      char *bytes, int *offset, mal_\ndata type\n_t to_encode);\n\n\n\n\n\n\nSi la donn\u00e9e est de type pointeur (Attributs pointeurs ou donn\u00e9es sp\u00e9cifiques) :\n\n\n\n\n    int \nformat\n_encoder_encode_\ndata\n(\nformat\n_encoder_t *self,\n      char *bytes, int *offset, mal_\ndata type\n_t *to_encode);\n\n\n\n\n\n\nPour le type \nMAL::Attribute\n (polymorphisme d'Attribut) :\n\n\n\n\n    int \nformat\n_encoder_encode_attribute(\n      \nformat\n_encoder_t *self, char *bytes, int *offset,\n      unsigned char attribute_tag, mal_attribute_t to_encode);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le contexte d'encodage\n\n\nbytes\n : le tableau d'octets o\u00f9 doit \u00eatre encod\u00e9e la donn\u00e9e\n\n\noffset\n : l'index \u00e0 partir duquel la donn\u00e9e doit \u00eatre encod\u00e9e, augment\u00e9 en r\u00e9sultat du nombre d'octets encod\u00e9s\n\n\nattribute_tag\n : l'identifiant du type d'Attribut (en cas de polymorphisme d'Attribut)\n\n\nto_encode\n : la donn\u00e9e \u00e0 encoder\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nD\u00e9codeur\n\n\n    \nformat\n_decoder.h\n\n\n\n\nPour chaque type de donn\u00e9e \u00e0 d\u00e9coder, une fonction de d\u00e9codage est d\u00e9finie.\n\n\nD\u00e9claration :\n\n\n\n\nSi la donn\u00e9e n'est pas de type pointeur (Attributs non pointeurs ou donn\u00e9es sp\u00e9cifiques) :\n\n\n\n\n    int \nformat\n_decoder_decode_\ndata\n(\nformat\n_decoder_t *self,\n      char *bytes, int *offset, mal_\ndata type\n_t *result);\n\n\n\n\n\n\nSi la donn\u00e9e est de type pointeur (Attributs pointeurs ou donn\u00e9es sp\u00e9cifiques) :\n\n\n\n\n    int \nformat\n_decoder_decode_\ndata\n(\nformat\n_decoder_t *self,\n      char *bytes, int *offset, mal_\ndata type\n_t **result);\n\n\n\n\n\n\nPour le type \nMAL::Attribute\n (polymorphisme d'Attribut) :\n\n\n\n\n    int \nformat\n_decoder_decode_attribute(\n      \nformat\n_decoder_t *self, char *bytes, int *offset,\n      unsigned char attribute_tag, mal_attribute_t *result);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le contexte de d\u00e9codage\n\n\nbytes\n : le tableau d'octets qui contient la donn\u00e9e encod\u00e9e\n\n\noffset\n : l'index \u00e0 partir duquel la donn\u00e9e doit \u00eatre d\u00e9cod\u00e9e, augment\u00e9 en r\u00e9sultat du nombre d'octets d\u00e9cod\u00e9s\n\n\nresult\n : la donn\u00e9e d\u00e9cod\u00e9e\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nFormat \nmalbinary\n\n\nDonn\u00e9es sp\u00e9cifiques\n\n\n\n\n\n\n\n\nDonn\u00e9e\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npresence_flag\n\n\nbool\n\n\nChamp de pr\u00e9sence d'un \u00e9l\u00e9ment pouvant \u00eatre nul. \nTRUE\n si le champ est pr\u00e9sent (valeur non nulle), \nFALSE\n si le champ est absent (valeur nulle).\n\n\n\n\n\n\nlist_size\n\n\nunsigned int\n\n\nChamp donnant la taille d'une liste MAL\n\n\n\n\n\n\nsmall_enum\n\n\nint\n\n\nChamp donnant la valeur d'un \u00e9l\u00e9ment d'une petite \u00e9num\u00e9ration (taille inf\u00e9rieure \u00e0 2^8)\n\n\n\n\n\n\nmedium_enum\n\n\nint\n\n\nChamp donnant la valeur d'un \u00e9l\u00e9ment d'une  moyenne \u00e9num\u00e9ration (taille inf\u00e9rieure \u00e0 2^16)\n\n\n\n\n\n\nlarge_enum\n\n\nint\n\n\nChamp donnant la valeur d'un \u00e9l\u00e9ment d'une grande \u00e9num\u00e9ration (taille inf\u00e9rieure \u00e0 2^32)\n\n\n\n\n\n\nshort_form\n\n\nlong\n\n\nIdentifiant de type constitu\u00e9 des num\u00e9ros d'Area, de Service, de version d'Area et de type. D\u00e9fini en section 4.1.2 du livre MAL. Cet identifiant est encod\u00e9 en cas de polymorphisme d'\u00e9l\u00e9ment.\n\n\n\n\n\n\nattribute_tag\n\n\nunsigned char\n\n\nIdentifiant d'attribut : \nshort form\n de l'attribut moins 1 (voir section 5.2.2 du livre MAL/SPP)\n\n\n\n\n\n\n\n\nConstantes\n\n\nCes constantes donnent la taille d'encodage de certaines donn\u00e9es : \npresence_flag\n, \nattribute_tag\n, \nshort_form\n, \nsmall_enum\n, \nmedium_enum\n, \nlarge_enum\n.\n\n\n    #define MALBINARY_PRESENCE_FLAG_SIZE 1\n    #define MALBINARY_ATTRIBUTE_TAG_SIZE 1\n    #define MALBINARY_SHORT_FORM_SIZE 8\n    #define MALBINARY_SMALL_ENUM_SIZE 1\n    #define MALBINARY_MEDIUM_ENUM_SIZE 2\n    #define MALBINARY_LARGE_ENUM_SIZE 4", 
            "title": "Encodage"
        }, 
        {
            "location": "/mal_encoding/#apis-dencodage", 
            "text": "Les APIs d'encodage sont d\u00e9finies de mani\u00e8re sp\u00e9cifique \u00e0 un format d'encodage. Aucune fonction virtuelle n'est impos\u00e9e par l'API C. Seuls des patterns de fonction sont propos\u00e9s. Ces patterns sont le plus g\u00e9n\u00e9rique possible mais ils ne sont pas forc\u00e9ment applicables \u00e0 tous les formats d'encodage. D'autres patterns de fonction peuvent \u00eatre d\u00e9finis selon les besoins.  Les fonctions d'encodage g\u00e9n\u00e9r\u00e9es pour chaque structure de donn\u00e9e appellent directement les fonctions sp\u00e9cifiques d'encodage. Donc le g\u00e9n\u00e9rateur de stub doit conna\u00eetre les fonctions sp\u00e9cifiques d'encodage offertes par chaque module d'encodage.  Le code applicatif ne d\u00e9pend pas des APIs sp\u00e9cifiques d'encodage, sauf dans le cas o\u00f9 l'application a besoin d'encoder ou de d\u00e9coder des donn\u00e9es de mani\u00e8re explicite.  Le nom donn\u00e9 en C au format d'encodage d\u00e9fini dans le livre MAL/SPP est : malbinary.  Ce nom est une cha\u00eene de caract\u00e8res utilis\u00e9e pour le nommage des APIs.", 
            "title": "APIs d'encodage"
        }, 
        {
            "location": "/mal_encoding/#definitions", 
            "text": "format .h  Un code identifie de mani\u00e8re unique le format d'encodage doit \u00eatre d\u00e9fini.      #define  FORMAT _FORMAT_CODE  unique number", 
            "title": "D\u00e9finitions"
        }, 
        {
            "location": "/mal_encoding/#donnees-a-encoder", 
            "text": "Les donn\u00e9es \u00e0 encoder sont :   les attributs MAL (dont les types C sont d\u00e9finis en section 5)  le type d'union  mal_attribute_t  des donn\u00e9es sp\u00e9cifiques \u00e0 certains format ; par exemple : le flag de pr\u00e9sence d'un champ, la taille de liste, la valeur d'un \u00e9num\u00e9r\u00e9.   Il n'y a pas de fonction d'encodage d'\u00e9num\u00e9rations car seul le code g\u00e9n\u00e9r\u00e9 (stubs) a la connaissance de la taille des \u00e9num\u00e9r\u00e9s qui d\u00e9termine le format d'encodage (dans le cas du format  malbinary ).  Il n'y a pas non plus de fonction d'encodage de liste car l'encodage des \u00e9l\u00e9ments de la liste est sp\u00e9cifique \u00e0 leur type. Donc le code d'encodage d'une liste doit \u00eatre g\u00e9n\u00e9r\u00e9 dans les stubs.  L'encodage/d\u00e9codage d'un code d'erreur est r\u00e9alis\u00e9 avec les fonctions d'encodage du type  MAL Uinteger .  Pour chaque type de donn\u00e9e \u00e0 encoder, trois fonctions sont d\u00e9finies :   une fonction permettant de calculer la taille requise par l'encodage de la donn\u00e9e ; cette fonction prend en param\u00e8tre une taille initiale (la taille d'encodage en cours de calcul) et ajoute la taille de la donn\u00e9e ;  une fonction d'encodage de la donn\u00e9e ;  une fonction de d\u00e9codage de la donn\u00e9e.", 
            "title": "Donn\u00e9es \u00e0 encoder"
        }, 
        {
            "location": "/mal_encoding/#encodeur", 
            "text": "format _encoder.h", 
            "title": "Encodeur"
        }, 
        {
            "location": "/mal_encoding/#calcul-de-la-taille-dencodage", 
            "text": "Fonction d'ajout de la taille d'encodage \u00e0 une valeur initiale.  D\u00e9claration :   Si la donn\u00e9e n'est pas de type pointeur (Attributs non pointeurs ou donn\u00e9es sp\u00e9cifiques) :       int  format _encoder_add_ data _encoding_length(\n      format _encoder_t *self, mal_ data type _t to_encode,\n     unsigned int *encoding_length);   Si la donn\u00e9e est de type pointeur (Attributs pointeurs ou donn\u00e9es sp\u00e9cifiques) :       int  format _encoder_add_ data _encoding_length(\n      format _encoder_t *self, mal_ data type _t *to_encode,\n     unsigned int *encoding_length);   Pour le type MAL::Attribute (polymorphisme d'Attribut) :       int  format _encoder_add_attribute_encoding_length(\n      format _encoder_t *self, unsigned char attribute_tag,\n      union mal_attribute_t to_encode, unsigned int *encoding_length);  Param\u00e8tres :   self  : le contexte d'encodage  attribute_tag  : l'identifiant du type d'Attribut (en cas de polymorphisme d'Attribut)  to_encode  : la donn\u00e9e \u00e0 encoder  encoding_length  : valeur initiale et r\u00e9sultat de la fonction d'ajout   R\u00e9sultat :   Code d'erreur", 
            "title": "Calcul de la taille d'encodage"
        }, 
        {
            "location": "/mal_encoding/#encodage", 
            "text": "D\u00e9claration :   Si la donn\u00e9e n'est pas de type pointeur (Attributs non pointeurs ou donn\u00e9es sp\u00e9cifiques) :       int  format _encoder_encode_ data ( format _encoder_t *self,\n      char *bytes, int *offset, mal_ data type _t to_encode);   Si la donn\u00e9e est de type pointeur (Attributs pointeurs ou donn\u00e9es sp\u00e9cifiques) :       int  format _encoder_encode_ data ( format _encoder_t *self,\n      char *bytes, int *offset, mal_ data type _t *to_encode);   Pour le type  MAL::Attribute  (polymorphisme d'Attribut) :       int  format _encoder_encode_attribute(\n       format _encoder_t *self, char *bytes, int *offset,\n      unsigned char attribute_tag, mal_attribute_t to_encode);  Param\u00e8tres :   self  : le contexte d'encodage  bytes  : le tableau d'octets o\u00f9 doit \u00eatre encod\u00e9e la donn\u00e9e  offset  : l'index \u00e0 partir duquel la donn\u00e9e doit \u00eatre encod\u00e9e, augment\u00e9 en r\u00e9sultat du nombre d'octets encod\u00e9s  attribute_tag  : l'identifiant du type d'Attribut (en cas de polymorphisme d'Attribut)  to_encode  : la donn\u00e9e \u00e0 encoder   R\u00e9sultat :   Code d'erreur", 
            "title": "Encodage"
        }, 
        {
            "location": "/mal_encoding/#decodeur", 
            "text": "format _decoder.h  Pour chaque type de donn\u00e9e \u00e0 d\u00e9coder, une fonction de d\u00e9codage est d\u00e9finie.  D\u00e9claration :   Si la donn\u00e9e n'est pas de type pointeur (Attributs non pointeurs ou donn\u00e9es sp\u00e9cifiques) :       int  format _decoder_decode_ data ( format _decoder_t *self,\n      char *bytes, int *offset, mal_ data type _t *result);   Si la donn\u00e9e est de type pointeur (Attributs pointeurs ou donn\u00e9es sp\u00e9cifiques) :       int  format _decoder_decode_ data ( format _decoder_t *self,\n      char *bytes, int *offset, mal_ data type _t **result);   Pour le type  MAL::Attribute  (polymorphisme d'Attribut) :       int  format _decoder_decode_attribute(\n       format _decoder_t *self, char *bytes, int *offset,\n      unsigned char attribute_tag, mal_attribute_t *result);  Param\u00e8tres :   self  : le contexte de d\u00e9codage  bytes  : le tableau d'octets qui contient la donn\u00e9e encod\u00e9e  offset  : l'index \u00e0 partir duquel la donn\u00e9e doit \u00eatre d\u00e9cod\u00e9e, augment\u00e9 en r\u00e9sultat du nombre d'octets d\u00e9cod\u00e9s  result  : la donn\u00e9e d\u00e9cod\u00e9e   R\u00e9sultat :   Code d'erreur", 
            "title": "D\u00e9codeur"
        }, 
        {
            "location": "/mal_encoding/#format-malbinary", 
            "text": "", 
            "title": "Format malbinary"
        }, 
        {
            "location": "/mal_encoding/#donnees-specifiques", 
            "text": "Donn\u00e9e  Type  Description      presence_flag  bool  Champ de pr\u00e9sence d'un \u00e9l\u00e9ment pouvant \u00eatre nul.  TRUE  si le champ est pr\u00e9sent (valeur non nulle),  FALSE  si le champ est absent (valeur nulle).    list_size  unsigned int  Champ donnant la taille d'une liste MAL    small_enum  int  Champ donnant la valeur d'un \u00e9l\u00e9ment d'une petite \u00e9num\u00e9ration (taille inf\u00e9rieure \u00e0 2^8)    medium_enum  int  Champ donnant la valeur d'un \u00e9l\u00e9ment d'une  moyenne \u00e9num\u00e9ration (taille inf\u00e9rieure \u00e0 2^16)    large_enum  int  Champ donnant la valeur d'un \u00e9l\u00e9ment d'une grande \u00e9num\u00e9ration (taille inf\u00e9rieure \u00e0 2^32)    short_form  long  Identifiant de type constitu\u00e9 des num\u00e9ros d'Area, de Service, de version d'Area et de type. D\u00e9fini en section 4.1.2 du livre MAL. Cet identifiant est encod\u00e9 en cas de polymorphisme d'\u00e9l\u00e9ment.    attribute_tag  unsigned char  Identifiant d'attribut :  short form  de l'attribut moins 1 (voir section 5.2.2 du livre MAL/SPP)", 
            "title": "Donn\u00e9es sp\u00e9cifiques"
        }, 
        {
            "location": "/mal_encoding/#constantes", 
            "text": "Ces constantes donnent la taille d'encodage de certaines donn\u00e9es :  presence_flag ,  attribute_tag ,  short_form ,  small_enum ,  medium_enum ,  large_enum .      #define MALBINARY_PRESENCE_FLAG_SIZE 1\n    #define MALBINARY_ATTRIBUTE_TAG_SIZE 1\n    #define MALBINARY_SHORT_FORM_SIZE 8\n    #define MALBINARY_SMALL_ENUM_SIZE 1\n    #define MALBINARY_MEDIUM_ENUM_SIZE 2\n    #define MALBINARY_LARGE_ENUM_SIZE 4", 
            "title": "Constantes"
        }, 
        {
            "location": "/mal_api/", 
            "text": "API MAL\n\n\nL'API MAL permet d'utiliser les concepts de niveau MAL :\n\n\n\n\nles concepts d\u00e9finis par la sp\u00e9cification MAL (Blue Book)\n\n\nles concepts propres \u00e0 l'API C, d\u00e9finis en section 2\n\n\n\n\nL'API MAL contient l'API d'Area g\u00e9n\u00e9r\u00e9e \u00e0 partir de la d\u00e9finition de l'Area MAL.\n\n\nD\u00e9finitions\n\n\nmal.h\n\n\n\n\nFonction virtuelle de cr\u00e9ation d'URI\n\n\nD\u00e9claration :\n\n\ntypedef mal_uri_t *mal_binding_ctx_create_uri_fn(\n  void *mal_binding_ctx,\n  char *id);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nid\n : identifiant unique devant \u00eatre inclus dans l'URI\n\n\n\n\nR\u00e9sultat : \n\n\nL'URI cr\u00e9\u00e9e\n\n\nFonction virtuelle de cr\u00e9ation d'un end-point\n\n\nD\u00e9claration :\n\n\ntypedef void *mal_binding_ctx_create_endpoint_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmal_endpoint\n : le end-point MAL correspondant au end-point physique du transport\n\n\n\n\nR\u00e9sultat :\n\n\nLa r\u00e9f\u00e9rence du end-point physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple socket ZMQ).\n\n\nFonction virtuelle de destruction d'un end-point\n\n\nD\u00e9claration :\n\n\ntypedef void mal_binding_ctx_destroy_endpoint_fn(\n  void *mal_binding_ctx,\n  void **endpoint_p);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nendpoint_p\n : le end-point \u00e0 d\u00e9truire\n\n\n\n\nFonction virtuelle de cr\u00e9ation d'un poller MAL\n\n\nD\u00e9claration :\n\n\ntypedef void *mal_binding_ctx_create_poller_fn(\n  void *mal_binding_ctx,\n  mal_poller_t *mal_poller);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmal_poller\n : le poller MAL correspondant au poller physique du transport\n\n\n\n\nR\u00e9sultat : \n\n\nLa r\u00e9f\u00e9rence du poller physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple zpoller ZMQ).\n\n\nFonction virtuelle d'ajout / suppression d'un end-point \u00e0 un poller\n\n\nD\u00e9claration :\n\n\ntypedef int mal_binding_ctx_poller_add_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\ntypedef int mal_binding_ctx_poller_del_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmal_poller\n : le poller \u00e0 utiliser\n\n\nmal_endpoint\n : le end-point \u00e0 ajouter ou supprimer au poller\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur.\n\n\nFonction virtuelle d'attente de message sur un poller MAL\n\n\nD\u00e9claration :\n\n\ntypedef int mal_binding_ctx_poller_wait_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmal_poller\n : le poller sur lequel attendre\n\n\nmal_endpoint\n : le end-point sur lequel un message est en attente de r\u00e9ception\n\n\ntimeout\n : le temps d'attente maximum, \u00e9ventuellement infini (-1)\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur.\n\n\nFonction virtuelle de destruction d'un poller MAL\n\n\nD\u00e9claration :\n\n\ntypedef void mal_binding_ctx_destroy_poller_fn(\n  void *mal_binding_ctx,\n  void **poller_p);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\npoller_p\n : le poller \u00e0 d\u00e9truire\n\n\n\n\nFonction virtuelle d'envoi de message MAL\n\n\nCette fonction est appel\u00e9e par la fonction \nmal_ctx_send_message\n (section 7.4.2).\n\n\nD\u00e9claration :\n\n\ntypedef int mal_binding_ctx_send_message_fn(\n    void *mal_binding_ctx,\n    mal_endpoint_t *mal_endpoint,\n    mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmal_endpoint\n : le end-point qui envoie le message\n\n\nmessage\n : message MAL \u00e0 envoyer\n\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nFonction virtuelle de r\u00e9ception de message MAL\n\n\nCette fonction est appel\u00e9e par la fonction \nmal_ctx_recv_message\n (section 7.4.3).\n\n\nD\u00e9claration :\n\n\ntypedef int mal_binding_ctx_recv_message_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint, mal_message_t **message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmal_endpoint\n : le end-point qui re\u00e7oit le message\n\n\nmessage\n : message MAL re\u00e7u\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nFonction virtuelle de destruction de message MAL\n\n\nPermet au transport d'associer des ressources au message MAL (champ \nbody_owner\n) et de les lib\u00e9rer lors de la destruction du message.\n\n\nD\u00e9claration :\n\n\ntypedef int mal_binding_ctx_destroy_message_fn(void *mal_binding_ctx,\n    mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_binding_ctx\n : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports\n\n\nmessage\n : message MAL \u00e0 d\u00e9truire\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nContexte MAL\n\n\nmal_ctx.h\n\n\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\nmal_ctx_t *mal_ctx_new(void);\n\n\n\n\nR\u00e9sultat : \n\n\nLe contexte MAL cr\u00e9\u00e9\n\n\nCr\u00e9ation d'URI\n\n\nD\u00e9claration :\n\n\nmal_uri_t *mal_ctx_create_uri(mal_ctx_t *self, char *id);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : contexte MAL\n\n\nid\n : identifiant unique devant \u00eatre inclus dans l'URI\n\n\n\n\nR\u00e9sultat : \n\n\nL'URI cr\u00e9\u00e9e\n\n\nCr\u00e9ation d'un end-point\n\n\nD\u00e9claration :\n\n\nvoid *mal_ctx_create_poller(\n  mal_ctx_t *self,\n  mal_poller_t *poller);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n  : contexte MAL\n\n\npoller\n : le poller MAL correspondant au poller physique cr\u00e9\u00e9\n\n\n\n\nR\u00e9sultat : \n\n\nLa r\u00e9f\u00e9rence du poller physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple zpoller ZMQ).\n\n\n\nCr\u00e9ation d'un poller\n\n\nD\u00e9claration :\n\n\nvoid *mal_ctx_create_endpoint(\n  mal_ctx_t *self,\n  mal_endpoint_t *endpoint);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : contexte MAL\n\n\nendpoint\n : le end-point MAL correspondant au end-point physique cr\u00e9\u00e9\n\n\n\n\nR\u00e9sultat : \n\n\nLa r\u00e9f\u00e9rence du end-point physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple socket ZMQ).\n\n\nEnvoi de message MAL\n\n\nCette fonction est appel\u00e9e par les fonctions d'envoi de message MAL des end-points (section 7.4.2). Elle appelle la fonction virtuelle d'envoi de message offerte par le transport (section 7.1.8).\n\n\nL'usage de cette fonction est limit\u00e9e aux end-point MAL.\n\n\nD\u00e9claration :\n\n\nint mal_ctx_send_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : contexte MAL\n\n\nmal_endpoint\n : end-point qui envoie le message\n\n\nmessage\n : message MAL \u00e0 envoyer\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nR\u00e9ception de message MAL\n\n\nCette fonction est appel\u00e9e par les fonctions de r\u00e9ception de messages MAL des end-points (section 7.4.3). Elle appelle la fonction virtuelle de r\u00e9ception de messages offerte par le transport (section 7.1.9).\n\n\nL'usage de cette fonction est limit\u00e9e aux end-point MAL.\n\n\nD\u00e9claration :\n\n\nint mal_ctx_recv_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t **message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : contexte MAL\n\n\nmal_endpoint\n : end-point qui recoit le message\n\n\nmessage\n : message MAL \u00e0 envoyer\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nDestructeur\n\n\nD\u00e9truit le contexte MAL.\n\n\n    void mal_ctx_destroy(mal_ctx_t **self_p);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself_p\n : pointeur vers le contexte MAL \u00e0 d\u00e9truire\n\n\n\n\nMessage MAL\n\n\nConstructeur\n\n\nAlloue la m\u00e9moire n\u00e9cessaire pour le corps de message.\n\n\nD\u00e9claration :\n\n\nmal_message_t *mal_message_new(\n  mal_blob_t *authentication_id,\n  mal_qoslevel_t qoslevel, mal_uinteger_t priority, mal_list_t *domain,\n  mal_identifier_t *network_zone, mal_sessiontype_t session,\n  mal_identifier_t *session_name, unsigned int body_length);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nChamps du header MAL\n\n\nTaille du corps de message en octets\n\n\n\n\nInitialisation\n\n\nInitialisation des champs propres \u00e0 l'op\u00e9ration et \u00e0 l'\u00e9tape d'interaction :\n\n\nD\u00e9claration :\n\n\nvoid mal_message_init(mal_message_t *self, mal_ushort_t service_area,\n  mal_uoctet_t area_version, mal_ushort_t service,\n  mal_ushort_t operation,\n  mal_interactiontype_t interaction_type,\n  mal_uoctet_t interaction_stage);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nChamps du header MAL\n\n\n\n\nDestructeur\n\n\nD\u00e9truit le message MAL et le contenu du corps de message.\n\n\nAppelle la fonction virtuelle de destruction de message MAL offerte par le transport (voir 7.1.10).\n\n\nD\u00e9claration :\n\n\nvoid mal_message_destroy(mal_message_t **self_p, mal_ctx_t *mal_ctx);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nLe message \u00e0 d\u00e9truire\n\n\nLe contexte MAL pour \u00e9ventuellement lib\u00e9rer des ressources au niveau transport (binding) associ\u00e9es au message\n\n\n\n\nGetters et setters\n\n\nLes champs d\u00e9finis dans le tableau suivant sont accessibles.\n\n\n\n\n\n\n\n\nChamp\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmal header field\n\n\nmal header field type\n\n\nLes champs de header MAL sont d\u00e9crits dans le livre MAL\n\n\n\n\n\n\nfree_\nheader field\n\n\nbool\n\n\nFlags indiquant si les champs de header MAL qui sont de type pointeur doivent \u00eatre d\u00e9truits (destroy) lorsque le message MAL est d\u00e9truit.\n\n\n\n\n\n\nbody\n\n\nchar *\n\n\nCorps du message encod\u00e9\n\n\n\n\n\n\nbody_offset\n\n\nunsigned int\n\n\nIndex de d\u00e9but du corps du message\n\n\n\n\n\n\nbody_length\n\n\nunsigned int\n\n\nTaille du corps de message\n\n\n\n\n\n\nbody_owner\n\n\nvoid *\n\n\nRessource associ\u00e9e au message par le transport et devant \u00eatre lib\u00e9r\u00e9e lors de la destruction du message\n\n\n\n\n\n\n\n\nLes flags de pr\u00e9sence s'appliquent aux champs suivants : \nURI To\n, \nAuthentication Id\n, \nURI From\n, \nDomain\n, \nNetwork Zone\n, \nSession Name\n.\nPar d\u00e9faut, le comportement est le suivant :\n\n\n\n\nsi le message MAL a \u00e9t\u00e9 cr\u00e9\u00e9 par le constructeur alors le flag est faux : les champs du header sont transmis lors de l'appel au constructeur, ils n'ont donc pas \u00e0 \u00eatre lib\u00e9r\u00e9s\n\n\nsi le message MAL a \u00e9t\u00e9 cr\u00e9\u00e9 lors d'un d\u00e9codage et si les champs de header ont \u00e9t\u00e9 d\u00e9cod\u00e9s (non r\u00e9cup\u00e9r\u00e9s d'un service de configuration) alors le flag est vrai : les champs du header appartiennent au message et doivent \u00eatre d\u00e9truits avec lui\n\n\n\n\nEnd-Point MAL\n\n\nUn end-point ne doit \u00eatre manipul\u00e9 que par un unique flot d'ex\u00e9cution.\n\n\nConstructeur\n\n\nCr\u00e9e une instance de end-point identifi\u00e9e par une URI MAL. Un compteur de \nTransaction Id\n est g\u00e9r\u00e9.\n\n\nD\u00e9claration :\n\n\nmal_endpoint_t *mal_endpoint_new(mal_ctx_t *mal_ctx, mal_uri_t *uri);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_ctx\n : contexte MAL\n\n\nuri\n : URI MAL identifiant le end-point MAL\n\n\n\n\nL'API offre deux fonctions permettant de retrouver l'URI et le contexte MAL correspondant au end-point :\n\n\nmal_uri_t *mal_endpoint_get_uri(mal_endpoint_t *self);\nmal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);\n\n\n\n\nEnvoi de message MAL\n\n\nDeux fonctions d'envoi de message sont d\u00e9finies :\n\n\n\n\nune fonction pour l'initiation d'une interaction (premi\u00e8re \u00e9tape). Cette fonction affecte les champs d'URI (l'URI de destination est affect\u00e9e avec le param\u00e8tre \nuri_to\n et l'URI source est l'URI du end-point). Si le flag \nset_tid\n est \u00e9gal \u00e0 True, alors le champ \nTransaction Id\n est affect\u00e9 avec la prochaine valeur du compteur de 'Transaction Id' g\u00e9r\u00e9 par le end-point MAL. Sinon, la valeur du champ \nTransaction Id\n du message fourni n'est pas modifi\u00e9e.\n\n\nune fonction pour les \u00e9tapes de r\u00e9sultat d'une interaction (seconde \u00e9tape et suivantes). Cette fonction affecte les champs d'URI (\nURI To\n est affect\u00e9e avec la valeur du champ \nURI From\n du message d'initiation, et \nURI From\n est l'URI du end-point). Le champ \nTransaction Id\n est affect\u00e9 avec la valeur du champ \nTransaction Id\n du message d'initiation. Le champ \nIs Error Message\n est affect\u00e9 avec la valeur pass\u00e9e par le param\u00e8tre \nis_error_message\n.\n\n\n\n\nLa fonction \nmal_ctx_send_message\n (section 7.2.5) est appel\u00e9e pour envoyer le message MAL.\n\n\nD\u00e9claration :\n\n\nint mal_endpoint_init_operation(\n  mal_endpoint_t *self,\n  mal_message_t *message,\n  mal_uri_t *uri_to,\n  bool set_tid);\n\nint mal_endpoint_return_operation(\n  mal_endpoint_t *self,\n  mal_message_t *init_message,\n  mal_message_t *message,\n  bool is_error_message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le end-point qui envoie le message\n\n\nmessage\n : message r\u00e9sultat de l'interaction (\u00e0 envoyer)\n\n\ninit_message\n : message qui a initi\u00e9 l'interaction\n\n\nuri_to\n : l'URI du destinataire du message\n\n\nset_tid\n : flag indiquant si le champ 'Transaction Id' du message MAL doit \u00eatre affect\u00e9 ou non\n\n\nis_error_message\n : flag indiquant si le message renvoie une erreur\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nR\u00e9ception de message MAL\n\n\nLa fonction \nmal_endpoint_recv_message\n permet de recevoir un message sur le end-point, cette fonction est bloquante.\n\n\nint mal_endpoint_recv_message(\n    mal_endpoint_t *self,\n    mal_message_t **message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le end-point qui envoie le message\n\n\nmessage\n : le message re\u00e7u\n\n\n\n\nR\u00e9sultat : \n\n\nCode d'erreur\n\n\nDestructeur\n\n\nD\u00e9truit le end-point.\n\n\nvoid mal_endpoint_destroy(mal_endpoint_t **self_p);\n\n\n\n\nPoller MAL\n\n\nUn poller ne doit \u00eatre manipul\u00e9 que par un unique flot d'ex\u00e9cution.\n\n\nConstructeur\n\n\nCr\u00e9e une instance de poller identifi\u00e9e par une URI MAL.\n\n\nD\u00e9claration :\n\n\n    mal_poller_t *mal_poller_new(mal_ctx_t *mal_ctx);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_ctx\n : contexte MAL\n\n\n\n\nL'API offre une fonction permettant de retrouver le contexte MAL correspondant au poller :\n\n\nmal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);\n\n\n\n\nAjout/Suppression de end-point MAL\n\n\nDeux fonctions permettent l'ajout et la suppression de end-point au poller.\n\n\nD\u00e9claration :\n\n\nint mal_poller_add_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *endpoint);\n\nint mal_poller_del_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *mal_endpoint);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le poller\n\n\nendpoint\n : le end-point \u00e0 ajouter ou supprimer\n\n\n\n\nR\u00e9sultat :\n\n\nCode d'erreur\n\n\nAttente de message MAL\n\n\nLa fonction mal_poller_wait permet d'attendre la r\u00e9ception d'un message sur l'un des end-points du poller. Cette fonction est bloquante prend en param\u00e8tre un time-out.\n\n\nint mal_poller_wait(\n    mal_poller_t *self,\n    mal_endpoint_t **endpoint,\n    int timeout);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le poller en attente de message\n\n\nendpoint\n : le end-point sur lequel un message est arriv\u00e9\n\n\ntimeout\n : le temps d'attente maximal, \u00e9ventuellement infini (-1).\n\n\n\n\nR\u00e9sultat :\n\n\nCode d'erreur\n\n\nDestructeur\n\n\nD\u00e9truit le poller, les \u00e9ventuels end-points rattach\u00e9s doivent \u00eatre d\u00e9truits s\u00e9par\u00e9ment.\n\n\n    void mal_poller_destroy(mal_oller_t **self_p);\n\n\n\n\nHandler et routage\n\n\nUn Handler est une structure logique constitu\u00e9e d'un ensemble de fonctions de traitements de messages MAL, cet ensemble de fonctions d\u00e9pend de son r\u00f4le (provider, consumer, etc.) et de l'interaction dans laquelle il intervient (send, submit, etc.). Les handlers s'ex\u00e9cutent dans le cadre d'une structure de routage (i;e ; un objet de la classe mal_routing, ou routeur).\n\n\nLe routeur est li\u00e9 \u00e0 un end-point MAL, il permet d'enregistrer les handlers correspondants aux diff\u00e9rentes interactions attendues, puis lors de la r\u00e9ception d'un message par le end-point d'activer explicitement le handler correspondant pour qu'il traite le message. Le routeur poss\u00e8de un \u00e9tat partag\u00e9 par l'ensemble des handlers qu'il g\u00e8re.\n\n\nHandler\n\n\nChaque fonction de traitement de messages des handlers prend en param\u00e8tre l'\u00e9tat du routeur, la r\u00e9f\u00e9rence du contexte MAL, la r\u00e9f\u00e9rence du end-point et le message \u00e0 traiter. La signature correspondante est d\u00e9finie ci-dessous.\n\n\ntypedef int mal_routing_on_message_fn(\n  void *self,\n  mal_ctx_t *mal_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nstate\n : \u00e9tat du routeur\n\n\nmal_ctx\n : contexte MAL\n\n\nendpoint\n : end-point MAL\n\n\nstate\n : \u00e9tat de du routeur, non typ\u00e9 pour permettre le polymorphisme\n\n\n\n\nConstructeur\n\n\nCr\u00e9e une instance de routeur identifi\u00e9e par l'URI du end-point correspondant. Normalement un unique routeur doit \u00eatre associ\u00e9 \u00e0 une end-point donn\u00e9.\n\n\nD\u00e9claration :\n\n\nmal_routing_t *mal_routing_new(mal_endpoint_t *endpoint, void *state);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nendpoint\n : end-point MAL\n\n\nstate\n : \u00e9tat de du routeur, non typ\u00e9 pour permettre le polymorphisme\n\n\n\n\nEnregistrement des handlers\n\n\nL'API du routeur MAL d\u00e9finit l'ensemble des fonctions permettant l'enregistrement des handlers d'interaction. Chacune de ces fonctions prend en param\u00e8tre le pointeur vers le routeur lui-m\u00eame, l'identification de l'area, sa version, l\u2019identit\u00e9 du service et de l'op\u00e9ration. En fonction du r\u00f4le du handler et du type de l'op\u00e9ration l'interface comprend des pointeurs vers les fonctions de traitement des messages correspondants de l'interaction.\n\n\nL'API d\u00e9finit une fonction pour enregistrer un provider d'interaction Send, et deux fonctions permettant d'enregistrer les handlers de consumer et provider de chacune des interactions \nSubmit\n, \nRequest\n, \nInvoke\n et \nProgress\n;\n\n\nint mal_routing_register_provider_send_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_send);\n\nint mal_routing_register_provider_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_submit);\n\nint mal_routing_register_consumer_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack);\n\nint mal_routing_register_provider_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_request);\n\nint mal_routing_register_consumer_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_invoke);\n\nint mal_routing_register_consumer_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_progress);\n\nint mal_routing_register_consumer_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_update,\n    mal_routing_on_message_fn *on_response);\n\n\n\n\nL'API offre en outre 3 fonctions permettant d'enregistrer un handler de publisher, de subscriber et de broker pour une interaction \nPubSub\n :\n\n\nint mal_routing_register_provider_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_publish_error,\n    mal_routing_on_message_fn *on_publish_register_ack,\n    mal_routing_on_message_fn *on_publish_deregister_ack);\n\nint mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify);\n\nint mal_routing_register_broker_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_notify_error,\n    mal_routing_on_message_fn *on_register,\n    mal_routing_on_message_fn *on_deregister,\n    mal_routing_on_message_fn *on_publish);\n\n\n\n\nL'API offre aussi une fonction permettant de d\u00e9senregistrer un Handler :\n\n\nint mal_routing_remove_handler(\n    mal_routing_t *mal_routing,\n    handler_type_t type,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation);\n\n\n\n\nEx\u00e9cution des handlers\n\n\nLe routeur offre une fonction permettant d'activer un handler donn\u00e9 en fonction du message MAL re\u00e7u. Lorsqu'elle est appel\u00e9e cette fonction recherche le handler correspondant dans la liste des handlers  enregistr\u00e9s. En cas de succ\u00e8s elle active cet handler en appelant la fonction correspondant au message re\u00e7u.\n\n\nint mal_routing_handle(mal_routing_t *self, mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : le routeur\n\n\nmessage\n : le message re\u00e7u\n\n\n\n\nDestructeur\n\n\nD\u00e9truit le routeur et son \u00e9tat.\n\n\nvoid mal_routing_destroy(mal_routing_t **self_p);\n\n\n\n\nUnion des \u00e9l\u00e9ments\n\n\nUne union \nmal_element_t\n est d\u00e9finie pour permettre le polymorphisme d'\u00e9l\u00e9ment.\n\n\nunion mal_element_t {\n  mal_blob_t *blob_value;\n  mal_boolean_t boolean_value;\n  mal_double_t double_value;\n  mal_float_t float_value;\n  mal_octet_t octet_value;\n  mal_uoctet_t uoctet_value;\n  mal_short_t short_value;\n  mal_ushort_t ushort_value;\n  mal_integer_t integer_value;\n  mal_uinteger_t uinteger_value;\n  mal_long_t long_value;\n  mal_ulong_t ulong_value;\n  mal_string_t *string_value;\n  mal_identifier_t *identifier_value;\n  mal_uri_t *uri_value;\n  mal_time_t time_value;\n  mal_finetime_t finetime_value;\n  mal_duration_t duration_value;\n  int enumerated_value;\n  void *composite_value;\n  void *list_value;\n};\n\n\n\n\nHolder d'\u00e9l\u00e9ment\n\n\nCette structure permet de g\u00e9rer le d\u00e9codage en cas de polymorphisme d'\u00e9l\u00e9ment.\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\nmal_element_holder_t *mal_element_holder_new(void);\n\n\n\n\nGetters et setters\n\n\nbool mal_element_holder_get_presence_flag(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_presence_flag(mal_element_holder_t *self,\n  bool presence_flag);\n\nlong mal_element_holder_get_short_form(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_short_form(mal_element_holder_t *self,\n  long short_form);\n\nunion mal_element_t mal_element_holder_get_value(\n  mal_element_holder_t *self);\n\nvoid mal_element_holder_set_value(mal_element_holder_t *self,\n  union mal_element_t value);\n\n\n\n\nDestructeur\n\n\nvoid mal_element_holder_destroy(mal_element_holder_t **self_p);\n\n\n\n\nCe destructeur ne lib\u00e8re que l'espace allou\u00e9 pour la structure elle-m\u00eame, mais pas les \u00e9l\u00e9ments de l'union.\n\n\nListes d'Attribut non pointeur\n\n\nStructures de donn\u00e9e d\u00e9finies pour repr\u00e9senter les listes des types d'Attribut qui ne sont pas repr\u00e9sent\u00e9s par un type C pointeur (voir section 2.6).\nCes listes sont sp\u00e9cifiques \u00e0 chaque type d'Attribut non pointeur.\nPour chaque liste, deux tableaux sont d\u00e9finis :\n\n\n\n\npresence_flags\n : tableau des flags de pr\u00e9sence pour chacun des \u00e9l\u00e9ments de la liste\n\n\ncontent\n : tableau contenant les valeurs des \u00e9l\u00e9ments de la liste ; si un \u00e9l\u00e9ment est nul, sa valeur dans le tableau doit \u00eatre affect\u00e9e avec n'importe quelle valeur.\n\n\n\n\nLa taille des tableaux \npresence_flags\n et \ncontent\n doit \u00eatre la m\u00eame.\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\nmal_\nattribute\n_list_t *mal_\nattribute\n_list_new(\n  unsigned int element_count);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nelement_count\n : nombre d'\u00e9l\u00e9ments dans la liste\n\n\n\n\nGetter\n\n\nDes fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :\n\n\nunsigned int mal_\nattribute\n_list_get_element_count(\n  mal_\nattribute\n_list_t *self);\n\nbool *mal_\nattribute\n_list_get_presence_flags(\n  mal_\nattribute\n_list_t *self);\n\nmal_\nattribute\n_t *mal_\nattribute\n_list_get_content(\n  mal_\nattribute\n_list_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste et son contenu (tableau des flags de pr\u00e9sence et tableau des valeurs).\n\n\nvoid mal_\nattribute\n_list_destroy(mal_\nattribute\n_list_t **self_p);\n\n\n\n\nListes d'Attribut pointeur\n\n\nStructures de donn\u00e9e d\u00e9finies pour repr\u00e9senter les listes des types d'Attribut qui sont repr\u00e9sent\u00e9s par un type C pointeur (voir section 2.6).\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\nmal_\nattribute\n_list_t *mal_\nattribute\n_list_new(\n  unsigned int element_count);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nelement_count\n : nombre d'\u00e9l\u00e9ments dans la liste\n\n\n\n\nGetters\n\n\nDes fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :\n\n\nunsigned int mal_\nattribute\n_list_get_element_count(\n  mal_\nattribute\n_list_t *self);\n\nmal_\nattribute\n_t **mal_\nattribute\n_list_get_content(\n  mal_\nattribute\n_list_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste, son contenu (tableau de pointeurs) et les \u00e9l\u00e9ments de la liste.\n\n\nvoid mal_\nattribute\n_list_destroy(mal_\nattribute\n_list_t **self_p);\n\n\n\n\nListes de Composite\n\n\nVoir section 9.6.\n\n\nListes d'\u00e9num\u00e9r\u00e9\n\n\nVoir section 9.7.\n\n\nEtapes d'interaction\n\n\nUne constante est d\u00e9finie pour chaque \u00e9tape d'interaction :\n\n\n#define MAL_IP_STAGE_SEND 1\n#define MAL_IP_STAGE_SUBMIT 1\n#define MAL_IP_STAGE_SUBMIT_ACK 2\n#define MAL_IP_STAGE_REQUEST 1\n#define MAL_IP_STAGE_REQUEST_RESPONSE 2\n#define MAL_IP_STAGE_INVOKE 1\n#define MAL_IP_STAGE_INVOKE_ACK 2\n#define MAL_IP_STAGE_INVOKE_RESPONSE 3\n#define MAL_IP_STAGE_PROGRESS 1\n#define MAL_IP_STAGE_PROGRESS_ACK 2\n#define MAL_IP_STAGE_PROGRESS_UPDATE 3\n#define MAL_IP_STAGE_PROGRESS_RESPONSE 4\n#define MAL_IP_STAGE_PUBSUB_REGISTER 1\n#define MAL_IP_STAGE_PUBSUB_REGISTER_ACK 2\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER 3\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER_ACK 4\n#define MAL_IP_STAGE_PUBSUB_PUBLISH 5\n#define MAL_IP_STAGE_PUBSUB_NOTIFY 6\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER 7\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER_ACK 8\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER 9\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER_ACK 10", 
            "title": "MAL"
        }, 
        {
            "location": "/mal_api/#api-mal", 
            "text": "L'API MAL permet d'utiliser les concepts de niveau MAL :   les concepts d\u00e9finis par la sp\u00e9cification MAL (Blue Book)  les concepts propres \u00e0 l'API C, d\u00e9finis en section 2   L'API MAL contient l'API d'Area g\u00e9n\u00e9r\u00e9e \u00e0 partir de la d\u00e9finition de l'Area MAL.", 
            "title": "API MAL"
        }, 
        {
            "location": "/mal_api/#definitions", 
            "text": "mal.h", 
            "title": "D\u00e9finitions"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-creation-duri", 
            "text": "D\u00e9claration :  typedef mal_uri_t *mal_binding_ctx_create_uri_fn(\n  void *mal_binding_ctx,\n  char *id);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  id  : identifiant unique devant \u00eatre inclus dans l'URI   R\u00e9sultat :   L'URI cr\u00e9\u00e9e", 
            "title": "Fonction virtuelle de cr\u00e9ation d'URI"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-creation-dun-end-point", 
            "text": "D\u00e9claration :  typedef void *mal_binding_ctx_create_endpoint_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  mal_endpoint  : le end-point MAL correspondant au end-point physique du transport   R\u00e9sultat :  La r\u00e9f\u00e9rence du end-point physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple socket ZMQ).", 
            "title": "Fonction virtuelle de cr\u00e9ation d'un end-point"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-destruction-dun-end-point", 
            "text": "D\u00e9claration :  typedef void mal_binding_ctx_destroy_endpoint_fn(\n  void *mal_binding_ctx,\n  void **endpoint_p);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  endpoint_p  : le end-point \u00e0 d\u00e9truire", 
            "title": "Fonction virtuelle de destruction d'un end-point"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-creation-dun-poller-mal", 
            "text": "D\u00e9claration :  typedef void *mal_binding_ctx_create_poller_fn(\n  void *mal_binding_ctx,\n  mal_poller_t *mal_poller);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  mal_poller  : le poller MAL correspondant au poller physique du transport   R\u00e9sultat :   La r\u00e9f\u00e9rence du poller physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple zpoller ZMQ).", 
            "title": "Fonction virtuelle de cr\u00e9ation d'un poller MAL"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-dajout-suppression-dun-end-point-a-un-poller", 
            "text": "D\u00e9claration :  typedef int mal_binding_ctx_poller_add_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\ntypedef int mal_binding_ctx_poller_del_endpoint_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  mal_poller  : le poller \u00e0 utiliser  mal_endpoint  : le end-point \u00e0 ajouter ou supprimer au poller   R\u00e9sultat :   Code d'erreur.", 
            "title": "Fonction virtuelle d'ajout / suppression d'un end-point \u00e0 un poller"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-dattente-de-message-sur-un-poller-mal", 
            "text": "D\u00e9claration :  typedef int mal_binding_ctx_poller_wait_fn(\n    void *mal_binding_ctx,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  mal_poller  : le poller sur lequel attendre  mal_endpoint  : le end-point sur lequel un message est en attente de r\u00e9ception  timeout  : le temps d'attente maximum, \u00e9ventuellement infini (-1)   R\u00e9sultat :   Code d'erreur.", 
            "title": "Fonction virtuelle d'attente de message sur un poller MAL"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-destruction-dun-poller-mal", 
            "text": "D\u00e9claration :  typedef void mal_binding_ctx_destroy_poller_fn(\n  void *mal_binding_ctx,\n  void **poller_p);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  poller_p  : le poller \u00e0 d\u00e9truire", 
            "title": "Fonction virtuelle de destruction d'un poller MAL"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-denvoi-de-message-mal", 
            "text": "Cette fonction est appel\u00e9e par la fonction  mal_ctx_send_message  (section 7.4.2).  D\u00e9claration :  typedef int mal_binding_ctx_send_message_fn(\n    void *mal_binding_ctx,\n    mal_endpoint_t *mal_endpoint,\n    mal_message_t *message);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  mal_endpoint  : le end-point qui envoie le message  message  : message MAL \u00e0 envoyer   R\u00e9sultat :   code d'erreur", 
            "title": "Fonction virtuelle d'envoi de message MAL"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-reception-de-message-mal", 
            "text": "Cette fonction est appel\u00e9e par la fonction  mal_ctx_recv_message  (section 7.4.3).  D\u00e9claration :  typedef int mal_binding_ctx_recv_message_fn(\n  void *mal_binding_ctx,\n  mal_endpoint_t *mal_endpoint, mal_message_t **message);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  mal_endpoint  : le end-point qui re\u00e7oit le message  message  : message MAL re\u00e7u   R\u00e9sultat :   Code d'erreur", 
            "title": "Fonction virtuelle de r\u00e9ception de message MAL"
        }, 
        {
            "location": "/mal_api/#fonction-virtuelle-de-destruction-de-message-mal", 
            "text": "Permet au transport d'associer des ressources au message MAL (champ  body_owner ) et de les lib\u00e9rer lors de la destruction du message.  D\u00e9claration :  typedef int mal_binding_ctx_destroy_message_fn(void *mal_binding_ctx,\n    mal_message_t *message);  Param\u00e8tres :   mal_binding_ctx  : contexte du transport (binding) utilis\u00e9 par la couche MAL ; non typ\u00e9 pour permettre \u00e0 la couche MAL d'utiliser plusieurs transports  message  : message MAL \u00e0 d\u00e9truire   R\u00e9sultat :   Code d'erreur", 
            "title": "Fonction virtuelle de destruction de message MAL"
        }, 
        {
            "location": "/mal_api/#contexte-mal", 
            "text": "mal_ctx.h", 
            "title": "Contexte MAL"
        }, 
        {
            "location": "/mal_api/#constructeur", 
            "text": "D\u00e9claration :  mal_ctx_t *mal_ctx_new(void);  R\u00e9sultat :   Le contexte MAL cr\u00e9\u00e9", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#creation-duri", 
            "text": "D\u00e9claration :  mal_uri_t *mal_ctx_create_uri(mal_ctx_t *self, char *id);  Param\u00e8tres :   self  : contexte MAL  id  : identifiant unique devant \u00eatre inclus dans l'URI   R\u00e9sultat :   L'URI cr\u00e9\u00e9e", 
            "title": "Cr\u00e9ation d'URI"
        }, 
        {
            "location": "/mal_api/#creation-dun-end-point", 
            "text": "D\u00e9claration :  void *mal_ctx_create_poller(\n  mal_ctx_t *self,\n  mal_poller_t *poller);  Param\u00e8tres :   self   : contexte MAL  poller  : le poller MAL correspondant au poller physique cr\u00e9\u00e9   R\u00e9sultat :   La r\u00e9f\u00e9rence du poller physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple zpoller ZMQ).", 
            "title": "Cr\u00e9ation d'un end-point"
        }, 
        {
            "location": "/mal_api/#creation-dun-poller", 
            "text": "D\u00e9claration :  void *mal_ctx_create_endpoint(\n  mal_ctx_t *self,\n  mal_endpoint_t *endpoint);  Param\u00e8tres :   self  : contexte MAL  endpoint  : le end-point MAL correspondant au end-point physique cr\u00e9\u00e9   R\u00e9sultat :   La r\u00e9f\u00e9rence du end-point physique cr\u00e9\u00e9 (non typ\u00e9e pour \u00e9viter la d\u00e9pendance avec les concepts physiques du transport, par exemple socket ZMQ).", 
            "title": "Cr\u00e9ation d'un poller"
        }, 
        {
            "location": "/mal_api/#envoi-de-message-mal", 
            "text": "Cette fonction est appel\u00e9e par les fonctions d'envoi de message MAL des end-points (section 7.4.2). Elle appelle la fonction virtuelle d'envoi de message offerte par le transport (section 7.1.8).  L'usage de cette fonction est limit\u00e9e aux end-point MAL.  D\u00e9claration :  int mal_ctx_send_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);  Param\u00e8tres :   self  : contexte MAL  mal_endpoint  : end-point qui envoie le message  message  : message MAL \u00e0 envoyer   R\u00e9sultat :   Code d'erreur", 
            "title": "Envoi de message MAL"
        }, 
        {
            "location": "/mal_api/#reception-de-message-mal", 
            "text": "Cette fonction est appel\u00e9e par les fonctions de r\u00e9ception de messages MAL des end-points (section 7.4.3). Elle appelle la fonction virtuelle de r\u00e9ception de messages offerte par le transport (section 7.1.9).  L'usage de cette fonction est limit\u00e9e aux end-point MAL.  D\u00e9claration :  int mal_ctx_recv_message(\n  mal_ctx_t *self,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t **message);  Param\u00e8tres :   self  : contexte MAL  mal_endpoint  : end-point qui recoit le message  message  : message MAL \u00e0 envoyer   R\u00e9sultat :   Code d'erreur", 
            "title": "R\u00e9ception de message MAL"
        }, 
        {
            "location": "/mal_api/#destructeur", 
            "text": "D\u00e9truit le contexte MAL.      void mal_ctx_destroy(mal_ctx_t **self_p);  Param\u00e8tres :   self_p  : pointeur vers le contexte MAL \u00e0 d\u00e9truire", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#message-mal", 
            "text": "", 
            "title": "Message MAL"
        }, 
        {
            "location": "/mal_api/#constructeur_1", 
            "text": "Alloue la m\u00e9moire n\u00e9cessaire pour le corps de message.  D\u00e9claration :  mal_message_t *mal_message_new(\n  mal_blob_t *authentication_id,\n  mal_qoslevel_t qoslevel, mal_uinteger_t priority, mal_list_t *domain,\n  mal_identifier_t *network_zone, mal_sessiontype_t session,\n  mal_identifier_t *session_name, unsigned int body_length);  Param\u00e8tres :   Champs du header MAL  Taille du corps de message en octets", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#initialisation", 
            "text": "Initialisation des champs propres \u00e0 l'op\u00e9ration et \u00e0 l'\u00e9tape d'interaction :  D\u00e9claration :  void mal_message_init(mal_message_t *self, mal_ushort_t service_area,\n  mal_uoctet_t area_version, mal_ushort_t service,\n  mal_ushort_t operation,\n  mal_interactiontype_t interaction_type,\n  mal_uoctet_t interaction_stage);  Param\u00e8tres :   Champs du header MAL", 
            "title": "Initialisation"
        }, 
        {
            "location": "/mal_api/#destructeur_1", 
            "text": "D\u00e9truit le message MAL et le contenu du corps de message.  Appelle la fonction virtuelle de destruction de message MAL offerte par le transport (voir 7.1.10).  D\u00e9claration :  void mal_message_destroy(mal_message_t **self_p, mal_ctx_t *mal_ctx);  Param\u00e8tres :   Le message \u00e0 d\u00e9truire  Le contexte MAL pour \u00e9ventuellement lib\u00e9rer des ressources au niveau transport (binding) associ\u00e9es au message", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#getters-et-setters", 
            "text": "Les champs d\u00e9finis dans le tableau suivant sont accessibles.     Champ  Type  Description      mal header field  mal header field type  Les champs de header MAL sont d\u00e9crits dans le livre MAL    free_ header field  bool  Flags indiquant si les champs de header MAL qui sont de type pointeur doivent \u00eatre d\u00e9truits (destroy) lorsque le message MAL est d\u00e9truit.    body  char *  Corps du message encod\u00e9    body_offset  unsigned int  Index de d\u00e9but du corps du message    body_length  unsigned int  Taille du corps de message    body_owner  void *  Ressource associ\u00e9e au message par le transport et devant \u00eatre lib\u00e9r\u00e9e lors de la destruction du message     Les flags de pr\u00e9sence s'appliquent aux champs suivants :  URI To ,  Authentication Id ,  URI From ,  Domain ,  Network Zone ,  Session Name .\nPar d\u00e9faut, le comportement est le suivant :   si le message MAL a \u00e9t\u00e9 cr\u00e9\u00e9 par le constructeur alors le flag est faux : les champs du header sont transmis lors de l'appel au constructeur, ils n'ont donc pas \u00e0 \u00eatre lib\u00e9r\u00e9s  si le message MAL a \u00e9t\u00e9 cr\u00e9\u00e9 lors d'un d\u00e9codage et si les champs de header ont \u00e9t\u00e9 d\u00e9cod\u00e9s (non r\u00e9cup\u00e9r\u00e9s d'un service de configuration) alors le flag est vrai : les champs du header appartiennent au message et doivent \u00eatre d\u00e9truits avec lui", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/mal_api/#end-point-mal", 
            "text": "Un end-point ne doit \u00eatre manipul\u00e9 que par un unique flot d'ex\u00e9cution.", 
            "title": "End-Point MAL"
        }, 
        {
            "location": "/mal_api/#constructeur_2", 
            "text": "Cr\u00e9e une instance de end-point identifi\u00e9e par une URI MAL. Un compteur de  Transaction Id  est g\u00e9r\u00e9.  D\u00e9claration :  mal_endpoint_t *mal_endpoint_new(mal_ctx_t *mal_ctx, mal_uri_t *uri);  Param\u00e8tres :   mal_ctx  : contexte MAL  uri  : URI MAL identifiant le end-point MAL   L'API offre deux fonctions permettant de retrouver l'URI et le contexte MAL correspondant au end-point :  mal_uri_t *mal_endpoint_get_uri(mal_endpoint_t *self);\nmal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#envoi-de-message-mal_1", 
            "text": "Deux fonctions d'envoi de message sont d\u00e9finies :   une fonction pour l'initiation d'une interaction (premi\u00e8re \u00e9tape). Cette fonction affecte les champs d'URI (l'URI de destination est affect\u00e9e avec le param\u00e8tre  uri_to  et l'URI source est l'URI du end-point). Si le flag  set_tid  est \u00e9gal \u00e0 True, alors le champ  Transaction Id  est affect\u00e9 avec la prochaine valeur du compteur de 'Transaction Id' g\u00e9r\u00e9 par le end-point MAL. Sinon, la valeur du champ  Transaction Id  du message fourni n'est pas modifi\u00e9e.  une fonction pour les \u00e9tapes de r\u00e9sultat d'une interaction (seconde \u00e9tape et suivantes). Cette fonction affecte les champs d'URI ( URI To  est affect\u00e9e avec la valeur du champ  URI From  du message d'initiation, et  URI From  est l'URI du end-point). Le champ  Transaction Id  est affect\u00e9 avec la valeur du champ  Transaction Id  du message d'initiation. Le champ  Is Error Message  est affect\u00e9 avec la valeur pass\u00e9e par le param\u00e8tre  is_error_message .   La fonction  mal_ctx_send_message  (section 7.2.5) est appel\u00e9e pour envoyer le message MAL.  D\u00e9claration :  int mal_endpoint_init_operation(\n  mal_endpoint_t *self,\n  mal_message_t *message,\n  mal_uri_t *uri_to,\n  bool set_tid);\n\nint mal_endpoint_return_operation(\n  mal_endpoint_t *self,\n  mal_message_t *init_message,\n  mal_message_t *message,\n  bool is_error_message);  Param\u00e8tres :   self  : le end-point qui envoie le message  message  : message r\u00e9sultat de l'interaction (\u00e0 envoyer)  init_message  : message qui a initi\u00e9 l'interaction  uri_to  : l'URI du destinataire du message  set_tid  : flag indiquant si le champ 'Transaction Id' du message MAL doit \u00eatre affect\u00e9 ou non  is_error_message  : flag indiquant si le message renvoie une erreur   R\u00e9sultat :   Code d'erreur", 
            "title": "Envoi de message MAL"
        }, 
        {
            "location": "/mal_api/#reception-de-message-mal_1", 
            "text": "La fonction  mal_endpoint_recv_message  permet de recevoir un message sur le end-point, cette fonction est bloquante.  int mal_endpoint_recv_message(\n    mal_endpoint_t *self,\n    mal_message_t **message);  Param\u00e8tres :   self  : le end-point qui envoie le message  message  : le message re\u00e7u   R\u00e9sultat :   Code d'erreur", 
            "title": "R\u00e9ception de message MAL"
        }, 
        {
            "location": "/mal_api/#destructeur_2", 
            "text": "D\u00e9truit le end-point.  void mal_endpoint_destroy(mal_endpoint_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#poller-mal", 
            "text": "Un poller ne doit \u00eatre manipul\u00e9 que par un unique flot d'ex\u00e9cution.", 
            "title": "Poller MAL"
        }, 
        {
            "location": "/mal_api/#constructeur_3", 
            "text": "Cr\u00e9e une instance de poller identifi\u00e9e par une URI MAL.  D\u00e9claration :      mal_poller_t *mal_poller_new(mal_ctx_t *mal_ctx);  Param\u00e8tres :   mal_ctx  : contexte MAL   L'API offre une fonction permettant de retrouver le contexte MAL correspondant au poller :  mal_ctx_t *mal_endpoint_get_mal_ctx(mal_endpoint_t *self);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#ajoutsuppression-de-end-point-mal", 
            "text": "Deux fonctions permettent l'ajout et la suppression de end-point au poller.  D\u00e9claration :  int mal_poller_add_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *endpoint);\n\nint mal_poller_del_endpoint(\n    mal_poller_t *self,\n    mal_endpoint_t *mal_endpoint);  Param\u00e8tres :   self  : le poller  endpoint  : le end-point \u00e0 ajouter ou supprimer   R\u00e9sultat :  Code d'erreur", 
            "title": "Ajout/Suppression de end-point MAL"
        }, 
        {
            "location": "/mal_api/#attente-de-message-mal", 
            "text": "La fonction mal_poller_wait permet d'attendre la r\u00e9ception d'un message sur l'un des end-points du poller. Cette fonction est bloquante prend en param\u00e8tre un time-out.  int mal_poller_wait(\n    mal_poller_t *self,\n    mal_endpoint_t **endpoint,\n    int timeout);  Param\u00e8tres :   self  : le poller en attente de message  endpoint  : le end-point sur lequel un message est arriv\u00e9  timeout  : le temps d'attente maximal, \u00e9ventuellement infini (-1).   R\u00e9sultat :  Code d'erreur", 
            "title": "Attente de message MAL"
        }, 
        {
            "location": "/mal_api/#destructeur_3", 
            "text": "D\u00e9truit le poller, les \u00e9ventuels end-points rattach\u00e9s doivent \u00eatre d\u00e9truits s\u00e9par\u00e9ment.      void mal_poller_destroy(mal_oller_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#handler-et-routage", 
            "text": "Un Handler est une structure logique constitu\u00e9e d'un ensemble de fonctions de traitements de messages MAL, cet ensemble de fonctions d\u00e9pend de son r\u00f4le (provider, consumer, etc.) et de l'interaction dans laquelle il intervient (send, submit, etc.). Les handlers s'ex\u00e9cutent dans le cadre d'une structure de routage (i;e ; un objet de la classe mal_routing, ou routeur).  Le routeur est li\u00e9 \u00e0 un end-point MAL, il permet d'enregistrer les handlers correspondants aux diff\u00e9rentes interactions attendues, puis lors de la r\u00e9ception d'un message par le end-point d'activer explicitement le handler correspondant pour qu'il traite le message. Le routeur poss\u00e8de un \u00e9tat partag\u00e9 par l'ensemble des handlers qu'il g\u00e8re.", 
            "title": "Handler et routage"
        }, 
        {
            "location": "/mal_api/#handler", 
            "text": "Chaque fonction de traitement de messages des handlers prend en param\u00e8tre l'\u00e9tat du routeur, la r\u00e9f\u00e9rence du contexte MAL, la r\u00e9f\u00e9rence du end-point et le message \u00e0 traiter. La signature correspondante est d\u00e9finie ci-dessous.  typedef int mal_routing_on_message_fn(\n  void *self,\n  mal_ctx_t *mal_ctx,\n  mal_endpoint_t *mal_endpoint,\n  mal_message_t *message);  Param\u00e8tres :   state  : \u00e9tat du routeur  mal_ctx  : contexte MAL  endpoint  : end-point MAL  state  : \u00e9tat de du routeur, non typ\u00e9 pour permettre le polymorphisme", 
            "title": "Handler"
        }, 
        {
            "location": "/mal_api/#constructeur_4", 
            "text": "Cr\u00e9e une instance de routeur identifi\u00e9e par l'URI du end-point correspondant. Normalement un unique routeur doit \u00eatre associ\u00e9 \u00e0 une end-point donn\u00e9.  D\u00e9claration :  mal_routing_t *mal_routing_new(mal_endpoint_t *endpoint, void *state);  Param\u00e8tres :   endpoint  : end-point MAL  state  : \u00e9tat de du routeur, non typ\u00e9 pour permettre le polymorphisme", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#enregistrement-des-handlers", 
            "text": "L'API du routeur MAL d\u00e9finit l'ensemble des fonctions permettant l'enregistrement des handlers d'interaction. Chacune de ces fonctions prend en param\u00e8tre le pointeur vers le routeur lui-m\u00eame, l'identification de l'area, sa version, l\u2019identit\u00e9 du service et de l'op\u00e9ration. En fonction du r\u00f4le du handler et du type de l'op\u00e9ration l'interface comprend des pointeurs vers les fonctions de traitement des messages correspondants de l'interaction.  L'API d\u00e9finit une fonction pour enregistrer un provider d'interaction Send, et deux fonctions permettant d'enregistrer les handlers de consumer et provider de chacune des interactions  Submit ,  Request ,  Invoke  et  Progress ;  int mal_routing_register_provider_send_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_send);\n\nint mal_routing_register_provider_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_submit);\n\nint mal_routing_register_consumer_submit_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack);\n\nint mal_routing_register_provider_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_request);\n\nint mal_routing_register_consumer_request_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_invoke);\n\nint mal_routing_register_consumer_invoke_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_response);\n\nint mal_routing_register_provider_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_progress);\n\nint mal_routing_register_consumer_progress_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_ack,\n    mal_routing_on_message_fn *on_update,\n    mal_routing_on_message_fn *on_response);  L'API offre en outre 3 fonctions permettant d'enregistrer un handler de publisher, de subscriber et de broker pour une interaction  PubSub  :  int mal_routing_register_provider_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_publish_error,\n    mal_routing_on_message_fn *on_publish_register_ack,\n    mal_routing_on_message_fn *on_publish_deregister_ack);\n\nint mal_routing_register_consumer_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_register_ack,\n    mal_routing_on_message_fn *on_deregister_ack,\n    mal_routing_on_message_fn *on_notify);\n\nint mal_routing_register_broker_pubsub_handler(\n    mal_routing_t *mal_routing,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation,\n    mal_routing_on_message_fn *on_notify_error,\n    mal_routing_on_message_fn *on_register,\n    mal_routing_on_message_fn *on_deregister,\n    mal_routing_on_message_fn *on_publish);  L'API offre aussi une fonction permettant de d\u00e9senregistrer un Handler :  int mal_routing_remove_handler(\n    mal_routing_t *mal_routing,\n    handler_type_t type,\n    mal_ushort_t area, mal_uoctet_t area_version,\n    mal_ushort_t service, mal_ushort_t operation);", 
            "title": "Enregistrement des handlers"
        }, 
        {
            "location": "/mal_api/#execution-des-handlers", 
            "text": "Le routeur offre une fonction permettant d'activer un handler donn\u00e9 en fonction du message MAL re\u00e7u. Lorsqu'elle est appel\u00e9e cette fonction recherche le handler correspondant dans la liste des handlers  enregistr\u00e9s. En cas de succ\u00e8s elle active cet handler en appelant la fonction correspondant au message re\u00e7u.  int mal_routing_handle(mal_routing_t *self, mal_message_t *message);  Param\u00e8tres :   self  : le routeur  message  : le message re\u00e7u", 
            "title": "Ex\u00e9cution des handlers"
        }, 
        {
            "location": "/mal_api/#destructeur_4", 
            "text": "D\u00e9truit le routeur et son \u00e9tat.  void mal_routing_destroy(mal_routing_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#union-des-elements", 
            "text": "Une union  mal_element_t  est d\u00e9finie pour permettre le polymorphisme d'\u00e9l\u00e9ment.  union mal_element_t {\n  mal_blob_t *blob_value;\n  mal_boolean_t boolean_value;\n  mal_double_t double_value;\n  mal_float_t float_value;\n  mal_octet_t octet_value;\n  mal_uoctet_t uoctet_value;\n  mal_short_t short_value;\n  mal_ushort_t ushort_value;\n  mal_integer_t integer_value;\n  mal_uinteger_t uinteger_value;\n  mal_long_t long_value;\n  mal_ulong_t ulong_value;\n  mal_string_t *string_value;\n  mal_identifier_t *identifier_value;\n  mal_uri_t *uri_value;\n  mal_time_t time_value;\n  mal_finetime_t finetime_value;\n  mal_duration_t duration_value;\n  int enumerated_value;\n  void *composite_value;\n  void *list_value;\n};", 
            "title": "Union des \u00e9l\u00e9ments"
        }, 
        {
            "location": "/mal_api/#holder-delement", 
            "text": "Cette structure permet de g\u00e9rer le d\u00e9codage en cas de polymorphisme d'\u00e9l\u00e9ment.", 
            "title": "Holder d'\u00e9l\u00e9ment"
        }, 
        {
            "location": "/mal_api/#constructeur_5", 
            "text": "D\u00e9claration :  mal_element_holder_t *mal_element_holder_new(void);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#getters-et-setters_1", 
            "text": "bool mal_element_holder_get_presence_flag(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_presence_flag(mal_element_holder_t *self,\n  bool presence_flag);\n\nlong mal_element_holder_get_short_form(mal_element_holder_t *self);\n\nvoid mal_element_holder_set_short_form(mal_element_holder_t *self,\n  long short_form);\n\nunion mal_element_t mal_element_holder_get_value(\n  mal_element_holder_t *self);\n\nvoid mal_element_holder_set_value(mal_element_holder_t *self,\n  union mal_element_t value);", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/mal_api/#destructeur_5", 
            "text": "void mal_element_holder_destroy(mal_element_holder_t **self_p);  Ce destructeur ne lib\u00e8re que l'espace allou\u00e9 pour la structure elle-m\u00eame, mais pas les \u00e9l\u00e9ments de l'union.", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#listes-dattribut-non-pointeur", 
            "text": "Structures de donn\u00e9e d\u00e9finies pour repr\u00e9senter les listes des types d'Attribut qui ne sont pas repr\u00e9sent\u00e9s par un type C pointeur (voir section 2.6).\nCes listes sont sp\u00e9cifiques \u00e0 chaque type d'Attribut non pointeur.\nPour chaque liste, deux tableaux sont d\u00e9finis :   presence_flags  : tableau des flags de pr\u00e9sence pour chacun des \u00e9l\u00e9ments de la liste  content  : tableau contenant les valeurs des \u00e9l\u00e9ments de la liste ; si un \u00e9l\u00e9ment est nul, sa valeur dans le tableau doit \u00eatre affect\u00e9e avec n'importe quelle valeur.   La taille des tableaux  presence_flags  et  content  doit \u00eatre la m\u00eame.", 
            "title": "Listes d'Attribut non pointeur"
        }, 
        {
            "location": "/mal_api/#constructeur_6", 
            "text": "D\u00e9claration :  mal_ attribute _list_t *mal_ attribute _list_new(\n  unsigned int element_count);  Param\u00e8tres :   element_count  : nombre d'\u00e9l\u00e9ments dans la liste", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#getter", 
            "text": "Des fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :  unsigned int mal_ attribute _list_get_element_count(\n  mal_ attribute _list_t *self);\n\nbool *mal_ attribute _list_get_presence_flags(\n  mal_ attribute _list_t *self);\n\nmal_ attribute _t *mal_ attribute _list_get_content(\n  mal_ attribute _list_t *self);", 
            "title": "Getter"
        }, 
        {
            "location": "/mal_api/#destructeur_6", 
            "text": "D\u00e9truit la liste et son contenu (tableau des flags de pr\u00e9sence et tableau des valeurs).  void mal_ attribute _list_destroy(mal_ attribute _list_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#listes-dattribut-pointeur", 
            "text": "Structures de donn\u00e9e d\u00e9finies pour repr\u00e9senter les listes des types d'Attribut qui sont repr\u00e9sent\u00e9s par un type C pointeur (voir section 2.6).", 
            "title": "Listes d'Attribut pointeur"
        }, 
        {
            "location": "/mal_api/#constructeur_7", 
            "text": "D\u00e9claration :  mal_ attribute _list_t *mal_ attribute _list_new(\n  unsigned int element_count);  Param\u00e8tres :   element_count  : nombre d'\u00e9l\u00e9ments dans la liste", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_api/#getters", 
            "text": "Des fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :  unsigned int mal_ attribute _list_get_element_count(\n  mal_ attribute _list_t *self);\n\nmal_ attribute _t **mal_ attribute _list_get_content(\n  mal_ attribute _list_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/mal_api/#destructeur_7", 
            "text": "D\u00e9truit la liste, son contenu (tableau de pointeurs) et les \u00e9l\u00e9ments de la liste.  void mal_ attribute _list_destroy(mal_ attribute _list_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_api/#listes-de-composite", 
            "text": "Voir section 9.6.", 
            "title": "Listes de Composite"
        }, 
        {
            "location": "/mal_api/#listes-denumere", 
            "text": "Voir section 9.7.", 
            "title": "Listes d'\u00e9num\u00e9r\u00e9"
        }, 
        {
            "location": "/mal_api/#etapes-dinteraction", 
            "text": "Une constante est d\u00e9finie pour chaque \u00e9tape d'interaction :  #define MAL_IP_STAGE_SEND 1\n#define MAL_IP_STAGE_SUBMIT 1\n#define MAL_IP_STAGE_SUBMIT_ACK 2\n#define MAL_IP_STAGE_REQUEST 1\n#define MAL_IP_STAGE_REQUEST_RESPONSE 2\n#define MAL_IP_STAGE_INVOKE 1\n#define MAL_IP_STAGE_INVOKE_ACK 2\n#define MAL_IP_STAGE_INVOKE_RESPONSE 3\n#define MAL_IP_STAGE_PROGRESS 1\n#define MAL_IP_STAGE_PROGRESS_ACK 2\n#define MAL_IP_STAGE_PROGRESS_UPDATE 3\n#define MAL_IP_STAGE_PROGRESS_RESPONSE 4\n#define MAL_IP_STAGE_PUBSUB_REGISTER 1\n#define MAL_IP_STAGE_PUBSUB_REGISTER_ACK 2\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER 3\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER_ACK 4\n#define MAL_IP_STAGE_PUBSUB_PUBLISH 5\n#define MAL_IP_STAGE_PUBSUB_NOTIFY 6\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER 7\n#define MAL_IP_STAGE_PUBSUB_DEREGISTER_ACK 8\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER 9\n#define MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER_ACK 10", 
            "title": "Etapes d'interaction"
        }, 
        {
            "location": "/mal_transport/", 
            "text": "APIs de transport\n\n\nLes APIs de transport sont d\u00e9finies de mani\u00e8re sp\u00e9cifique \u00e0 un \u00ab binding \u00bb, par exemple MALZMQ.\n\n\nPlusieurs fonctions virtuelles sont impos\u00e9es par la couche MAL, par exemple la fonction d'envoi de message (section 7.1.8). Ainsi, le code applicatif peut envoyer un message sans d\u00e9pendre de l'API sp\u00e9cifique du transport utilis\u00e9.\n\n\nLe code des services (consumer, provider) ne d\u00e9pend pas de l'API de transport. Il utilise seulement l'API MAL.\nLe nom donn\u00e9 en C au transport (binding) MALZMQ est : \nmalzmq\n\nCe nom est une cha\u00eene de caract\u00e8res utilis\u00e9e pour le nommage des APIs.\n\n\nContexte de Binding\n\n\nbinding\n_ctx.h\n\n\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\nbinding\n_ctx_t *\nbinding\n_ctx_new(mal_ctx_t *mal_ctx);\n\n\n\n\nParam\u00e8tre :\n\n\n\n\nmal_ctx\n : le context MAL utilisant le transport cr\u00e9\u00e9\n\n\n\n\nR\u00e9sultat :\n\n\nle transport cr\u00e9\u00e9\n\n\nCr\u00e9ation d'une URI\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour cr\u00e9er une URI  (voir 7.1.1).\n\n\nD\u00e9claration :\n\n\nmal_uri_t *\nbinding\n_ctx_create_uri(void *self, char *id);\n\n\n\n\nParam\u00e8tre :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nid\n : identifiant unique dans le contexte MALZMQ\n\n\n\n\nR\u00e9sultat :\n\n\nl'URI cr\u00e9\u00e9e\n\n\nCr\u00e9ation de end-point\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour cr\u00e9er un end-point  (voir 7.1.2).\n\n\nD\u00e9claration :\n\n\nvoid *\nbinding\n_ctx_create_endpoint(\n  void *self,\n  mal_endpoint_t *endpoint);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nmal_endpoint\n : end-point MAL correspondant au end-point physique du transport\n\n\n\n\nRetour :\n\n\nLa r\u00e9f\u00e9rence du end-point cr\u00e9\u00e9 par le transport\n\n\nEnvoi de message MAL\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour envoyer un message MAL (voir 7.1.8).\n\n\nD\u00e9claration :\n\n\nint \nbinding\n_ctx_send_message(void *self,\n  mal_endpoint_t *mal_endpoint, mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nmal_endpoint\n : le end-point qui envoie le message\n\n\nmessage\n : message MAL \u00e0 envoyer\n\n\n\n\nR\u00e9sultat :\n\n\nCode d'erreur\n\n\nDestruction de message MAL\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour d\u00e9truire un message MAL (voir 7.1.10).\n\n\nD\u00e9claration :\n\n\nint \nbinding\n_ctx_destroy_message(void *self, mal_message_t *message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nmessage\n : message MAL \u00e0 d\u00e9truire\n\n\n\n\nR\u00e9sultat :\n\n\nCode d'erreur\n\n\nDestruction de end-point\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour d\u00e9truire un end-point (voir 7.1.3).\n\n\nD\u00e9claration :\n\n\nvoid \nbinding\n_ctx_destroy_endpoint(void *self, void **endpoint_p);\n\n\n\n\nCr\u00e9ation de poller\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour cr\u00e9er un end-point  (voir 7.1.4).\n\n\nD\u00e9claration :\n\n\nvoid *\nbinding\n_ctx_create_poller(\n  void *self,\n  mal_poller_t *poller);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nmal_poller\n : poller MAL correspondant au poller physique du transport\n\n\n\n\nRetour :\n\n\nLa r\u00e9f\u00e9rence du poller cr\u00e9\u00e9 par le transport\n\n\nAjout / Suppression de end-point au poller\n\n\nCes fonctions doivent \u00eatre conformes aux fonctions virtuelles d\u00e9finies par l'API MAL pour ajouter ou supprimer un end-point du poller (voir 7.1.5).\n\n\nD\u00e9claration :\n\n\nint malzmq_ctx_poller_add_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\nint malzmq_ctx_poller_del_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nmal_poller\n : poller MAL correspondant au poller physique du transport\n\n\nmal_endpoint\n : end-point MAL \u00e0 ajouter ou supprimer du poller\n\n\n\n\nRetour : \n\n\nCode d'erreur\n\n\nAttente de message sur le poller\n\n\nCes fonctions doivent \u00eatre conformes aux fonctions virtuelles d\u00e9finies par l'API MAL pour attendre la r\u00e9ception d'un message sur un des end-points du poller (voir 7.1.6).\n\n\nD\u00e9claration :\n\n\nint malzmq_ctx_poller_wait(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : la r\u00e9f\u00e9rence du module de transport\n\n\nmal_poller\n : poller MAL correspondant au poller physique du transport\n\n\nmal_endpoint\n : le end-point sur lequel un message est en attente de r\u00e9ception\n\n\ntimeout\n : le temps d'attente maximum, \u00e9ventuellement infini (-1)\n\n\n\n\nRetour : \n\n\nCode d'erreur\n\n\nDestruction du poller\n\n\nCette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour d\u00e9truire un poller (voir 7.1.7).\n\n\nD\u00e9claration :\n\n\nvoid \nbinding\n_ctx_destroy_poller(void *self, void **poller_p);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit le contexte MALZMQ.\n\n\nvoid \nbinding\n_ctx_destroy(\nbinding\n_ctx_t **self_p);", 
            "title": "Transport"
        }, 
        {
            "location": "/mal_transport/#apis-de-transport", 
            "text": "Les APIs de transport sont d\u00e9finies de mani\u00e8re sp\u00e9cifique \u00e0 un \u00ab binding \u00bb, par exemple MALZMQ.  Plusieurs fonctions virtuelles sont impos\u00e9es par la couche MAL, par exemple la fonction d'envoi de message (section 7.1.8). Ainsi, le code applicatif peut envoyer un message sans d\u00e9pendre de l'API sp\u00e9cifique du transport utilis\u00e9.  Le code des services (consumer, provider) ne d\u00e9pend pas de l'API de transport. Il utilise seulement l'API MAL.\nLe nom donn\u00e9 en C au transport (binding) MALZMQ est :  malzmq \nCe nom est une cha\u00eene de caract\u00e8res utilis\u00e9e pour le nommage des APIs.", 
            "title": "APIs de transport"
        }, 
        {
            "location": "/mal_transport/#contexte-de-binding", 
            "text": "binding _ctx.h", 
            "title": "Contexte de Binding"
        }, 
        {
            "location": "/mal_transport/#constructeur", 
            "text": "D\u00e9claration :  binding _ctx_t * binding _ctx_new(mal_ctx_t *mal_ctx);  Param\u00e8tre :   mal_ctx  : le context MAL utilisant le transport cr\u00e9\u00e9   R\u00e9sultat :  le transport cr\u00e9\u00e9", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_transport/#creation-dune-uri", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour cr\u00e9er une URI  (voir 7.1.1).  D\u00e9claration :  mal_uri_t * binding _ctx_create_uri(void *self, char *id);  Param\u00e8tre :   self  : la r\u00e9f\u00e9rence du module de transport  id  : identifiant unique dans le contexte MALZMQ   R\u00e9sultat :  l'URI cr\u00e9\u00e9e", 
            "title": "Cr\u00e9ation d'une URI"
        }, 
        {
            "location": "/mal_transport/#creation-de-end-point", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour cr\u00e9er un end-point  (voir 7.1.2).  D\u00e9claration :  void * binding _ctx_create_endpoint(\n  void *self,\n  mal_endpoint_t *endpoint);  Param\u00e8tres :   self  : la r\u00e9f\u00e9rence du module de transport  mal_endpoint  : end-point MAL correspondant au end-point physique du transport   Retour :  La r\u00e9f\u00e9rence du end-point cr\u00e9\u00e9 par le transport", 
            "title": "Cr\u00e9ation de end-point"
        }, 
        {
            "location": "/mal_transport/#envoi-de-message-mal", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour envoyer un message MAL (voir 7.1.8).  D\u00e9claration :  int  binding _ctx_send_message(void *self,\n  mal_endpoint_t *mal_endpoint, mal_message_t *message);  Param\u00e8tres :   self  : la r\u00e9f\u00e9rence du module de transport  mal_endpoint  : le end-point qui envoie le message  message  : message MAL \u00e0 envoyer   R\u00e9sultat :  Code d'erreur", 
            "title": "Envoi de message MAL"
        }, 
        {
            "location": "/mal_transport/#destruction-de-message-mal", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour d\u00e9truire un message MAL (voir 7.1.10).  D\u00e9claration :  int  binding _ctx_destroy_message(void *self, mal_message_t *message);  Param\u00e8tres :   self  : la r\u00e9f\u00e9rence du module de transport  message  : message MAL \u00e0 d\u00e9truire   R\u00e9sultat :  Code d'erreur", 
            "title": "Destruction de message MAL"
        }, 
        {
            "location": "/mal_transport/#destruction-de-end-point", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour d\u00e9truire un end-point (voir 7.1.3).  D\u00e9claration :  void  binding _ctx_destroy_endpoint(void *self, void **endpoint_p);", 
            "title": "Destruction de end-point"
        }, 
        {
            "location": "/mal_transport/#creation-de-poller", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour cr\u00e9er un end-point  (voir 7.1.4).  D\u00e9claration :  void * binding _ctx_create_poller(\n  void *self,\n  mal_poller_t *poller);  Param\u00e8tres :   self  : la r\u00e9f\u00e9rence du module de transport  mal_poller  : poller MAL correspondant au poller physique du transport   Retour :  La r\u00e9f\u00e9rence du poller cr\u00e9\u00e9 par le transport", 
            "title": "Cr\u00e9ation de poller"
        }, 
        {
            "location": "/mal_transport/#ajout-suppression-de-end-point-au-poller", 
            "text": "Ces fonctions doivent \u00eatre conformes aux fonctions virtuelles d\u00e9finies par l'API MAL pour ajouter ou supprimer un end-point du poller (voir 7.1.5).  D\u00e9claration :  int malzmq_ctx_poller_add_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);\n\nint malzmq_ctx_poller_del_endpoint(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t *mal_endpoint);  Param\u00e8tres :   self  : la r\u00e9f\u00e9rence du module de transport  mal_poller  : poller MAL correspondant au poller physique du transport  mal_endpoint  : end-point MAL \u00e0 ajouter ou supprimer du poller   Retour :   Code d'erreur", 
            "title": "Ajout / Suppression de end-point au poller"
        }, 
        {
            "location": "/mal_transport/#attente-de-message-sur-le-poller", 
            "text": "Ces fonctions doivent \u00eatre conformes aux fonctions virtuelles d\u00e9finies par l'API MAL pour attendre la r\u00e9ception d'un message sur un des end-points du poller (voir 7.1.6).  D\u00e9claration :  int malzmq_ctx_poller_wait(\n    void *self,\n    mal_poller_t *mal_poller,\n    mal_endpoint_t **mal_endpoint,\n    int timeout);  Param\u00e8tres :   self  : la r\u00e9f\u00e9rence du module de transport  mal_poller  : poller MAL correspondant au poller physique du transport  mal_endpoint  : le end-point sur lequel un message est en attente de r\u00e9ception  timeout  : le temps d'attente maximum, \u00e9ventuellement infini (-1)   Retour :   Code d'erreur", 
            "title": "Attente de message sur le poller"
        }, 
        {
            "location": "/mal_transport/#destruction-du-poller", 
            "text": "Cette fonction doit \u00eatre conforme \u00e0 la fonction virtuelle d\u00e9finie par l'API MAL pour d\u00e9truire un poller (voir 7.1.7).  D\u00e9claration :  void  binding _ctx_destroy_poller(void *self, void **poller_p);", 
            "title": "Destruction du poller"
        }, 
        {
            "location": "/mal_transport/#destructeur", 
            "text": "D\u00e9truit le contexte MALZMQ.  void  binding _ctx_destroy( binding _ctx_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/area/", 
            "text": "APIs d'area\n\n\nLes noms de type (de donn\u00e9e) ou d'op\u00e9ration sont toujours pr\u00e9fix\u00e9s par les nom d'area et de service o\u00f9 est d\u00e9clar\u00e9 le type ou l'op\u00e9ration. Deux notations sont utilis\u00e9es pour sp\u00e9cifier ce format de nommage. La premi\u00e8re consiste \u00e0 inclure syst\u00e9matiquement les noms d'Area et de service, le nom de service n'existant pas pour les types d\u00e9finis dans des Areas (il est donc entre crochets pour les types) :\n\n\narea\n_[\nservice\n_]\ntype\n\n\narea\n_\nservice\n_\noperation\n\n\n\n\n\nLa seconde notation n'indique que le nom de type ou d'op\u00e9ration avec le pr\u00e9fix \nqf\n signifiant \u00ab qualified \u00bb c'est-\u00e0-dire incluant les noms d'Area et de service. Cette notation est plus compacte :\n\n\nqftype\n\n\nqfop\n\n\n\n\n\nD\u00e9finition de constantes\n\n\n#define \nAREA\n_AREA_NUMBER \narea number\n\n#define \nAREA\n_AREA_VERSION \nversion\n\n\n\n\n\nPour chaque service :\n\n\n#define \nAREA\n_\nSERVICE\n_SERVICE_NUMBER \nservice number\n\n\n\n\n\nPour chaque op\u00e9ration de service :\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER \noperation number\n\n\n\n\n\nPour chaque erreur lev\u00e9e par une op\u00e9ration :\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_\nERROR\n_ERROR_NUMBER \nerror number\n\n\n\n\n\nPour chaque type de donn\u00e9e :\n\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM \nshort form\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_LIST_SHORT_FORM \nshort form\n\n\n\n\n\nD\u00e9finition des types\n\n\nEnumeration\n\n\nLa valeur d'un \u00e9num\u00e9r\u00e9 est sa valeur ordinale, qui est \u00e9gale \u00e0 0 pour le premier \u00e9num\u00e9r\u00e9 et qui est incr\u00e9ment\u00e9e de 1 pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.\n\n\ntypedef enum {\n  \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_\nENUMERATED NAME\n,\n} \narea\n_[\nservice\n_]\nenumeration\n_t;\n\n\n\n\nLa valeur num\u00e9rique de l'\u00e9num\u00e9r\u00e9 (sp\u00e9cifi\u00e9e par la d\u00e9finition du service) est r\u00e9solue au travers d'un tableau d'entiers d\u00e9clar\u00e9 statiquement. Ce tableau contient la valeur num\u00e9rique pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.\n\n\nint \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_NUMERIC_VALUES[] = {\n  \nnumeric value\n,\n}\n\n\n\n\nComposite\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ncomposite\n_t\n  \narea\n_[\nservice\n_]\ncomposite\n_t;\n\n\n\n\nListes\n\n\nPour chaque Composite :\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ncomposite\n_list_t\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t;\n\n\n\n\nPour chaque Enumeration :\n\n\ntypedef struct _\narea\n_[\nservice\n_]\nenumeration\n_list_t\n    \narea\n_[\nservice\n_]\nenumeration\n_list_t;\n\n\n\n\nEnvoi de message\n\n\nOp\u00e9ration non Publish/Subscribe\n\n\nPour chaque op\u00e9ration, except\u00e9 si le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies. \n\n\nL'\u00e9tape et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction.\n\n\n\n\n\n\n\n\nFonction\n\n\nEtape\n\n\nR\u00f4le\n\n\n\n\n\n\n\n\n\n\nInitiation d'interaction\n\n\nsend, submit, request, invoke, progress\n\n\nConsumer\n\n\n\n\n\n\nR\u00e9sultat d'interaction\n\n\nsubmit_ack, request_response invoke_ack, invoke_response, progress_ack, progress_update, progress_response\n\n\nProvider\n\n\n\n\n\n\n\n\nD\u00e9clarations :\n\n\nint \narea\n_\nservice\n_\noperation\n_\nfirst stage\n(\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_uri_t *provider_uri);\n\nint \narea\n_\nservice\n_\noperation\n_\nresult stage\n(\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_message_t *result_message, bool is_error_message);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nendpoint\n : le end-point qui envoie le message\n\n\ninit_message\n : le message qui initie l'interaction (premi\u00e8re \u00e9tape)\n\n\nprovider_uri\n : l'URI du provider de service\n\n\nresult_message\n : le message r\u00e9sultat du traitement de l'interaction (seconde \u00e9tape et suivantes)\n\n\nis_error_message\n : flag indiquant si le message renvoie une erreur\n\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nOp\u00e9ration Publish/Subscribe\n\n\nPour chaque op\u00e9ration dont le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies. \n\n\nL'\u00e9tape Pub/Sub et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction. Aucune fonction n'est g\u00e9n\u00e9r\u00e9e pour le r\u00f4le Broker car un Broker est un composant g\u00e9n\u00e9rique qui ne d\u00e9pend pas d'Area particuli\u00e8re (except\u00e9 l'Area MAL).\n\n\n\n\n\n\n\n\nFonction\n\n\nEtape Pub/Sub\n\n\nR\u00f4le\n\n\n\n\n\n\n\n\n\n\nAbonnement\n\n\nRegister\n\n\nSubscriber\n\n\n\n\n\n\nD\u00e9claration de publication\n\n\nPublish Register\n\n\nPublisher\n\n\n\n\n\n\nPublication\n\n\nPublish\n\n\nPublisher\n\n\n\n\n\n\nD\u00e9sabonnement\n\n\nDeregister\n\n\nSubscriber\n\n\n\n\n\n\nArr\u00eat de publication\n\n\nPublish Deregister\n\n\nPublisher\n\n\n\n\n\n\n\n\nD\u00e9clarations :\n\n\nint \narea\n_\nservice\n_\noperation\n_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint \narea\n_\nservice\n_\noperation\n_publish_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint \narea\n_\nservice\n_\noperation\n_publish(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri,\n  long initial_publish_register_tid);\n\nint \narea\n_\nservice\n_\noperation\n_deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint \narea\n_\nservice\n_\noperation\n_publish_deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nendpoint\n : Le end-point qui envoie le message\n\n\nmessage\n : le message relatif \u00e0 l'\u00e9tape Pub/Sub\n\n\nbroker_uri\n : l'URI du broker\n\n\ninitial_publish_register_tid\n : identifiant de transaction du premier message Publish Register envoy\u00e9\n\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nEncodage\n\n\nCes fonctions sont d\u00e9finies pour chaque op\u00e9ration, chaque \u00e9l\u00e9ment de corps de message et chaque erreur retourn\u00e9e par l'op\u00e9ration. Les \u00e9l\u00e9ments sont identifi\u00e9s par leur index dans le corps de message comme sp\u00e9cifi\u00e9 par la d\u00e9finition MAL (XML) du service.\n\n\nEn Pub/Sub, l'index des \u00e9l\u00e9ments commence \u00e0 0 avec la premi\u00e8re liste d'Update. Les \u00e9l\u00e9ments pr\u00e9c\u00e9dents comme par exemple l'Identifier (message Notify) ou l'UpdateHeaderList (messages Publish et Notify) ne sont pas compt\u00e9s.\n\n\nLes messages d'erreur n'ont au plus qu'un seul \u00e9l\u00e9ment (identifi\u00e9 par le champ extraInformation). Il n'y a donc pas d'index.\n\n\nPolymorphisme du dernier \u00e9l\u00e9ment de corps de message\n\n\nSi l'\u00e9l\u00e9ment est le dernier du corps de message :\n\n\n\n\nSi le type d\u00e9clar\u00e9 est MAL::Attribute, alors l'\u00e9l\u00e9ment est transmis avec le type de l'union 'mal_attribute_t'.\n\n\nSi le type d\u00e9clar\u00e9 est MAL::Element, un composite abstrait, ou une liste d'un type abstrait (y compris MAL::Attribute), alors une fonction doit \u00eatre d\u00e9finie pour chaque type final conforme au type abstrait. Le nom du type (qftype) est ajout\u00e9 au nom de la fonction apr\u00e8s un s\u00e9parateur '_' :\n\n\n\n\nnom de la fonction d encodage\n_\nqftype\n(\nparam\u00e8tres\n);\n\n\n\n\nLes fonctions d'encodage du message d'erreur suivront \u00e9galement la m\u00eame convention de nommage, que le type du champ extraInformation soit polymorphique ou non. Cela permet de distinguer les fonctions des \u00e9ventuelles erreurs multiples.\n\n\nCalcul de la taille d'encodage d'un \u00e9l\u00e9ment de corps de message\n\n\nFonction d'ajout de la taille d'encodage \u00e0 une valeur initiale.\n\n\nD\u00e9claration :\n\n\n\n\n\n\nSi l'op\u00e9ration n'est pas Pub/Sub :\n\n\n\n\n\n\nEn cas de polymorphisme d'Attribut :\n\n\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length);\n\n\n\n\n\n\nSinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  \nqftype\n_t element, unsigned int *encoding_length);\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, \nqftype\n_[list_]t *element,\n  unsigned int *encoding_length);\n\n\n\n\n\n\nSi l'op\u00e9ration est Pub/Sub :\n\n\n\n\nint \nqfop\n_update_add_encoding_length[_\nindex\n][_\nqftype\n_list](\n    int encoding_format_code, void * encoder,\n    \nqftype\n_list_t *element,\n    unsigned int *encoding_length);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nencoding_format_code\n : code du format d'encodage\n\n\nencoder\n : configuration du module d'encodage\n\n\npresence_flag\n : champ de pr\u00e9sence, n\u00e9cessaire si le type de l'\u00e9l\u00e9ment n'est pas un pointeur\n\n\nelement\n : \u00e9l\u00e9ment \u00e0 encoder\n\n\nencoding_length\n : valeur initiale et r\u00e9sultat de la fonction d'ajout\n\n\n\n\nR\u00e9sultat : \n\n\ncode d'erreur\n\n\nEncodage d'un \u00e9l\u00e9ment de corps de message\n\n\nD\u00e9claration :\n\n\n\n\nSi l'op\u00e9ration n'est pas Pub/Sub :\n\n\nEn cas de polymorphisme d'Attribut :\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);\n\n\n\n\n\n\nSinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, \nqftype\n_t element);\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, \nqftype\n_[list_]t *element);\n\n\n\n\n\n\nSi l'op\u00e9ration est Pub/Sub :\n\n\n\n\nint \nqfop\n_update_encode[_\nindex\n][_\nqftype\n_list](\n    int encoding_format_code, char *bytes,\n    unsigned int *offset, void *encoder, \nqftype\n_list_t *element) {\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nencoding_format_code\n : code du format d'encodage\n\n\nbytes\n : le tableau d'octets dans lequel l'\u00e9l\u00e9ment doit \u00eatre encod\u00e9\n\n\noffset\n : index \u00e0 partir duquel l'\u00e9l\u00e9ment est encod\u00e9, augment\u00e9 en r\u00e9sultat du nombre d'octets encod\u00e9s\n\n\nencoder\n : configuration du module d'encodage\n\n\npresence_flag\n : flag de pr\u00e9sence \u00e0 encoder\n\n\nattribute_tag\n : tag d'Attribut \u00e0 encoder\n\n\nelement\n : \u00e9l\u00e9ment \u00e0 encoder\n\n\n\n\nD\u00e9codage d'un \u00e9l\u00e9ment de corps de message\n\n\nD\u00e9claration :\n\n\n\n\nSi l'op\u00e9ration n'est pas Pub/Sub :\n\n\nEn cas de polymorphisme d'Attribut :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);\n\n\n\n\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment et/ou pour un message d'erreur :\n\n\n\n\nint \nqfop\n_\nstage|error\n_decode[_\nindex\n](\n  int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder);\n\n\n\n\n\n\nSi le type de l'\u00e9l\u00e9ment est connu :\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res, \nqftype\n_t *element_res);\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, \nqftype\n_[list_]t **element_res);\n\n\n\n\n\n\nSi l'op\u00e9ration est Pub/Sub :\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment :\n\n\n\n\nint \nqfop\n_update_decode[_\nindex\n](int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder);\n\n\n\n\n\n\nSi le type de l'update est connu :\n\n\n\n\nint \nqfop\n_update_decode[_\nindex\n](int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  \nqftype\n_list_t **element_res);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nencoding_format_code\n : code du format d'encodage\n\n\nbytes\n : le tableau d'octets \u00e0 partir duquel l'\u00e9l\u00e9ment doit \u00eatre d\u00e9cod\u00e9\n\n\noffset\n : index \u00e0 partir duquel l'\u00e9l\u00e9ment est d\u00e9cod\u00e9, augment\u00e9 en r\u00e9sultat du nombre d'octets d\u00e9cod\u00e9s\n\n\ndecoder\n : configuration du module de d\u00e9codage\n\n\npresence_flag_res\n : flag de pr\u00e9sence d\u00e9cod\u00e9\n\n\nattribute_tag_res\n : tag d'Attribut d\u00e9cod\u00e9\n\n\nelement_res\n : \u00e9l\u00e9ment d\u00e9cod\u00e9\n\n\nelement_holder\n : \u00e9l\u00e9ment d\u00e9cod\u00e9\n\n\n\n\nAllocation m\u00e9moire\n\n\nLes primitives de d\u00e9codage allouent de la m\u00e9moire pour certains param\u00e8tres (attributs pointeurs, composites, listes, et ce r\u00e9cursivement. Ces param\u00e8tres doivent en final \u00eatre d\u00e9truits par l'appel des fonctions destroy adapt\u00e9es, qui assurent la lib\u00e9ration r\u00e9cursive de la m\u00e9moire.\n\n\nEn cas de retour en erreur d'une fonction de d\u00e9codage, il peut y avoir eu allocation partielle d'un ensemble d'\u00e9l\u00e9ments. Dans ce cas le param\u00e8tre partiellement d\u00e9cod\u00e9 est retourn\u00e9 et doit \u00e9galement \u00eatre d\u00e9truit par l'appel \u00e0 la fonction destroy.\n\n\nLa destruction de la m\u00e9moire allou\u00e9e lors du d\u00e9codage d'un \u00e9l\u00e9ment polymorphique au travers d'une structure mal_holder_t est particuli\u00e8re. Le destructeur de la structure ne lib\u00e9rant pas le contenu, il faut retrouv\u00e9 le type effectif de l'\u00e9l\u00e9ment allou\u00e9 et appeler le constructeur sp\u00e9cifique de l'\u00e9l\u00e9ment.\n\n\nComposite\n\n\nUne classe est g\u00e9n\u00e9r\u00e9e pour chaque Composite.\n\n\nConstructeur\n\n\narea\n_[\nservice\n_]\ncomposite\n_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_new(void);\n\n\n\n\nGetters et setters\n\n\nL'affectation du flag de pr\u00e9sence est r\u00e9alis\u00e9e de mani\u00e8re explicite par des fonctions \nsetter\n d\u00e9di\u00e9es. Le flag de pr\u00e9sence ne doit pas \u00eatre modifi\u00e9 implicitement par le \nsetter\n de la valeur du champ.\n\n\nPour chaque champ, les fonctions 'setter' et 'getter' d'acc\u00e8s \u00e0 la valeur du champ sont d\u00e9finies :\n\n\nfield type\n \narea\n_[\nservice\n_]\ncomposite\n_get_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\nvoid \narea\n_[\nservice\n_]\ncomposite\n_set_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nfield type\n \nfield\n);\n\n\n\n\nSi le champ n'est pas un pointeur (valeur NULL interdite), des fonctions 'setter' et 'getter' d'acc\u00e8s aux flags de pr\u00e9sence sont ajout\u00e9es :\n\n\nbool \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_is_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, bool is_present);\n\n\n\n\nEn cas de polymorphisme d'attribut, des fonctions 'setter' et 'getter' d'acc\u00e8s aux tags d'Attribut sont ajout\u00e9es :\n\n\nunsigned char \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_get_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, unsigned char attribute_tag);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la structure et les structures contenues dedans (composites, listes, Attributs pointeurs).\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_t **self_p);\n\n\n\n\nListes de Composite\n\n\nStructures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Composite.\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\narea\n_[\nservice\n_]\ncomposite\n_list_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_list_new(unsigned int element_count);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nelement_count\n\n\n\n\nGetters\n\n\nDes fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :\n\n\nunsigned int \narea\n_[\nservice\n_]\ncomposite\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\narea\n_[\nservice\n_]\ncomposite\n_t **\narea\n_[\nservice\n_]\ncomposite\n_list_get_content(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste, son contenu et les \u00e9l\u00e9ments de la liste.\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t **self_p);\n\n\n\n\nListes d'\u00e9num\u00e9r\u00e9\n\n\nStructures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Enumeration.\n\n\nConstructeur\n\n\nD\u00e9claration :\n\n\narea\n_[\nservice\n_]\nenum\n_list_t\n  *\narea\n_[\nservice\n_]\nenum\n_list_new(unsigned int element_count);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nelement_count\n\n\n\n\nGetters\n\n\nDes fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :\n\n\nunsigned int \narea\n_[\nservice\n_]\nenum\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\nenum\n_list_t *self);\nbool *\narea\n_[\nservice\n_]\nenum\n_list_get_presence_flags(\n  \narea\n_[\nservice\n_]\nenum\n_list_t *self);\n\narea\n_[\nservice\n_]\nenum\n_t *\narea\n_[\nservice\n_]\nenum\n_list_get_content(\n  \narea\n_[\nservice\n_]\nenum\n_list_t *self);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste et son contenu.\n\n\nvoid \narea\n_[\nservice\n_]\nenum\n_list_destroy(\n    \narea\n_[\nservice\n_]\nenum\n_list_t **self_p);", 
            "title": "Area"
        }, 
        {
            "location": "/area/#apis-darea", 
            "text": "Les noms de type (de donn\u00e9e) ou d'op\u00e9ration sont toujours pr\u00e9fix\u00e9s par les nom d'area et de service o\u00f9 est d\u00e9clar\u00e9 le type ou l'op\u00e9ration. Deux notations sont utilis\u00e9es pour sp\u00e9cifier ce format de nommage. La premi\u00e8re consiste \u00e0 inclure syst\u00e9matiquement les noms d'Area et de service, le nom de service n'existant pas pour les types d\u00e9finis dans des Areas (il est donc entre crochets pour les types) :  area _[ service _] type  area _ service _ operation   La seconde notation n'indique que le nom de type ou d'op\u00e9ration avec le pr\u00e9fix  qf  signifiant \u00ab qualified \u00bb c'est-\u00e0-dire incluant les noms d'Area et de service. Cette notation est plus compacte :  qftype  qfop", 
            "title": "APIs d'area"
        }, 
        {
            "location": "/area/#definition-de-constantes", 
            "text": "#define  AREA _AREA_NUMBER  area number \n#define  AREA _AREA_VERSION  version   Pour chaque service :  #define  AREA _ SERVICE _SERVICE_NUMBER  service number   Pour chaque op\u00e9ration de service :  #define  AREA _ SERVICE _ OPERATION _OPERATION_NUMBER  operation number   Pour chaque erreur lev\u00e9e par une op\u00e9ration :  #define  AREA _ SERVICE _ OPERATION _ ERROR _ERROR_NUMBER  error number   Pour chaque type de donn\u00e9e :  #define  AREA _[ SERVICE _] TYPE _SHORT_FORM  short form \n#define  AREA _[ SERVICE _] TYPE _LIST_SHORT_FORM  short form", 
            "title": "D\u00e9finition de constantes"
        }, 
        {
            "location": "/area/#definition-des-types", 
            "text": "", 
            "title": "D\u00e9finition des types"
        }, 
        {
            "location": "/area/#enumeration", 
            "text": "La valeur d'un \u00e9num\u00e9r\u00e9 est sa valeur ordinale, qui est \u00e9gale \u00e0 0 pour le premier \u00e9num\u00e9r\u00e9 et qui est incr\u00e9ment\u00e9e de 1 pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.  typedef enum {\n   AREA _[ SERVICE _] ENUMERATION _ ENUMERATED NAME ,\n}  area _[ service _] enumeration _t;  La valeur num\u00e9rique de l'\u00e9num\u00e9r\u00e9 (sp\u00e9cifi\u00e9e par la d\u00e9finition du service) est r\u00e9solue au travers d'un tableau d'entiers d\u00e9clar\u00e9 statiquement. Ce tableau contient la valeur num\u00e9rique pour chaque \u00e9num\u00e9r\u00e9 dans l'ordre de leur d\u00e9claration.  int  AREA _[ SERVICE _] ENUMERATION _NUMERIC_VALUES[] = {\n   numeric value ,\n}", 
            "title": "Enumeration"
        }, 
        {
            "location": "/area/#composite", 
            "text": "typedef struct _ area _[ service _] composite _t\n   area _[ service _] composite _t;", 
            "title": "Composite"
        }, 
        {
            "location": "/area/#listes", 
            "text": "Pour chaque Composite :  typedef struct _ area _[ service _] composite _list_t\n     area _[ service _] composite _list_t;  Pour chaque Enumeration :  typedef struct _ area _[ service _] enumeration _list_t\n     area _[ service _] enumeration _list_t;", 
            "title": "Listes"
        }, 
        {
            "location": "/area/#envoi-de-message", 
            "text": "", 
            "title": "Envoi de message"
        }, 
        {
            "location": "/area/#operation-non-publishsubscribe", 
            "text": "Pour chaque op\u00e9ration, except\u00e9 si le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies.   L'\u00e9tape et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction.     Fonction  Etape  R\u00f4le      Initiation d'interaction  send, submit, request, invoke, progress  Consumer    R\u00e9sultat d'interaction  submit_ack, request_response invoke_ack, invoke_response, progress_ack, progress_update, progress_response  Provider     D\u00e9clarations :  int  area _ service _ operation _ first stage (\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_uri_t *provider_uri);\n\nint  area _ service _ operation _ result stage (\n  mal_endpoint_t *endpoint, mal_message_t *init_message,\n  mal_message_t *result_message, bool is_error_message);  Param\u00e8tres :   endpoint  : le end-point qui envoie le message  init_message  : le message qui initie l'interaction (premi\u00e8re \u00e9tape)  provider_uri  : l'URI du provider de service  result_message  : le message r\u00e9sultat du traitement de l'interaction (seconde \u00e9tape et suivantes)  is_error_message  : flag indiquant si le message renvoie une erreur   R\u00e9sultat :   code d'erreur", 
            "title": "Op\u00e9ration non Publish/Subscribe"
        }, 
        {
            "location": "/area/#operation-publishsubscribe", 
            "text": "Pour chaque op\u00e9ration dont le pattern d'interaction est Publish/Subscribe, les fonctions d'envoi de message list\u00e9es dans le tableau ci-dessous doivent \u00eatre d\u00e9finies.   L'\u00e9tape Pub/Sub et le r\u00f4le de l'application MAL appelant la fonction sont sp\u00e9cifi\u00e9s pour chaque fonction. Aucune fonction n'est g\u00e9n\u00e9r\u00e9e pour le r\u00f4le Broker car un Broker est un composant g\u00e9n\u00e9rique qui ne d\u00e9pend pas d'Area particuli\u00e8re (except\u00e9 l'Area MAL).     Fonction  Etape Pub/Sub  R\u00f4le      Abonnement  Register  Subscriber    D\u00e9claration de publication  Publish Register  Publisher    Publication  Publish  Publisher    D\u00e9sabonnement  Deregister  Subscriber    Arr\u00eat de publication  Publish Deregister  Publisher     D\u00e9clarations :  int  area _ service _ operation _register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint  area _ service _ operation _publish_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint  area _ service _ operation _publish(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri,\n  long initial_publish_register_tid);\n\nint  area _ service _ operation _deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);\n\nint  area _ service _ operation _publish_deregister(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri);  Param\u00e8tres :   endpoint  : Le end-point qui envoie le message  message  : le message relatif \u00e0 l'\u00e9tape Pub/Sub  broker_uri  : l'URI du broker  initial_publish_register_tid  : identifiant de transaction du premier message Publish Register envoy\u00e9   R\u00e9sultat :   code d'erreur", 
            "title": "Op\u00e9ration Publish/Subscribe"
        }, 
        {
            "location": "/area/#encodage", 
            "text": "Ces fonctions sont d\u00e9finies pour chaque op\u00e9ration, chaque \u00e9l\u00e9ment de corps de message et chaque erreur retourn\u00e9e par l'op\u00e9ration. Les \u00e9l\u00e9ments sont identifi\u00e9s par leur index dans le corps de message comme sp\u00e9cifi\u00e9 par la d\u00e9finition MAL (XML) du service.  En Pub/Sub, l'index des \u00e9l\u00e9ments commence \u00e0 0 avec la premi\u00e8re liste d'Update. Les \u00e9l\u00e9ments pr\u00e9c\u00e9dents comme par exemple l'Identifier (message Notify) ou l'UpdateHeaderList (messages Publish et Notify) ne sont pas compt\u00e9s.  Les messages d'erreur n'ont au plus qu'un seul \u00e9l\u00e9ment (identifi\u00e9 par le champ extraInformation). Il n'y a donc pas d'index.", 
            "title": "Encodage"
        }, 
        {
            "location": "/area/#polymorphisme-du-dernier-element-de-corps-de-message", 
            "text": "Si l'\u00e9l\u00e9ment est le dernier du corps de message :   Si le type d\u00e9clar\u00e9 est MAL::Attribute, alors l'\u00e9l\u00e9ment est transmis avec le type de l'union 'mal_attribute_t'.  Si le type d\u00e9clar\u00e9 est MAL::Element, un composite abstrait, ou une liste d'un type abstrait (y compris MAL::Attribute), alors une fonction doit \u00eatre d\u00e9finie pour chaque type final conforme au type abstrait. Le nom du type (qftype) est ajout\u00e9 au nom de la fonction apr\u00e8s un s\u00e9parateur '_' :   nom de la fonction d encodage _ qftype ( param\u00e8tres );  Les fonctions d'encodage du message d'erreur suivront \u00e9galement la m\u00eame convention de nommage, que le type du champ extraInformation soit polymorphique ou non. Cela permet de distinguer les fonctions des \u00e9ventuelles erreurs multiples.", 
            "title": "Polymorphisme du dernier \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#calcul-de-la-taille-dencodage-dun-element-de-corps-de-message", 
            "text": "Fonction d'ajout de la taille d'encodage \u00e0 une valeur initiale.  D\u00e9claration :    Si l'op\u00e9ration n'est pas Pub/Sub :    En cas de polymorphisme d'Attribut :    int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length);   Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :  Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n   qftype _t element, unsigned int *encoding_length);   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder,  qftype _[list_]t *element,\n  unsigned int *encoding_length);   Si l'op\u00e9ration est Pub/Sub :   int  qfop _update_add_encoding_length[_ index ][_ qftype _list](\n    int encoding_format_code, void * encoder,\n     qftype _list_t *element,\n    unsigned int *encoding_length);  Param\u00e8tres :   encoding_format_code  : code du format d'encodage  encoder  : configuration du module d'encodage  presence_flag  : champ de pr\u00e9sence, n\u00e9cessaire si le type de l'\u00e9l\u00e9ment n'est pas un pointeur  element  : \u00e9l\u00e9ment \u00e0 encoder  encoding_length  : valeur initiale et r\u00e9sultat de la fonction d'ajout   R\u00e9sultat :   code d'erreur", 
            "title": "Calcul de la taille d'encodage d'un \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#encodage-dun-element-de-corps-de-message", 
            "text": "D\u00e9claration :   Si l'op\u00e9ration n'est pas Pub/Sub :  En cas de polymorphisme d'Attribut :   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);   Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :  Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag,  qftype _t element);   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder,  qftype _[list_]t *element);   Si l'op\u00e9ration est Pub/Sub :   int  qfop _update_encode[_ index ][_ qftype _list](\n    int encoding_format_code, char *bytes,\n    unsigned int *offset, void *encoder,  qftype _list_t *element) {  Param\u00e8tres :   encoding_format_code  : code du format d'encodage  bytes  : le tableau d'octets dans lequel l'\u00e9l\u00e9ment doit \u00eatre encod\u00e9  offset  : index \u00e0 partir duquel l'\u00e9l\u00e9ment est encod\u00e9, augment\u00e9 en r\u00e9sultat du nombre d'octets encod\u00e9s  encoder  : configuration du module d'encodage  presence_flag  : flag de pr\u00e9sence \u00e0 encoder  attribute_tag  : tag d'Attribut \u00e0 encoder  element  : \u00e9l\u00e9ment \u00e0 encoder", 
            "title": "Encodage d'un \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#decodage-dun-element-de-corps-de-message", 
            "text": "D\u00e9claration :   Si l'op\u00e9ration n'est pas Pub/Sub :  En cas de polymorphisme d'Attribut :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);   En cas de polymorphisme d'\u00e9l\u00e9ment et/ou pour un message d'erreur :   int  qfop _ stage|error _decode[_ index ](\n  int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder);   Si le type de l'\u00e9l\u00e9ment est connu :  Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,  qftype _t *element_res);   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder,  qftype _[list_]t **element_res);   Si l'op\u00e9ration est Pub/Sub :  En cas de polymorphisme d'\u00e9l\u00e9ment :   int  qfop _update_decode[_ index ](int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder);   Si le type de l'update est connu :   int  qfop _update_decode[_ index ](int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n   qftype _list_t **element_res);  Param\u00e8tres :   encoding_format_code  : code du format d'encodage  bytes  : le tableau d'octets \u00e0 partir duquel l'\u00e9l\u00e9ment doit \u00eatre d\u00e9cod\u00e9  offset  : index \u00e0 partir duquel l'\u00e9l\u00e9ment est d\u00e9cod\u00e9, augment\u00e9 en r\u00e9sultat du nombre d'octets d\u00e9cod\u00e9s  decoder  : configuration du module de d\u00e9codage  presence_flag_res  : flag de pr\u00e9sence d\u00e9cod\u00e9  attribute_tag_res  : tag d'Attribut d\u00e9cod\u00e9  element_res  : \u00e9l\u00e9ment d\u00e9cod\u00e9  element_holder  : \u00e9l\u00e9ment d\u00e9cod\u00e9", 
            "title": "D\u00e9codage d'un \u00e9l\u00e9ment de corps de message"
        }, 
        {
            "location": "/area/#allocation-memoire", 
            "text": "Les primitives de d\u00e9codage allouent de la m\u00e9moire pour certains param\u00e8tres (attributs pointeurs, composites, listes, et ce r\u00e9cursivement. Ces param\u00e8tres doivent en final \u00eatre d\u00e9truits par l'appel des fonctions destroy adapt\u00e9es, qui assurent la lib\u00e9ration r\u00e9cursive de la m\u00e9moire.  En cas de retour en erreur d'une fonction de d\u00e9codage, il peut y avoir eu allocation partielle d'un ensemble d'\u00e9l\u00e9ments. Dans ce cas le param\u00e8tre partiellement d\u00e9cod\u00e9 est retourn\u00e9 et doit \u00e9galement \u00eatre d\u00e9truit par l'appel \u00e0 la fonction destroy.  La destruction de la m\u00e9moire allou\u00e9e lors du d\u00e9codage d'un \u00e9l\u00e9ment polymorphique au travers d'une structure mal_holder_t est particuli\u00e8re. Le destructeur de la structure ne lib\u00e9rant pas le contenu, il faut retrouv\u00e9 le type effectif de l'\u00e9l\u00e9ment allou\u00e9 et appeler le constructeur sp\u00e9cifique de l'\u00e9l\u00e9ment.", 
            "title": "Allocation m\u00e9moire"
        }, 
        {
            "location": "/area/#composite_1", 
            "text": "Une classe est g\u00e9n\u00e9r\u00e9e pour chaque Composite.", 
            "title": "Composite"
        }, 
        {
            "location": "/area/#constructeur", 
            "text": "area _[ service _] composite _t\n  * area _[ service _] composite _new(void);", 
            "title": "Constructeur"
        }, 
        {
            "location": "/area/#getters-et-setters", 
            "text": "L'affectation du flag de pr\u00e9sence est r\u00e9alis\u00e9e de mani\u00e8re explicite par des fonctions  setter  d\u00e9di\u00e9es. Le flag de pr\u00e9sence ne doit pas \u00eatre modifi\u00e9 implicitement par le  setter  de la valeur du champ.  Pour chaque champ, les fonctions 'setter' et 'getter' d'acc\u00e8s \u00e0 la valeur du champ sont d\u00e9finies :  field type   area _[ service _] composite _get_ field (\n     area _[ service _] composite _t *self);\nvoid  area _[ service _] composite _set_ field (\n     area _[ service _] composite _t *self,  field type   field );  Si le champ n'est pas un pointeur (valeur NULL interdite), des fonctions 'setter' et 'getter' d'acc\u00e8s aux flags de pr\u00e9sence sont ajout\u00e9es :  bool  area _[ service _] composite _ field _is_present(\n     area _[ service _] composite _t *self);\nvoid  area _[ service _] composite _ field _set_present(\n     area _[ service _] composite _t *self, bool is_present);  En cas de polymorphisme d'attribut, des fonctions 'setter' et 'getter' d'acc\u00e8s aux tags d'Attribut sont ajout\u00e9es :  unsigned char  area _[ service _] composite _ field _get_attribute_tag(\n     area _[ service _] composite _t *self);\nvoid  area _[ service _] composite _ field _set_attribute_tag(\n     area _[ service _] composite _t *self, unsigned char attribute_tag);", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/area/#destructeur", 
            "text": "D\u00e9truit la structure et les structures contenues dedans (composites, listes, Attributs pointeurs).  void  area _[ service _] composite _destroy(\n     area _[ service _] composite _t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/area/#listes-de-composite", 
            "text": "Structures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Composite.", 
            "title": "Listes de Composite"
        }, 
        {
            "location": "/area/#constructeur_1", 
            "text": "D\u00e9claration :  area _[ service _] composite _list_t\n  * area _[ service _] composite _list_new(unsigned int element_count);  Param\u00e8tres :   element_count", 
            "title": "Constructeur"
        }, 
        {
            "location": "/area/#getters", 
            "text": "Des fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :  unsigned int  area _[ service _] composite _list_get_element_count(\n   area _[ service _] composite _list_t *self); area _[ service _] composite _t ** area _[ service _] composite _list_get_content(\n   area _[ service _] composite _list_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/area/#destructeur_1", 
            "text": "D\u00e9truit la liste, son contenu et les \u00e9l\u00e9ments de la liste.  void  area _[ service _] composite _list_destroy(\n     area _[ service _] composite _list_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/area/#listes-denumere", 
            "text": "Structures de liste g\u00e9n\u00e9r\u00e9es pour chaque type Enumeration.", 
            "title": "Listes d'\u00e9num\u00e9r\u00e9"
        }, 
        {
            "location": "/area/#constructeur_2", 
            "text": "D\u00e9claration :  area _[ service _] enum _list_t\n  * area _[ service _] enum _list_new(unsigned int element_count);  Param\u00e8tres :   element_count", 
            "title": "Constructeur"
        }, 
        {
            "location": "/area/#getters_1", 
            "text": "Des fonctions \u00ab getters \u00bb sont d\u00e9finies pour acc\u00e9der aux champs :  unsigned int  area _[ service _] enum _list_get_element_count(\n   area _[ service _] enum _list_t *self);\nbool * area _[ service _] enum _list_get_presence_flags(\n   area _[ service _] enum _list_t *self); area _[ service _] enum _t * area _[ service _] enum _list_get_content(\n   area _[ service _] enum _list_t *self);", 
            "title": "Getters"
        }, 
        {
            "location": "/area/#destructeur_2", 
            "text": "D\u00e9truit la liste et son contenu.  void  area _[ service _] enum _list_destroy(\n     area _[ service _] enum _list_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_actor/", 
            "text": "Mod\u00e8le d'ex\u00e9cution Acteur / Handler\n\n\nL'acteur MAL utilise l'API MAL/C et en particulier les notions de \npoller\n, de \nend-point\n et de \nhandler\n. Il repose sur la notion d'acteur CZMQ.\n\n\nActeur\n\n\nUn acteur est en charge de l'ex\u00e9cution d'un ensemble de handlers d'interactions correspondant aux interactions d'un end-point donn\u00e9. L'API permet l'ajout et la suppression dynamique de handlers. Afin d'\u00e9viter les probl\u00e8mes li\u00e9s au parall\u00e9lisme, l'enregistrement et la suppression d'un handler ne peut s'effectuer que depuis l'acteur lui-m\u00eame.\nUn Handler ne peut \u00eatre ex\u00e9cut\u00e9 que par un unique acteur.\n\n\nUn acteur r\u00e9agit aux messages MAL ind\u00e9pendamment de tout r\u00f4le dans l'interaction. Lors de la r\u00e9ception d'un message il recherche le handler correspondant dans la liste des handlers  enregistr\u00e9s. En cas de succ\u00e8s il active cet handler en appelant la fonction correspondant au message re\u00e7u, dans le cas contraire le message est d\u00e9truit.\n\n\nLa dur\u00e9e de vie d'une interaction d\u00e9passe celle d'une r\u00e9action de l'acteur.\n\n\nSeul l'acteur qui a re\u00e7u le message initiant une interaction peut r\u00e9pondre \u00e0 cette interaction.\n\n\nUn acteur poss\u00e8de les caract\u00e9ristiques suivantes :\n\n\n\n\nIl correspond \u00e0 un unique end-point, en cons\u00e9quence :\n\n\nIl ne peut utiliser qu'un unique transport (binding) pour recevoir et envoyer des messages MAL.\n\n\nIl peut utiliser plusieurs formats d'encodage du corps de message MAL.\n\n\nIl est identifi\u00e9 de mani\u00e8re unique par une URI MAL relative au contexte MAL et dont le format d\u00e9pend du transport utilis\u00e9.\n\n\nIl g\u00e8re un compteur de 'Transaction Id' (champ du header MAL)\n\n\n\n\n\n\nIl poss\u00e8de un \u00e9tat.\n\n\nIl a un cycle de vie \u00e0 3 trois \u00e9tats :\n\n\nLors de sa cr\u00e9ation la fonction \ninitialize\n est appel\u00e9e avant de le lancement de la boucle de traitement des messages entrants.\n\n\nLa fonction \nhandle\n est appel\u00e9e par la boucle de r\u00e9ception des messages pour rechercher le handler correspondant au message re\u00e7u et l'activer.\n\n\nLors de son arr\u00eat la fonction \nfinalize\n est appel\u00e9e avant sa destruction.\n\n\n\n\n\n\nLes fonctions \ninitialize\n et \nfinalize\n sont personnalisables par l'utilisateur.\n\n\nIl est ex\u00e9cut\u00e9 de mani\u00e8re mono-thread\u00e9e.\n\n\nSon \u00e9tat n'est modifiable qu'au travers des r\u00e9actions des Handlers.\n\n\nSon \u00e9tat n'est pas transmissible \u00e0 un autre acteur.\n\n\n\n\nSi un mode d'ex\u00e9cution multi-thread\u00e9 est n\u00e9cessaire, par exemple pour effectuer un traitement co\u00fbteux en CPU, alors le Handler doit d\u00e9l\u00e9guer l'ex\u00e9cution de ce traitement \u00e0 diff\u00e9rents acteurs. Le traitement est donc ex\u00e9cut\u00e9 en parall\u00e8le, et la charge associ\u00e9e est partag\u00e9e entre ces acteurs.\n\n\nL'acteur d\u00e9finit un end-point sp\u00e9cifique correspondant au socket d'\u00e9coute de l'acteur C/ZMQ sous-jacent, il utilise la notion de poller MAL pour \u00e9couter simultan\u00e9ment le end-point utilisateur et ce end-point interne. Ce end-point interne permet la r\u00e9ception de commandes envoy\u00e9es \u00e0 l'acteur, par la fontion \nmal_actor_send_command\n.\n\n\nAPI Actor MAL\n\n\nConstructeur\n\n\nCr\u00e9e une instance d'acteur identifi\u00e9e par une URI MAL. La cr\u00e9ation d'un acteur entra\u00eene la cr\u00e9ation d'un end-point correspondant \u00e0 l'URI MAL de cet acteur, et d'un routeur pour la gestion des handlers de cet acteur. L'\u00e9tat de ce routeur est l'\u00e9tat de l'acteur.\n\n\nUn compteur de \nTransaction Id\n est g\u00e9r\u00e9.\n\n\nD\u00e9claration :\n\n\nmal_actor_t *mal_actor_new(\n  mal_ctx_t *mal_ctx,\n  mal_uri_t *uri,\n  void *state,\n  mal_actor_initialize_fn *initialize,\n  mal_actor_finalize_fn *finalize);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_ctx\n : contexte MAL\n\n\nuri\n : URI MAL identifiant l'acteur MAL\n\n\nstate\n : \u00e9tat de l'acteur; non typ\u00e9 pour permettre le polymorphisme\n\n\ninitialize\n : fonction d'initialisation de l'acteur\n\n\nfinalize\n : fonction de terminaison de l'acteur\n\n\n\n\nFonction virtuelle d'initialisation de l'acteur MAL\n\n\nD\u00e9claration :\n\n\ntypedef int mal_actor_initialize_fn(void *self, mal_ctx_t *mal_ctx,\n  mal_actor_t *mal_actor);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : \u00e9tat de l'acteur\n\n\nmal_ctx\n : r\u00e9f\u00e9rence du contexte MAL\n\n\nmal_actor\n : r\u00e9f\u00e9rence de l'acteur\n\n\n\n\nR\u00e9sultat :\n\n\nCode d'erreur\n\n\nFonction virtuelle de terminaison de l'acteur MAL\n\n\nD\u00e9claration :\n\n\ntypedef int mal_handler_finalize_fn(void *self, mal_ctx_t *mal_ctx,\n  mal_actor_t *mal_actor);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nself\n : \u00e9tat de l'acteur\n\n\nmal_ctx\n : r\u00e9f\u00e9rence du contexte MAL\n\n\nmal_actor\n : r\u00e9f\u00e9rence de l'acteur\n\n\n\n\nR\u00e9sultat :\n\n\nCode d'erreur\n\n\nEnvoi de message MAL\n\n\nL'envoi de messages MAL se fait au travers du end-point int\u00e9gr\u00e9 \u00e0 l'acteur (voir interface d\u00e9finie en 7.4.2). L'interface de l'acteur d\u00e9finit une fonction permettant de retrouver le end-point correspondant :\n\n\nmal_endpoint_t *mal_actor_get_mal_endpoint(mal_actor_t *self);\n\n\n\n\nEnregistrement des handlers\n\n\nL'enregistrement des handlers de l'acteur se fait au travers du routeur int\u00e9gr\u00e9 \u00e0 l'acteur ( voir interface d\u00e9finie en 7.6.3). L'interface de l'acteur d\u00e9finit une fonction permettant de retrouver le routeur correspondant :\n\n\nmal_routing_t *mal_actor_get_router(mal_actor_t *self);\n\n\n\n\nEnvoi de commandes \u00e0 l'acteur MAL\n\n\nL'envoi de commandes \u00e0 l'acteur MAL au travers de son end-point interne peut s'effectuer au travers de la fonction :\n\n\nint mal_actor_send_command(mal_actor_t *to, char *cmd);\n\n\n\n\nCette fonction prend en param\u00e8tre l'acteur destinataire et la chaine de caract\u00e8re contenant la commande. Par exemple :\n\n\nmal_actor_send_command(actor, \n$TERM\n);\n\n\n\n\nDestructeur\n\n\nD\u00e9truit l'acteur et son \u00e9tat.\n\n\nvoid mal_actor_destroy(mal_actor_t **self_p);\n\n\n\n\nExemple simple d'application MAL\n\n\nDans cet exemple nous reprenons le code de l'exemple du chapitre 4 mais en utilisant la librairie d'acteurs pr\u00e9sent\u00e9e dans ce chapitre. Une part importante du code est identique et nous ne d\u00e9taillerons que les aspects sp\u00e9cifiquement li\u00e9s \u00e0 l'usage du framework d'acteurs MAL.\n\n\nComposant consumer\n\n\nLors de la cr\u00e9ation du composant concumer on cr\u00e9e un acteur MAL pour sa gestion :\n\n\nsend_app_myconsumer_t *consumer = send_app_myconsumer_new(\n  provider_uri,\n  authentication_id, qoslevel, priority, domain, network_zone, session,\n  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);\n\n\n\n\nmal_uri_t *consumer_uri = mal_ctx_create_uri(mal_ctx, \nsend_app/myconsumer\n);\nmal_actor_t *consumer_actor = mal_actor_new(\n  mal_ctx,\n  consumer_uri, consumer,\n  send_app_myconsumer_initialize, send_app_myconsumer_finalize);\n\n\n\n\nDeux fonctions d'initialisation et de terminaison sont sp\u00e9cifi\u00e9es \u00e0 l'acteur, la fonction d'initialisation nous permet d'initier l'interaction SEND vers le provider. Ce code correspond au code la m\u00e9thode run d\u00e9crit en section 4.1.2.\n\n\nComposant Provider\n\n\nLors de la cr\u00e9ation du composant provider on cr\u00e9e un acteur MAL pour sa gestion :\n\n\nsend_app_myprovider_t *provider =\n  send_app_myprovider_new(MALBINARY_FORMAT_CODE, encoder, decoder);\n\n\n\n\nmal_actor_t *provider_actor = mal_actor_new(\n  mal_ctx,\n  provider_uri, provider,\n  send_app_myprovider_initialize, send_app_myprovider_finalize);\n\n\n\n\nDeux fonctions d'initialisation et de terminaison sont sp\u00e9cifi\u00e9es \u00e0 l'acteur, la fonction d'initialisation permettra entre autre d'enregistrer les handlers du provider. La r\u00e9ception de message est maintenant implicitement g\u00e9r\u00e9e par l'acteur MAL :\n\n\n\n\nLors de la r\u00e9ception d'un message MAL sur le end-point correspondant \u00e0 l'URI du provider le handler enregistr\u00e9s en automatiquement ex\u00e9cut\u00e9.\n\n\nDans le cas contraire le message est d\u00e9truit.\n\n\n\n\nLancement de l'application\n\n\nLes composants consumer et provider sont maintenant des acteurs MAL, ils ne n\u00e9cessitent donc plus la cr\u00e9ation explicite d'un acteur ZMQ pour les ex\u00e9cuter :\n\n\nsend_app_create_provider(verbose, mal_ctx, provider_uri, encoder, decoder);\nsend_app_create_consumer(verbose, mal_ctx, provider_uri, encoder, decoder);\n\n\n\n\nLe code de lancement de l'application est par ailleurs identique :\n\n\n\n\ncr\u00e9ation du contexte MAL,\n\n\ncr\u00e9ation des encoder et decoder,\n\n\ncr\u00e9ation du transport MALZMQ,\n\n\nd\u00e9marrage du contexte MAL.", 
            "title": "Actor"
        }, 
        {
            "location": "/mal_actor/#modele-dexecution-acteur-handler", 
            "text": "L'acteur MAL utilise l'API MAL/C et en particulier les notions de  poller , de  end-point  et de  handler . Il repose sur la notion d'acteur CZMQ.", 
            "title": "Mod\u00e8le d'ex\u00e9cution Acteur / Handler"
        }, 
        {
            "location": "/mal_actor/#acteur", 
            "text": "Un acteur est en charge de l'ex\u00e9cution d'un ensemble de handlers d'interactions correspondant aux interactions d'un end-point donn\u00e9. L'API permet l'ajout et la suppression dynamique de handlers. Afin d'\u00e9viter les probl\u00e8mes li\u00e9s au parall\u00e9lisme, l'enregistrement et la suppression d'un handler ne peut s'effectuer que depuis l'acteur lui-m\u00eame.\nUn Handler ne peut \u00eatre ex\u00e9cut\u00e9 que par un unique acteur.  Un acteur r\u00e9agit aux messages MAL ind\u00e9pendamment de tout r\u00f4le dans l'interaction. Lors de la r\u00e9ception d'un message il recherche le handler correspondant dans la liste des handlers  enregistr\u00e9s. En cas de succ\u00e8s il active cet handler en appelant la fonction correspondant au message re\u00e7u, dans le cas contraire le message est d\u00e9truit.  La dur\u00e9e de vie d'une interaction d\u00e9passe celle d'une r\u00e9action de l'acteur.  Seul l'acteur qui a re\u00e7u le message initiant une interaction peut r\u00e9pondre \u00e0 cette interaction.  Un acteur poss\u00e8de les caract\u00e9ristiques suivantes :   Il correspond \u00e0 un unique end-point, en cons\u00e9quence :  Il ne peut utiliser qu'un unique transport (binding) pour recevoir et envoyer des messages MAL.  Il peut utiliser plusieurs formats d'encodage du corps de message MAL.  Il est identifi\u00e9 de mani\u00e8re unique par une URI MAL relative au contexte MAL et dont le format d\u00e9pend du transport utilis\u00e9.  Il g\u00e8re un compteur de 'Transaction Id' (champ du header MAL)    Il poss\u00e8de un \u00e9tat.  Il a un cycle de vie \u00e0 3 trois \u00e9tats :  Lors de sa cr\u00e9ation la fonction  initialize  est appel\u00e9e avant de le lancement de la boucle de traitement des messages entrants.  La fonction  handle  est appel\u00e9e par la boucle de r\u00e9ception des messages pour rechercher le handler correspondant au message re\u00e7u et l'activer.  Lors de son arr\u00eat la fonction  finalize  est appel\u00e9e avant sa destruction.    Les fonctions  initialize  et  finalize  sont personnalisables par l'utilisateur.  Il est ex\u00e9cut\u00e9 de mani\u00e8re mono-thread\u00e9e.  Son \u00e9tat n'est modifiable qu'au travers des r\u00e9actions des Handlers.  Son \u00e9tat n'est pas transmissible \u00e0 un autre acteur.   Si un mode d'ex\u00e9cution multi-thread\u00e9 est n\u00e9cessaire, par exemple pour effectuer un traitement co\u00fbteux en CPU, alors le Handler doit d\u00e9l\u00e9guer l'ex\u00e9cution de ce traitement \u00e0 diff\u00e9rents acteurs. Le traitement est donc ex\u00e9cut\u00e9 en parall\u00e8le, et la charge associ\u00e9e est partag\u00e9e entre ces acteurs.  L'acteur d\u00e9finit un end-point sp\u00e9cifique correspondant au socket d'\u00e9coute de l'acteur C/ZMQ sous-jacent, il utilise la notion de poller MAL pour \u00e9couter simultan\u00e9ment le end-point utilisateur et ce end-point interne. Ce end-point interne permet la r\u00e9ception de commandes envoy\u00e9es \u00e0 l'acteur, par la fontion  mal_actor_send_command .", 
            "title": "Acteur"
        }, 
        {
            "location": "/mal_actor/#api-actor-mal", 
            "text": "", 
            "title": "API Actor MAL"
        }, 
        {
            "location": "/mal_actor/#constructeur", 
            "text": "Cr\u00e9e une instance d'acteur identifi\u00e9e par une URI MAL. La cr\u00e9ation d'un acteur entra\u00eene la cr\u00e9ation d'un end-point correspondant \u00e0 l'URI MAL de cet acteur, et d'un routeur pour la gestion des handlers de cet acteur. L'\u00e9tat de ce routeur est l'\u00e9tat de l'acteur.  Un compteur de  Transaction Id  est g\u00e9r\u00e9.  D\u00e9claration :  mal_actor_t *mal_actor_new(\n  mal_ctx_t *mal_ctx,\n  mal_uri_t *uri,\n  void *state,\n  mal_actor_initialize_fn *initialize,\n  mal_actor_finalize_fn *finalize);  Param\u00e8tres :   mal_ctx  : contexte MAL  uri  : URI MAL identifiant l'acteur MAL  state  : \u00e9tat de l'acteur; non typ\u00e9 pour permettre le polymorphisme  initialize  : fonction d'initialisation de l'acteur  finalize  : fonction de terminaison de l'acteur", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_actor/#fonction-virtuelle-dinitialisation-de-lacteur-mal", 
            "text": "D\u00e9claration :  typedef int mal_actor_initialize_fn(void *self, mal_ctx_t *mal_ctx,\n  mal_actor_t *mal_actor);  Param\u00e8tres :   self  : \u00e9tat de l'acteur  mal_ctx  : r\u00e9f\u00e9rence du contexte MAL  mal_actor  : r\u00e9f\u00e9rence de l'acteur   R\u00e9sultat :  Code d'erreur", 
            "title": "Fonction virtuelle d'initialisation de l'acteur MAL"
        }, 
        {
            "location": "/mal_actor/#fonction-virtuelle-de-terminaison-de-lacteur-mal", 
            "text": "D\u00e9claration :  typedef int mal_handler_finalize_fn(void *self, mal_ctx_t *mal_ctx,\n  mal_actor_t *mal_actor);  Param\u00e8tres :   self  : \u00e9tat de l'acteur  mal_ctx  : r\u00e9f\u00e9rence du contexte MAL  mal_actor  : r\u00e9f\u00e9rence de l'acteur   R\u00e9sultat :  Code d'erreur", 
            "title": "Fonction virtuelle de terminaison de l'acteur MAL"
        }, 
        {
            "location": "/mal_actor/#envoi-de-message-mal", 
            "text": "L'envoi de messages MAL se fait au travers du end-point int\u00e9gr\u00e9 \u00e0 l'acteur (voir interface d\u00e9finie en 7.4.2). L'interface de l'acteur d\u00e9finit une fonction permettant de retrouver le end-point correspondant :  mal_endpoint_t *mal_actor_get_mal_endpoint(mal_actor_t *self);", 
            "title": "Envoi de message MAL"
        }, 
        {
            "location": "/mal_actor/#enregistrement-des-handlers", 
            "text": "L'enregistrement des handlers de l'acteur se fait au travers du routeur int\u00e9gr\u00e9 \u00e0 l'acteur ( voir interface d\u00e9finie en 7.6.3). L'interface de l'acteur d\u00e9finit une fonction permettant de retrouver le routeur correspondant :  mal_routing_t *mal_actor_get_router(mal_actor_t *self);", 
            "title": "Enregistrement des handlers"
        }, 
        {
            "location": "/mal_actor/#envoi-de-commandes-a-lacteur-mal", 
            "text": "L'envoi de commandes \u00e0 l'acteur MAL au travers de son end-point interne peut s'effectuer au travers de la fonction :  int mal_actor_send_command(mal_actor_t *to, char *cmd);  Cette fonction prend en param\u00e8tre l'acteur destinataire et la chaine de caract\u00e8re contenant la commande. Par exemple :  mal_actor_send_command(actor,  $TERM );", 
            "title": "Envoi de commandes \u00e0 l'acteur MAL"
        }, 
        {
            "location": "/mal_actor/#destructeur", 
            "text": "D\u00e9truit l'acteur et son \u00e9tat.  void mal_actor_destroy(mal_actor_t **self_p);", 
            "title": "Destructeur"
        }, 
        {
            "location": "/mal_actor/#exemple-simple-dapplication-mal", 
            "text": "Dans cet exemple nous reprenons le code de l'exemple du chapitre 4 mais en utilisant la librairie d'acteurs pr\u00e9sent\u00e9e dans ce chapitre. Une part importante du code est identique et nous ne d\u00e9taillerons que les aspects sp\u00e9cifiquement li\u00e9s \u00e0 l'usage du framework d'acteurs MAL.", 
            "title": "Exemple simple d'application MAL"
        }, 
        {
            "location": "/mal_actor/#composant-consumer", 
            "text": "Lors de la cr\u00e9ation du composant concumer on cr\u00e9e un acteur MAL pour sa gestion :  send_app_myconsumer_t *consumer = send_app_myconsumer_new(\n  provider_uri,\n  authentication_id, qoslevel, priority, domain, network_zone, session,\n  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);  mal_uri_t *consumer_uri = mal_ctx_create_uri(mal_ctx,  send_app/myconsumer );\nmal_actor_t *consumer_actor = mal_actor_new(\n  mal_ctx,\n  consumer_uri, consumer,\n  send_app_myconsumer_initialize, send_app_myconsumer_finalize);  Deux fonctions d'initialisation et de terminaison sont sp\u00e9cifi\u00e9es \u00e0 l'acteur, la fonction d'initialisation nous permet d'initier l'interaction SEND vers le provider. Ce code correspond au code la m\u00e9thode run d\u00e9crit en section 4.1.2.", 
            "title": "Composant consumer"
        }, 
        {
            "location": "/mal_actor/#composant-provider", 
            "text": "Lors de la cr\u00e9ation du composant provider on cr\u00e9e un acteur MAL pour sa gestion :  send_app_myprovider_t *provider =\n  send_app_myprovider_new(MALBINARY_FORMAT_CODE, encoder, decoder);  mal_actor_t *provider_actor = mal_actor_new(\n  mal_ctx,\n  provider_uri, provider,\n  send_app_myprovider_initialize, send_app_myprovider_finalize);  Deux fonctions d'initialisation et de terminaison sont sp\u00e9cifi\u00e9es \u00e0 l'acteur, la fonction d'initialisation permettra entre autre d'enregistrer les handlers du provider. La r\u00e9ception de message est maintenant implicitement g\u00e9r\u00e9e par l'acteur MAL :   Lors de la r\u00e9ception d'un message MAL sur le end-point correspondant \u00e0 l'URI du provider le handler enregistr\u00e9s en automatiquement ex\u00e9cut\u00e9.  Dans le cas contraire le message est d\u00e9truit.", 
            "title": "Composant Provider"
        }, 
        {
            "location": "/mal_actor/#lancement-de-lapplication", 
            "text": "Les composants consumer et provider sont maintenant des acteurs MAL, ils ne n\u00e9cessitent donc plus la cr\u00e9ation explicite d'un acteur ZMQ pour les ex\u00e9cuter :  send_app_create_provider(verbose, mal_ctx, provider_uri, encoder, decoder);\nsend_app_create_consumer(verbose, mal_ctx, provider_uri, encoder, decoder);  Le code de lancement de l'application est par ailleurs identique :   cr\u00e9ation du contexte MAL,  cr\u00e9ation des encoder et decoder,  cr\u00e9ation du transport MALZMQ,  d\u00e9marrage du contexte MAL.", 
            "title": "Lancement de l'application"
        }, 
        {
            "location": "/mal_czmq/", 
            "text": "Transport MAL/CZMQ\n\n\nCette section d\u00e9crit l'impl\u00e9mentation du transport \nmalzmq\n sur l'API CZMQ. Il ne s'agit donc pas d'une description en terme de protocole (comme doit le faire le livre CCSDS MALZMQ) mais en terme d'API.\n\n\nLe format d'encodage du header MAL est donn\u00e9 en annexe ###La m\u00eame description doit \u00eatre donn\u00e9e par le livre MALZMQ.\n\n\nUn message MAL est transport\u00e9 dans une unique trame ZMQ (zframe).\n\n\nLes sections suivantes d\u00e9crivent l'impl\u00e9mentation du module MAL/CZMQ :\n\n\n\n\nConfiguration du header MALZMQ\n\n\nConstructeur d'un contexte MALZMQ\n\n\nD\u00e9marrage\n\n\nR\u00e9ception d'un message MAL\n\n\nImpl\u00e9mentation des fonctions virtuelles impos\u00e9es par l'API MAL\n\n\n\n\nHeader MALZMQ\n\n\nUne classe est d\u00e9finie pour g\u00e9rer les sp\u00e9cificit\u00e9s du format de header MALZMQ (voir annexe 14.3) :\n\n\n\n\nNum\u00e9ro de version du mapping MALZMQ.\n\n\nCatalogue de mapping.\n\n\nFlags de pr\u00e9sence des champs de header MALZMQ optionnels.\n\n\nValeur des champs non pr\u00e9sents.\n\n\n\n\nConstructeur\n\n\nmalzmq_header_t *malzmq_header_new(\n  malzmq_mapping_directory_t *mapping_directory,\n  bool priority_flag, mal_uinteger_t priority,\n  bool timestamp_flag, mal_identifier_t *network_zone,\n  mal_identifier_t *session_name, mal_identifier_list_t *domain,\n  mal_blob_t *authentication_id);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmapping_directory\n : catalogue de mapping \u00e0 utiliser pour l'encodage (cf ###), peut \u00eatre NULL.\n\n\npriority_flag\n : flag de pr\u00e9sence du champ Priority dans le header MALZMQ.\n\n\npriority\n : valeur du champ Priority s'il n'est pas pr\u00e9sent dans le header MALZMQ.\n\n\ntimestamp_flag\n : flag de pr\u00e9sence du champ Timestamp dans le header MALZMQ.\n\n\nnetwork_zone\n : valeur du champ Network Zone s'il n'est pas pr\u00e9sent dans le header MALZMQ. Si NULL alors le champ Network Zone est pr\u00e9sent dans le header MALZMQ.\n\n\nsession_name\n : idem pour le champ Session Name.\n\n\ndomain\n : idem pour le champ Domain.\n\n\nauthentication_id\n : idem pour le champ Authentication Id.\n\n\n\n\nParam\u00e8tres de configuration\n\n\nCertains champs du header MAL peuvent \u00eatre toujours identiques pour une application. Les transf\u00e9rer lors de chaque appel serait redondant, et on peut donc optimiser les performances en les omettant du header MALZMQ. Ces champs sont les suivants : \nPRIORITY\n, \nNETWORK_ZONE\n, \nSESSION_NAME\n, \nDOMAIN\n, \nAUTHENTICATION_ID\n. La pr\u00e9sence de ces champs dans le header MALZMQ, ainsi que leur \u00e9ventuelle valeur globale, est d\u00e9finie dans le constructeur du header MALZMQ.\n\n\nUn autre champ du header MAL, \nTIMESTAMP\n, peut \u00e9galement \u00eatre omis du header MALZMQ. Cette \u00e9ventuelle omission est \u00e9galement d\u00e9finie dans le constructeur du header MALZMQ. Il n'y a pas de valeur de remplacement d\u00e9finie pour ce champ.\n\n\nIl va de soit que ces diff\u00e9rents param\u00e8tres de configuration doivent \u00eatre fournis de mani\u00e8re identique \u00e0 toutes les entit\u00e9s communiquantes de l'application.\n\n\nCatalogue de mapping\n\n\nLe header du message MAL contient de nombreux champs dont la taille peut \u00eatre importante : des URIs, des cha\u00eenes de caract\u00e8re, etc. Afin d'optimiser les performances les messages \u00e9chang\u00e9s entre les instances de MAL/CZMQ transportent des champs encod\u00e9s dans des types scalaires de taille moindre.\n\n\nAfin de maintenir la compatibilit\u00e9 avec le MAL les champs des messages MAL/CZMQ ainsi encod\u00e9s sont syst\u00e9matiquement transform\u00e9s en leur \u00e9quivalent MAL lors de leur acc\u00e8s par l'utilisateur de l'API MAL. Pour ce faire la correspondance des informations doit \u00eatre maintenue tant cot\u00e9 consumer, que cot\u00e9 provider via un catalogue.\n\n\nL'objet de cette section est de d\u00e9crire l'API d'acc\u00e8s \u00e0 ce catalogue et son usage.\n\n\nPrincipes\n\n\nLe catalogue de mapping conserve une correspondance entre des cha\u00eenes de caract\u00e8res et des valeurs num\u00e9riques. La valeur num\u00e9rique est appel\u00e9e \nMDK\n pour Mapping Directory Key.\n\n\nLe catalogue permet de retrouver le MDK d'une cha\u00eene c\u00f4t\u00e9 encodage, et de retrouver la cha\u00eene d'un MDK c\u00f4t\u00e9 d\u00e9codage.\n\n\nIl n'est pas de la responsabilit\u00e9 du MAL/CZMQ de s'assurer de la coh\u00e9rence du catalogue de chaque c\u00f4t\u00e9 de l'interaction. Cette responsabilit\u00e9 revient \u00e0 l'application. Le moyen le plus simple d'y parvenir est d'offrir un catalogue statique, fix\u00e9 une fois pour toute \u00e0 l'installation de l'application au niveau de tous les participants. Toutefois rien n'interdit \u00e0 une application d'offrir une implantation plus dynamique du catalogue.\n\n\nEncodage\n\n\nL'encodage d'une cha\u00eene sous sa forme MDK est optionnelle, afin de g\u00e9rer le cas o\u00f9 il n'existe pas de MDK dans le catalogue correspondant \u00e0 la cha\u00eene \u00e0 encoder. C'est pour cela que le mapping d\u00e9crit en 14.3 fait r\u00e9f\u00e9rence \u00e0 un type \nOptional MDK\n.\n\n\nLe principe de l'encodage \nOptional MDK\n est d\u00e9riv\u00e9 de l'encodage MAL binary d'une cha\u00eene de caract\u00e8res. Cet encodage consiste normalement en l'encodage de la longueur de la cha\u00eene, typ\u00e9e UInteger, suivi de l'encodage des caract\u00e8res eux-m\u00eames. L'encodage \nOptional MDK\n transforme ce champ longueur de 32 bits en une valeur de type Integer, pour en exploiter s\u00e9par\u00e9ment le signe et la valeur absolue. Le signe d\u00e9crit la nature du champ repr\u00e9sent\u00e9 par la valeur absolue, \u00e0 savoir un MDK si le signe est n\u00e9gatif, ou une longueur si le signe est positif. Dans le second cas les caract\u00e8res de la cha\u00eene sont encod\u00e9s \u00e0 la suite comme dans l'encodage MAL binary.\n\n\nUne cha\u00eene encod\u00e9e sous sa forme MDK ne n\u00e9cessite donc que 4 octets, repr\u00e9sentant la valeur n\u00e9gative du MDK. Si elle n'est pas encod\u00e9e sous sa forme MDK, une cha\u00eene est conforme \u00e0 son encodage MAL binary.\n\n\nLe cas particulier d'une valeur nulle pour l'Integer initial correspond \u00e0 l'encodage MAL binary, \u00e0 savoir la cha\u00eene vide. En cons\u00e9quence un MDK doit \u00eatre strictement positif.\n\n\nAPI\n\n\nLe catalogue de mapping, typ\u00e9 \nmalzmq_mapping_directory_t\n, est fourni comme une table de fonctions.\n\n\ntypedef struct _malzmq_mapping_directory_t malzmq_mapping_directory_t;\nstruct _malzmq_mapping_directory_t {\n  malzmq_md_get_key_fn *get_key_fn;\n  malzmq_md_get_string_fn *get_string_fn;\n  malzmq_md_put_string_fn *put_string_fn;\n};\n\n\n\n\nChamps :\n\n\n\n\nget_key_fn\n : renvoie le MDK d'une cha\u00eene s'il existe dans le catalogue\n\n\nget_string_fn\n : renvoie la cha\u00eene correspondant \u00e0 un MDK\n\n\nput_string_fn\n : ajoute une cha\u00eene au catalogue et renvoie le MDK correspondant.\n\n\n\n\nPour l'instant seules les deux premi\u00e8res fonctions sont utilis\u00e9es par le MAL/CZMQ.\n\n\nVoici le d\u00e9tail d'interface de chacune de ces fonctions.\n\n\ntypedef int malzmq_md_get_key_fn(char *string, unsigned int *key);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nstring\n : cha\u00eene pour laquelle on recherche une \u00e9ventuelle clef de correspondance. Ne doit pas \u00eatre nulle.\n\n\nkey\n : valeur de retour du MDK correspondant \u00e0 string, s'il existe.\n\n\n\n\nR\u00e9sultat :\n\n\n\n\n0 : ex\u00e9cution valide, valeur de retour key exploitable.\n\n\n0 : code d'erreur, valeur de retour key ind\u00e9termin\u00e9e.\n\n\n\n\ntypedef int malzmq_md_get_string_fn(unsigned int key, char **string);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nkey\n : MDK pour lequel on recherche une cha\u00eene associ\u00e9e.\n\n\nstring\n : valeur de retour de la cha\u00eene correspondant \u00e0 key, si elle existe. Cette cha\u00eene a \u00e9t\u00e9 allou\u00e9e et doit \u00eatre lib\u00e9r\u00e9e par free ou par les diverses fonctions sp\u00e9cifiques (mal_string_destroy, etc).\n\n\n\n\nR\u00e9sultat :\n\n\n\n\n0 : ex\u00e9cution valide, valeur de retour string exploitable.\n\n\n0 : code d'erreur, valeur de retour string ind\u00e9termin\u00e9e.\n\n\n\n\ntypedef int malzmq_md_put_string_fn(char *string, unsigned int *key);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nstring\n : cha\u00eene pour laquelle on souhaite cr\u00e9er une clef de correspondance. Ne doit pas \u00eatre nulle. Le catalogue ne doit pas conserver la cha\u00eene telle quelle au del\u00e0 de cet appel, afin de permettre \u00e0 l'appelant de la lib\u00e9rer au besoin.\n\n\nkey\n : valeur de retour du MDK correspondant \u00e0 string. Doit \u00eatre strictement positive et strictement inf\u00e9rieure \u00e0 231. Cette valeur distinctive est cr\u00e9\u00e9e si et seulement si il n'existait pas auparavant une autre valeur correspondante dans le catalogue.\n\n\n\n\nR\u00e9sultat :\n\n\n\n\n0 : ex\u00e9cution valide, valeur de retour key exploitable.\n\n\n0 : code d'erreur, cha\u00eene non enregistr\u00e9e dans le catalogue et valeur de retour key ind\u00e9termin\u00e9e.\n\n\n\n\nNote :\n\n\nles fonctions du catalogue ne travaillent que sur des cha\u00eenes (char*), car les diff\u00e9rents types cibles \nmal_string_t\n, \nmal_uri_t\n et \nmal_identifier_t\n, ne sont eux-m\u00eames que des \nchar*\n. Si ce n'\u00e9tait pas le cas, il faudrait que le catalogue fournisse des fonctions distinctes pour chacun de ces types.\n\n\nUsage\n\n\nLe catalogue n'est pour l'instant utilis\u00e9 que pour les champs du header suivants : \nURI from\n, \nURI to\n, \nNetwork Zone\n, \nSession Name\n, \nDomain\n.\n\n\nL'utilisation du catalogue pour des champs choisis du body est envisageable, mais casserait la conformit\u00e9 actuelle de l'encodage du body au format MAL binary.\n\n\nConstructeur du contexte MALZMQ\n\n\nmalzmq_ctx_t *malzmq_ctx_new(\n  mal_ctx_t *mal_ctx,\n  malzmq_mapping_uri_t *mapping_uri,\n  char *hostname, char *port, malzmq_header_t *malzmq_header,\n  malbinary_encoder_t *encoder, malbinary_decoder_t *decoder,\n  bool verbose);\n\n\n\n\nParam\u00e8tres :\n\n\n\n\nmal_ctx\n : le contexte MAL.\n\n\nmapping_uri\n : fonctions de transformation de l'URI MAL d'un service en URI ZMQ. Ce mapping peut-\u00eatre NULL, dans ce cas les fonctions de transformation d'URI par d\u00e9faut de l'implantation sont utilis\u00e9es (voir section ###).\n\n\nhostname\n : addresse IP utilis\u00e9e pour accepter les connexions entrantes.\n\n\nport\n : port utilis\u00e9 pour accepter les connexions entrantes.\n\n\nmalzmq_header\n : flags et champs optionnels. La configuration du header MALZMQ est globale au contexte MALZMQ.\n\n\nencoder\n : contexte d'encodage utilis\u00e9 pour encoder les headers MAL.\n\n\ndecoder\n : contexte de d\u00e9codage utilis\u00e9 pour d\u00e9coder les headers MAL.\n\n\nverbose\n : flag d'activation des traces.\n\n\n\n\nLe constructeur effectue les actions suivantes :\n\n\n\n\nCr\u00e9ation d'une socket ZMQ de type ROUTER permettant d'accepter les connexions ouvertes par d'autres contextes MALZMQ distants : \nSOCKET_MAL_ROUTER\n. L'URI ZMQ utilis\u00e9e par le bind est d\u00e9termin\u00e9e \u00e0 partir des param\u00e8tres \nhostname\n et \nport\n et des fonctions de transformation d'URI pass\u00e9es en param\u00e8tre.\n\n\nCr\u00e9ation d'une socket ZMQ de type SUB permettant la r\u00e9ception des messages diffus\u00e9s par les autres contextes MALZMQ : \nSOCKET_MAL_SUB\n. L'URI ZMQ utilis\u00e9e par le bind est d\u00e9termin\u00e9e \u00e0 partir des param\u00e8tres \nhostname\n et \nport\n et des fonctions de transformation d'URI pass\u00e9es en param\u00e8tre.\n\n\nCr\u00e9ation d'une socket ZMQ de protocole \ninproc\n et de type ROUTER permettant de communiquer avec les acteurs MALZMQ du contexte :  \nSOCKET_Z_ROUTER\n.\n\n\nUne \nzloop\n est cr\u00e9\u00e9e pour g\u00e9rer les deux sockets \nROUTER\n.\n\n\n\n\nFonctions de transformation d'URI\n\n\nLa transformation des URI MAL en URI ZMQ est assur\u00e9e par 3 fonctions :\n\n\n\n\nLa premi\u00e8re get_p2p_zmquri prend en param\u00e8tre l'URI MAL d'un service et retourne l'URI ZMQ de bind du socket DEALER d'\u00e9coute du contexte MAL correspondant. Par exemple : \nmalzmq://host:port/service \u2192 tcp://*:port\n\n\nLa seconde get_ps_zmquri prend en param\u00e8tre l'URI MAL d'un service et retourne l'URI ZMQ sur laquelle connecter le socket SUB d'\u00e9coute du contexte MAL correspondant. Par exemple : \nmalzmq://host:port/service \u2192 tcp://host:(port+1) ou pgm://itf;mcast_addr:(port+1)\n\n\nLa derni\u00e8re \nget_zmquri_to\n prend en param\u00e8tre un message MAL \u00e0 \u00e9mettre et retourne l'URI ZMQ correspondante en fonction de l'\u00e9tape de l'interaction et de l'URI MAL du destinataire. Si l'URI du destinataire est \nmalzmq://host1:port1/service\n :\n\u25e6   MAL_INTERACTIONTYPE_INVOKE, MAL_IP_STAGE_INVOKE\n\u25aa   tcp://host1:port1\n\u25e6   MAL_INTERACTIONTYPE_PUBSUB, MAL_IP_STAGE_PUBSUB_PUBLISH\n\u25aa   tcp://*:(port1+1) ou epgm://itf;mcast_addr:(port+1)\n\n\n\n\nLes fonctions permettant la transformation des URI MAL en URI ZMQ sont pass\u00e9es au contexte MALZMQ au travers d'une structure malzmq_mapping_uri_t. Si ce param\u00e8tre est nul les fonctions d\u00e9finies par d\u00e9faut dans le transport MALZMQ sont utilis\u00e9es ; ces fonctions consid\u00e8rent que le transport utilis\u00e9 est TCP pour toutes les interactions et que le port utilis\u00e9 pour le Publish / Subscribe est le port du service incr\u00e9ment\u00e9 de 1 (cf section ###).\n\n\ntypedef mal_uri_t *malzmq_get_p2p_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_get_ps_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_getzmquri_to_fn(mal_message_t *message);\n\ntypedef struct _malzmq_mapping_uri_t malzmq_mapping_uri_t;\n\nstruct _malzmq_mapping_uri_t {\n  malzmq_get_p2p_zmquri_fn *get_p2p_zmquri_fn;\n  malzmq_get_ps_zmquri_fn *get_ps_zmquri_fn;\n  malzmq_getzmquri_to_fn *getzmquri_to_fn;\n};\n\n\n\n\nMapping par d\u00e9faut\n\n\nLe mapping par d\u00e9faut du transport MAL/CZMQ implant\u00e9 dans le POC utilise le protocole TCP tant pour les communications Point-to-Point que Publish/Subscribe :\n\n\n\n\nmalzmq_get_p2p_zmquri_fn\n\u25e6   malzmq://host:port/service \u2192 tcp://*:port\n\n\ntypedef int malzmq_get_ps_zmquri_fn\n\u25e6   malzmq://host:port/service \u2192 tcp://host:port_ps, o\u00f9 port_ps=port+1\n\n\ntypedef int malzmq_getzmquri_to_fn\n\u25e6   Si les champs interaction_type et interaction_stage du message pass\u00e9 en param\u00e8tre sont MAL_INTERACTIONTYPE_PUBSUB et MAL_IP_STAGE_PUBSUB_PUBLISH :\n\u25aa   malzmq://host1:port1/service \u2192 tcp://host1:port1_ps, o\u00f9 port1_ps=port1+1\n\u25e6   Dans tous les autres cas :\n\u25aa   malzmq://host1:port1/service \u2192 tcp://host1:port1\n\n\n\n\nD\u00e9marrage\n\n\nLa fonction suivante permet de d\u00e9marrer le contexte MALZMQ. Cette fonction d\u00e9marre la zloop et bloque tant que la zloop ne s'est pas termin\u00e9e.\n\n\nint malzmq_ctx_start(malzmq_ctx_t *self);\n\n\n\n\nComportement de la zloop\n\n\nLa zloop est en \u00e9coute (\nSOCKET_MAL_ROUTER\n et \nSOCKET_MAL_SUB\n) des messages \u00e9mis par les acteurs MALZMQ distants. Lorsqu'un message ZMQ est re\u00e7u, les actions suivantes sont effectu\u00e9es :\n\n\n\n\nExtraction et destruction de la premi\u00e8re trame contenant l'identit\u00e9 de l'appelant. En effet, actuellement, les connexions ZMQ sont utilis\u00e9es seulement \u00e0 sens unique, en cons\u00e9quence l'identit\u00e9 de l'appelant n'est pas conserv\u00e9e.\n\n\nLa trame suivante n'est pas extraite (\nzmsg_pop\n) du message ZMQ mais seulement lue (\nzmsg_next\n) afin de permettre la r\u00e9utilisation du message ZMQ pour l'envoyer \u00e0 l'acteur destinataire.\n\n\nSeul le champ \nURI To\n est d\u00e9cod\u00e9. Ce champ donne l'identit\u00e9 de la socket \nDEALER\n utilis\u00e9e par l'acteur destinataire.\n\n\nLe message ZMQ re\u00e7u est renvoy\u00e9 \u00e0 l'acteur destinataire au travers de \nSOCKET_ACTOR_ROUTER\n.\n\n\n\n\nR\u00e9ception d'un message par un end-point MALZMQ\n\n\nLors de la demande de r\u00e9ception d'un message par un end-point MAL, le transport MALZMQ se met en \u00e9coute sur le socket connect\u00e9 au socket router de la zloop.\n\n\nA la r\u00e9ception d'un message MAL :\n\n\n\n\nLa premi\u00e8re et unique trame du message ZMQ est extraite.\n\n\nUne structure \nmal_message\n est instanci\u00e9e.\n\n\nLes champs du header MAL sont d\u00e9cod\u00e9s. Les champs optionnels non encod\u00e9s du header MAL sont affect\u00e9s \u00e0 partir de la configuration du header MALZMQ qui est globale au contexte MALZMQ.\n\n\nLe corps du message est directement affect\u00e9 \u00e0 partir de la trame ZMQ (\ndata\n de \nzframe\n) sans copie. En cons\u00e9quence, la trame ZMQ ne peut \u00eatre d\u00e9truite qu'au moment de la destruction du message MAL (voir section 12.13). Le champ \nbody_owner\n du message MAL est affect\u00e9 avec la trame ZMQ.\n\n\nLe message MAL est retourn\u00e9 \u00e0 l'appelant, la destruction du message MAL est \u00e0 la responsabilit\u00e9 du traitant de ce message.\n\n\n\n\nFonction virtuelle de cr\u00e9ation d'URI\n\n\nLe format d'URI est le suivant :\n\n\nmalzmq://\nhostname\n:\nport\n/\nid\n\n\n\n\n\nLe protocole de transport utilis\u00e9 par ZMQ n'est pas sp\u00e9cifi\u00e9 dans l'URI. Il est sp\u00e9cifi\u00e9 \u00e0 la cr\u00e9ation du contexte MALZMQ.\n\n\nDans certains cas, le contexte MALZMQ pourrait optimiser la communication en utilisant un protocole de transport plus efficace, par exemple :\n\n\n\n\nipc\n : si le consumer et le provider sont sur la m\u00eame machine (m\u00eame 'hostname')\n\n\ninproc\n : si le consumer et le provider sont dans le m\u00eame processus (attention dans ce cas \u00e0 l'ordre de d\u00e9marrage car 'inproc' n'assure pas le d\u00e9couplage temporel des sockets ZMQ)\n\n\n\n\nCette optimisation n'est pour l'instant pas impl\u00e9ment\u00e9e.\n\n\nFonction virtuelle de cr\u00e9ation de end-point\n\n\nUn end-point MALZMQ est cr\u00e9\u00e9 et retourn\u00e9 comme r\u00e9sultat (en pointeur non typ\u00e9 \nvoid *\n).\n\n\nLes donn\u00e9es sp\u00e9cifiques au end-point MALZMQ sont :\n\n\n\n\nle contexte MALZMQ,\n\n\nle end-point MAL pass\u00e9 en param\u00e8tre de la fonction,\n\n\nla socket de r\u00e9ception des messages MAL rout\u00e9s par la zloop,\n\n\nune table de hash contenant les sockets ZMQ ouvertes vers des contextes MALZMQ distants.\n\n\n\n\nLors de l'initialisation du end-point, les actions suivantes sont effectu\u00e9es :\n\n\n\n\ncr\u00e9ation d'une socket ZMQ de type DEALER\n\n\naffectation de l'identit\u00e9 de cette socket avec l'URI du end-point\n\n\nconnexion de cette socket avec la socket router g\u00e9r\u00e9e par la zloop \n\n\n\n\n(ZLOOP_ENDPOINTS_SOCKET_URI)\n\n\nFonction virtuelle d'envoi de message\n\n\nL'URI MAL destinataire du message est transform\u00e9e en URI ZMQ :\n\n\n\n\nFormat d'URI MAL : \nmalzmq://\nhostname\n:\nport\n/\nid\n\n\nFormat d'URI ZMQ : \nprotocole zmq\n://\nhostname\n:\nport\n\n\n\n\nUne socket de type DEALER connect\u00e9e \u00e0 cette URI est recherch\u00e9e dans une table de hash appartenant \u00e0 l'acteur (structure \nmalzmq_actor_data\n). Si la socket n'est pas trouv\u00e9e alors elle est cr\u00e9\u00e9e et enregistr\u00e9e dans la table (la cl\u00e9 \u00e9tant l'URI ZMQ).\n\n\nLe message MAL est encod\u00e9 et transmis dans une unique trame ZMQ.\n\n\nFonction virtuelle de cr\u00e9ation de poller\n\n\nUn poller MALZMQ est cr\u00e9\u00e9 et retourn\u00e9 comme r\u00e9sultat (en pointeur non typ\u00e9 \nvoid *\n).\n\n\nLes donn\u00e9es sp\u00e9cifiques au poller MALZMQ sont :\n\n\n\n\nle contexte MALZMQ,\n\n\nle poller MAL pass\u00e9 en param\u00e8tre de la fonction,\n\n\nle zpoller permettant l'attente sur les sockets des end-points..\n\n\nla liste des end-points li\u00e9s \u00e0 ce poller\n\n\n\n\nLors de l'initialisation du poller, les actions suivantes sont effectu\u00e9es :\n\n\n\n\ncr\u00e9ation d'un zpoller \n\n\ncr\u00e9ation d'une liste vide de end-points\n\n\n\n\nFonction virtuelle d'ajout d'un end-point\n\n\nCette fonction ajoute le end-point pass\u00e9 en param\u00e8tre au poller. Le end-point est ajout\u00e9 \u00e0 la liste du poller, le socket correspondant est ajout\u00e9 au zpoller du poller.\n\n\nFonction virtuelle de suppression d'un end-point\n\n\nCette fonction supprime le  end-point pass\u00e9 en param\u00e8tre du poller. Le end-point est supprim\u00e9 de la liste du poller, le socket correspondant est supprim\u00e9 du zpoller du poller.\n\n\nFonction virtuelle d'attente de message sur un poller\n\n\nCette fonction se met en attente de r\u00e9ception d'un message sur le zpoller associ\u00e9.\n\n\nSi un message arrive avant l'expiration du timeout le end-point correspondant est recherch\u00e9 dans la liste des end-points et est retourn\u00e9 dans le param\u00e8tre correspondant. Si aucun end-point enregistr\u00e9 ne correspond une erreur est retourn\u00e9e.\n\n\nFonction virtuelle de destruction de message\n\n\nCette fonction v\u00e9rifie si le champ \nbody_owner\n du message MAL est affect\u00e9.\n\n\nSi c'est le cas, alors cela signifie que le message MAL a \u00e9t\u00e9 cr\u00e9\u00e9 (d\u00e9cod\u00e9) \u00e0 partir d'une trame ZMQ (\nzframe\n) qui doit donc \u00eatre d\u00e9truite (\nzframe_destroy\n).", 
            "title": "MAL/CZMQ"
        }, 
        {
            "location": "/mal_czmq/#transport-malczmq", 
            "text": "Cette section d\u00e9crit l'impl\u00e9mentation du transport  malzmq  sur l'API CZMQ. Il ne s'agit donc pas d'une description en terme de protocole (comme doit le faire le livre CCSDS MALZMQ) mais en terme d'API.  Le format d'encodage du header MAL est donn\u00e9 en annexe ###La m\u00eame description doit \u00eatre donn\u00e9e par le livre MALZMQ.  Un message MAL est transport\u00e9 dans une unique trame ZMQ (zframe).  Les sections suivantes d\u00e9crivent l'impl\u00e9mentation du module MAL/CZMQ :   Configuration du header MALZMQ  Constructeur d'un contexte MALZMQ  D\u00e9marrage  R\u00e9ception d'un message MAL  Impl\u00e9mentation des fonctions virtuelles impos\u00e9es par l'API MAL", 
            "title": "Transport MAL/CZMQ"
        }, 
        {
            "location": "/mal_czmq/#header-malzmq", 
            "text": "Une classe est d\u00e9finie pour g\u00e9rer les sp\u00e9cificit\u00e9s du format de header MALZMQ (voir annexe 14.3) :   Num\u00e9ro de version du mapping MALZMQ.  Catalogue de mapping.  Flags de pr\u00e9sence des champs de header MALZMQ optionnels.  Valeur des champs non pr\u00e9sents.", 
            "title": "Header MALZMQ"
        }, 
        {
            "location": "/mal_czmq/#constructeur", 
            "text": "malzmq_header_t *malzmq_header_new(\n  malzmq_mapping_directory_t *mapping_directory,\n  bool priority_flag, mal_uinteger_t priority,\n  bool timestamp_flag, mal_identifier_t *network_zone,\n  mal_identifier_t *session_name, mal_identifier_list_t *domain,\n  mal_blob_t *authentication_id);  Param\u00e8tres :   mapping_directory  : catalogue de mapping \u00e0 utiliser pour l'encodage (cf ###), peut \u00eatre NULL.  priority_flag  : flag de pr\u00e9sence du champ Priority dans le header MALZMQ.  priority  : valeur du champ Priority s'il n'est pas pr\u00e9sent dans le header MALZMQ.  timestamp_flag  : flag de pr\u00e9sence du champ Timestamp dans le header MALZMQ.  network_zone  : valeur du champ Network Zone s'il n'est pas pr\u00e9sent dans le header MALZMQ. Si NULL alors le champ Network Zone est pr\u00e9sent dans le header MALZMQ.  session_name  : idem pour le champ Session Name.  domain  : idem pour le champ Domain.  authentication_id  : idem pour le champ Authentication Id.", 
            "title": "Constructeur"
        }, 
        {
            "location": "/mal_czmq/#parametres-de-configuration", 
            "text": "Certains champs du header MAL peuvent \u00eatre toujours identiques pour une application. Les transf\u00e9rer lors de chaque appel serait redondant, et on peut donc optimiser les performances en les omettant du header MALZMQ. Ces champs sont les suivants :  PRIORITY ,  NETWORK_ZONE ,  SESSION_NAME ,  DOMAIN ,  AUTHENTICATION_ID . La pr\u00e9sence de ces champs dans le header MALZMQ, ainsi que leur \u00e9ventuelle valeur globale, est d\u00e9finie dans le constructeur du header MALZMQ.  Un autre champ du header MAL,  TIMESTAMP , peut \u00e9galement \u00eatre omis du header MALZMQ. Cette \u00e9ventuelle omission est \u00e9galement d\u00e9finie dans le constructeur du header MALZMQ. Il n'y a pas de valeur de remplacement d\u00e9finie pour ce champ.  Il va de soit que ces diff\u00e9rents param\u00e8tres de configuration doivent \u00eatre fournis de mani\u00e8re identique \u00e0 toutes les entit\u00e9s communiquantes de l'application.", 
            "title": "Param\u00e8tres de configuration"
        }, 
        {
            "location": "/mal_czmq/#catalogue-de-mapping", 
            "text": "Le header du message MAL contient de nombreux champs dont la taille peut \u00eatre importante : des URIs, des cha\u00eenes de caract\u00e8re, etc. Afin d'optimiser les performances les messages \u00e9chang\u00e9s entre les instances de MAL/CZMQ transportent des champs encod\u00e9s dans des types scalaires de taille moindre.  Afin de maintenir la compatibilit\u00e9 avec le MAL les champs des messages MAL/CZMQ ainsi encod\u00e9s sont syst\u00e9matiquement transform\u00e9s en leur \u00e9quivalent MAL lors de leur acc\u00e8s par l'utilisateur de l'API MAL. Pour ce faire la correspondance des informations doit \u00eatre maintenue tant cot\u00e9 consumer, que cot\u00e9 provider via un catalogue.  L'objet de cette section est de d\u00e9crire l'API d'acc\u00e8s \u00e0 ce catalogue et son usage.", 
            "title": "Catalogue de mapping"
        }, 
        {
            "location": "/mal_czmq/#principes", 
            "text": "Le catalogue de mapping conserve une correspondance entre des cha\u00eenes de caract\u00e8res et des valeurs num\u00e9riques. La valeur num\u00e9rique est appel\u00e9e  MDK  pour Mapping Directory Key.  Le catalogue permet de retrouver le MDK d'une cha\u00eene c\u00f4t\u00e9 encodage, et de retrouver la cha\u00eene d'un MDK c\u00f4t\u00e9 d\u00e9codage.  Il n'est pas de la responsabilit\u00e9 du MAL/CZMQ de s'assurer de la coh\u00e9rence du catalogue de chaque c\u00f4t\u00e9 de l'interaction. Cette responsabilit\u00e9 revient \u00e0 l'application. Le moyen le plus simple d'y parvenir est d'offrir un catalogue statique, fix\u00e9 une fois pour toute \u00e0 l'installation de l'application au niveau de tous les participants. Toutefois rien n'interdit \u00e0 une application d'offrir une implantation plus dynamique du catalogue.", 
            "title": "Principes"
        }, 
        {
            "location": "/mal_czmq/#encodage", 
            "text": "L'encodage d'une cha\u00eene sous sa forme MDK est optionnelle, afin de g\u00e9rer le cas o\u00f9 il n'existe pas de MDK dans le catalogue correspondant \u00e0 la cha\u00eene \u00e0 encoder. C'est pour cela que le mapping d\u00e9crit en 14.3 fait r\u00e9f\u00e9rence \u00e0 un type  Optional MDK .  Le principe de l'encodage  Optional MDK  est d\u00e9riv\u00e9 de l'encodage MAL binary d'une cha\u00eene de caract\u00e8res. Cet encodage consiste normalement en l'encodage de la longueur de la cha\u00eene, typ\u00e9e UInteger, suivi de l'encodage des caract\u00e8res eux-m\u00eames. L'encodage  Optional MDK  transforme ce champ longueur de 32 bits en une valeur de type Integer, pour en exploiter s\u00e9par\u00e9ment le signe et la valeur absolue. Le signe d\u00e9crit la nature du champ repr\u00e9sent\u00e9 par la valeur absolue, \u00e0 savoir un MDK si le signe est n\u00e9gatif, ou une longueur si le signe est positif. Dans le second cas les caract\u00e8res de la cha\u00eene sont encod\u00e9s \u00e0 la suite comme dans l'encodage MAL binary.  Une cha\u00eene encod\u00e9e sous sa forme MDK ne n\u00e9cessite donc que 4 octets, repr\u00e9sentant la valeur n\u00e9gative du MDK. Si elle n'est pas encod\u00e9e sous sa forme MDK, une cha\u00eene est conforme \u00e0 son encodage MAL binary.  Le cas particulier d'une valeur nulle pour l'Integer initial correspond \u00e0 l'encodage MAL binary, \u00e0 savoir la cha\u00eene vide. En cons\u00e9quence un MDK doit \u00eatre strictement positif.", 
            "title": "Encodage"
        }, 
        {
            "location": "/mal_czmq/#api", 
            "text": "Le catalogue de mapping, typ\u00e9  malzmq_mapping_directory_t , est fourni comme une table de fonctions.  typedef struct _malzmq_mapping_directory_t malzmq_mapping_directory_t;\nstruct _malzmq_mapping_directory_t {\n  malzmq_md_get_key_fn *get_key_fn;\n  malzmq_md_get_string_fn *get_string_fn;\n  malzmq_md_put_string_fn *put_string_fn;\n};  Champs :   get_key_fn  : renvoie le MDK d'une cha\u00eene s'il existe dans le catalogue  get_string_fn  : renvoie la cha\u00eene correspondant \u00e0 un MDK  put_string_fn  : ajoute une cha\u00eene au catalogue et renvoie le MDK correspondant.   Pour l'instant seules les deux premi\u00e8res fonctions sont utilis\u00e9es par le MAL/CZMQ.  Voici le d\u00e9tail d'interface de chacune de ces fonctions.  typedef int malzmq_md_get_key_fn(char *string, unsigned int *key);  Param\u00e8tres :   string  : cha\u00eene pour laquelle on recherche une \u00e9ventuelle clef de correspondance. Ne doit pas \u00eatre nulle.  key  : valeur de retour du MDK correspondant \u00e0 string, s'il existe.   R\u00e9sultat :   0 : ex\u00e9cution valide, valeur de retour key exploitable.  0 : code d'erreur, valeur de retour key ind\u00e9termin\u00e9e.   typedef int malzmq_md_get_string_fn(unsigned int key, char **string);  Param\u00e8tres :   key  : MDK pour lequel on recherche une cha\u00eene associ\u00e9e.  string  : valeur de retour de la cha\u00eene correspondant \u00e0 key, si elle existe. Cette cha\u00eene a \u00e9t\u00e9 allou\u00e9e et doit \u00eatre lib\u00e9r\u00e9e par free ou par les diverses fonctions sp\u00e9cifiques (mal_string_destroy, etc).   R\u00e9sultat :   0 : ex\u00e9cution valide, valeur de retour string exploitable.  0 : code d'erreur, valeur de retour string ind\u00e9termin\u00e9e.   typedef int malzmq_md_put_string_fn(char *string, unsigned int *key);  Param\u00e8tres :   string  : cha\u00eene pour laquelle on souhaite cr\u00e9er une clef de correspondance. Ne doit pas \u00eatre nulle. Le catalogue ne doit pas conserver la cha\u00eene telle quelle au del\u00e0 de cet appel, afin de permettre \u00e0 l'appelant de la lib\u00e9rer au besoin.  key  : valeur de retour du MDK correspondant \u00e0 string. Doit \u00eatre strictement positive et strictement inf\u00e9rieure \u00e0 231. Cette valeur distinctive est cr\u00e9\u00e9e si et seulement si il n'existait pas auparavant une autre valeur correspondante dans le catalogue.   R\u00e9sultat :   0 : ex\u00e9cution valide, valeur de retour key exploitable.  0 : code d'erreur, cha\u00eene non enregistr\u00e9e dans le catalogue et valeur de retour key ind\u00e9termin\u00e9e.   Note :  les fonctions du catalogue ne travaillent que sur des cha\u00eenes (char*), car les diff\u00e9rents types cibles  mal_string_t ,  mal_uri_t  et  mal_identifier_t , ne sont eux-m\u00eames que des  char* . Si ce n'\u00e9tait pas le cas, il faudrait que le catalogue fournisse des fonctions distinctes pour chacun de ces types.", 
            "title": "API"
        }, 
        {
            "location": "/mal_czmq/#usage", 
            "text": "Le catalogue n'est pour l'instant utilis\u00e9 que pour les champs du header suivants :  URI from ,  URI to ,  Network Zone ,  Session Name ,  Domain .  L'utilisation du catalogue pour des champs choisis du body est envisageable, mais casserait la conformit\u00e9 actuelle de l'encodage du body au format MAL binary.", 
            "title": "Usage"
        }, 
        {
            "location": "/mal_czmq/#constructeur-du-contexte-malzmq", 
            "text": "malzmq_ctx_t *malzmq_ctx_new(\n  mal_ctx_t *mal_ctx,\n  malzmq_mapping_uri_t *mapping_uri,\n  char *hostname, char *port, malzmq_header_t *malzmq_header,\n  malbinary_encoder_t *encoder, malbinary_decoder_t *decoder,\n  bool verbose);  Param\u00e8tres :   mal_ctx  : le contexte MAL.  mapping_uri  : fonctions de transformation de l'URI MAL d'un service en URI ZMQ. Ce mapping peut-\u00eatre NULL, dans ce cas les fonctions de transformation d'URI par d\u00e9faut de l'implantation sont utilis\u00e9es (voir section ###).  hostname  : addresse IP utilis\u00e9e pour accepter les connexions entrantes.  port  : port utilis\u00e9 pour accepter les connexions entrantes.  malzmq_header  : flags et champs optionnels. La configuration du header MALZMQ est globale au contexte MALZMQ.  encoder  : contexte d'encodage utilis\u00e9 pour encoder les headers MAL.  decoder  : contexte de d\u00e9codage utilis\u00e9 pour d\u00e9coder les headers MAL.  verbose  : flag d'activation des traces.   Le constructeur effectue les actions suivantes :   Cr\u00e9ation d'une socket ZMQ de type ROUTER permettant d'accepter les connexions ouvertes par d'autres contextes MALZMQ distants :  SOCKET_MAL_ROUTER . L'URI ZMQ utilis\u00e9e par le bind est d\u00e9termin\u00e9e \u00e0 partir des param\u00e8tres  hostname  et  port  et des fonctions de transformation d'URI pass\u00e9es en param\u00e8tre.  Cr\u00e9ation d'une socket ZMQ de type SUB permettant la r\u00e9ception des messages diffus\u00e9s par les autres contextes MALZMQ :  SOCKET_MAL_SUB . L'URI ZMQ utilis\u00e9e par le bind est d\u00e9termin\u00e9e \u00e0 partir des param\u00e8tres  hostname  et  port  et des fonctions de transformation d'URI pass\u00e9es en param\u00e8tre.  Cr\u00e9ation d'une socket ZMQ de protocole  inproc  et de type ROUTER permettant de communiquer avec les acteurs MALZMQ du contexte :   SOCKET_Z_ROUTER .  Une  zloop  est cr\u00e9\u00e9e pour g\u00e9rer les deux sockets  ROUTER .", 
            "title": "Constructeur du contexte MALZMQ"
        }, 
        {
            "location": "/mal_czmq/#fonctions-de-transformation-duri", 
            "text": "La transformation des URI MAL en URI ZMQ est assur\u00e9e par 3 fonctions :   La premi\u00e8re get_p2p_zmquri prend en param\u00e8tre l'URI MAL d'un service et retourne l'URI ZMQ de bind du socket DEALER d'\u00e9coute du contexte MAL correspondant. Par exemple :  malzmq://host:port/service \u2192 tcp://*:port  La seconde get_ps_zmquri prend en param\u00e8tre l'URI MAL d'un service et retourne l'URI ZMQ sur laquelle connecter le socket SUB d'\u00e9coute du contexte MAL correspondant. Par exemple :  malzmq://host:port/service \u2192 tcp://host:(port+1) ou pgm://itf;mcast_addr:(port+1)  La derni\u00e8re  get_zmquri_to  prend en param\u00e8tre un message MAL \u00e0 \u00e9mettre et retourne l'URI ZMQ correspondante en fonction de l'\u00e9tape de l'interaction et de l'URI MAL du destinataire. Si l'URI du destinataire est  malzmq://host1:port1/service  :\n\u25e6   MAL_INTERACTIONTYPE_INVOKE, MAL_IP_STAGE_INVOKE\n\u25aa   tcp://host1:port1\n\u25e6   MAL_INTERACTIONTYPE_PUBSUB, MAL_IP_STAGE_PUBSUB_PUBLISH\n\u25aa   tcp://*:(port1+1) ou epgm://itf;mcast_addr:(port+1)   Les fonctions permettant la transformation des URI MAL en URI ZMQ sont pass\u00e9es au contexte MALZMQ au travers d'une structure malzmq_mapping_uri_t. Si ce param\u00e8tre est nul les fonctions d\u00e9finies par d\u00e9faut dans le transport MALZMQ sont utilis\u00e9es ; ces fonctions consid\u00e8rent que le transport utilis\u00e9 est TCP pour toutes les interactions et que le port utilis\u00e9 pour le Publish / Subscribe est le port du service incr\u00e9ment\u00e9 de 1 (cf section ###).  typedef mal_uri_t *malzmq_get_p2p_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_get_ps_zmquri_fn(mal_uri_t *maluri);\ntypedef mal_uri_t *malzmq_getzmquri_to_fn(mal_message_t *message);\n\ntypedef struct _malzmq_mapping_uri_t malzmq_mapping_uri_t;\n\nstruct _malzmq_mapping_uri_t {\n  malzmq_get_p2p_zmquri_fn *get_p2p_zmquri_fn;\n  malzmq_get_ps_zmquri_fn *get_ps_zmquri_fn;\n  malzmq_getzmquri_to_fn *getzmquri_to_fn;\n};", 
            "title": "Fonctions de transformation d'URI"
        }, 
        {
            "location": "/mal_czmq/#mapping-par-defaut", 
            "text": "Le mapping par d\u00e9faut du transport MAL/CZMQ implant\u00e9 dans le POC utilise le protocole TCP tant pour les communications Point-to-Point que Publish/Subscribe :   malzmq_get_p2p_zmquri_fn\n\u25e6   malzmq://host:port/service \u2192 tcp://*:port  typedef int malzmq_get_ps_zmquri_fn\n\u25e6   malzmq://host:port/service \u2192 tcp://host:port_ps, o\u00f9 port_ps=port+1  typedef int malzmq_getzmquri_to_fn\n\u25e6   Si les champs interaction_type et interaction_stage du message pass\u00e9 en param\u00e8tre sont MAL_INTERACTIONTYPE_PUBSUB et MAL_IP_STAGE_PUBSUB_PUBLISH :\n\u25aa   malzmq://host1:port1/service \u2192 tcp://host1:port1_ps, o\u00f9 port1_ps=port1+1\n\u25e6   Dans tous les autres cas :\n\u25aa   malzmq://host1:port1/service \u2192 tcp://host1:port1", 
            "title": "Mapping par d\u00e9faut"
        }, 
        {
            "location": "/mal_czmq/#demarrage", 
            "text": "La fonction suivante permet de d\u00e9marrer le contexte MALZMQ. Cette fonction d\u00e9marre la zloop et bloque tant que la zloop ne s'est pas termin\u00e9e.  int malzmq_ctx_start(malzmq_ctx_t *self);", 
            "title": "D\u00e9marrage"
        }, 
        {
            "location": "/mal_czmq/#comportement-de-la-zloop", 
            "text": "La zloop est en \u00e9coute ( SOCKET_MAL_ROUTER  et  SOCKET_MAL_SUB ) des messages \u00e9mis par les acteurs MALZMQ distants. Lorsqu'un message ZMQ est re\u00e7u, les actions suivantes sont effectu\u00e9es :   Extraction et destruction de la premi\u00e8re trame contenant l'identit\u00e9 de l'appelant. En effet, actuellement, les connexions ZMQ sont utilis\u00e9es seulement \u00e0 sens unique, en cons\u00e9quence l'identit\u00e9 de l'appelant n'est pas conserv\u00e9e.  La trame suivante n'est pas extraite ( zmsg_pop ) du message ZMQ mais seulement lue ( zmsg_next ) afin de permettre la r\u00e9utilisation du message ZMQ pour l'envoyer \u00e0 l'acteur destinataire.  Seul le champ  URI To  est d\u00e9cod\u00e9. Ce champ donne l'identit\u00e9 de la socket  DEALER  utilis\u00e9e par l'acteur destinataire.  Le message ZMQ re\u00e7u est renvoy\u00e9 \u00e0 l'acteur destinataire au travers de  SOCKET_ACTOR_ROUTER .", 
            "title": "Comportement de la zloop"
        }, 
        {
            "location": "/mal_czmq/#reception-dun-message-par-un-end-point-malzmq", 
            "text": "Lors de la demande de r\u00e9ception d'un message par un end-point MAL, le transport MALZMQ se met en \u00e9coute sur le socket connect\u00e9 au socket router de la zloop.  A la r\u00e9ception d'un message MAL :   La premi\u00e8re et unique trame du message ZMQ est extraite.  Une structure  mal_message  est instanci\u00e9e.  Les champs du header MAL sont d\u00e9cod\u00e9s. Les champs optionnels non encod\u00e9s du header MAL sont affect\u00e9s \u00e0 partir de la configuration du header MALZMQ qui est globale au contexte MALZMQ.  Le corps du message est directement affect\u00e9 \u00e0 partir de la trame ZMQ ( data  de  zframe ) sans copie. En cons\u00e9quence, la trame ZMQ ne peut \u00eatre d\u00e9truite qu'au moment de la destruction du message MAL (voir section 12.13). Le champ  body_owner  du message MAL est affect\u00e9 avec la trame ZMQ.  Le message MAL est retourn\u00e9 \u00e0 l'appelant, la destruction du message MAL est \u00e0 la responsabilit\u00e9 du traitant de ce message.", 
            "title": "R\u00e9ception d'un message par un end-point MALZMQ"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-de-creation-duri", 
            "text": "Le format d'URI est le suivant :  malzmq:// hostname : port / id   Le protocole de transport utilis\u00e9 par ZMQ n'est pas sp\u00e9cifi\u00e9 dans l'URI. Il est sp\u00e9cifi\u00e9 \u00e0 la cr\u00e9ation du contexte MALZMQ.  Dans certains cas, le contexte MALZMQ pourrait optimiser la communication en utilisant un protocole de transport plus efficace, par exemple :   ipc  : si le consumer et le provider sont sur la m\u00eame machine (m\u00eame 'hostname')  inproc  : si le consumer et le provider sont dans le m\u00eame processus (attention dans ce cas \u00e0 l'ordre de d\u00e9marrage car 'inproc' n'assure pas le d\u00e9couplage temporel des sockets ZMQ)   Cette optimisation n'est pour l'instant pas impl\u00e9ment\u00e9e.", 
            "title": "Fonction virtuelle de cr\u00e9ation d'URI"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-de-creation-de-end-point", 
            "text": "Un end-point MALZMQ est cr\u00e9\u00e9 et retourn\u00e9 comme r\u00e9sultat (en pointeur non typ\u00e9  void * ).  Les donn\u00e9es sp\u00e9cifiques au end-point MALZMQ sont :   le contexte MALZMQ,  le end-point MAL pass\u00e9 en param\u00e8tre de la fonction,  la socket de r\u00e9ception des messages MAL rout\u00e9s par la zloop,  une table de hash contenant les sockets ZMQ ouvertes vers des contextes MALZMQ distants.   Lors de l'initialisation du end-point, les actions suivantes sont effectu\u00e9es :   cr\u00e9ation d'une socket ZMQ de type DEALER  affectation de l'identit\u00e9 de cette socket avec l'URI du end-point  connexion de cette socket avec la socket router g\u00e9r\u00e9e par la zloop    (ZLOOP_ENDPOINTS_SOCKET_URI)", 
            "title": "Fonction virtuelle de cr\u00e9ation de end-point"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-denvoi-de-message", 
            "text": "L'URI MAL destinataire du message est transform\u00e9e en URI ZMQ :   Format d'URI MAL :  malzmq:// hostname : port / id  Format d'URI ZMQ :  protocole zmq :// hostname : port   Une socket de type DEALER connect\u00e9e \u00e0 cette URI est recherch\u00e9e dans une table de hash appartenant \u00e0 l'acteur (structure  malzmq_actor_data ). Si la socket n'est pas trouv\u00e9e alors elle est cr\u00e9\u00e9e et enregistr\u00e9e dans la table (la cl\u00e9 \u00e9tant l'URI ZMQ).  Le message MAL est encod\u00e9 et transmis dans une unique trame ZMQ.", 
            "title": "Fonction virtuelle d'envoi de message"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-de-creation-de-poller", 
            "text": "Un poller MALZMQ est cr\u00e9\u00e9 et retourn\u00e9 comme r\u00e9sultat (en pointeur non typ\u00e9  void * ).  Les donn\u00e9es sp\u00e9cifiques au poller MALZMQ sont :   le contexte MALZMQ,  le poller MAL pass\u00e9 en param\u00e8tre de la fonction,  le zpoller permettant l'attente sur les sockets des end-points..  la liste des end-points li\u00e9s \u00e0 ce poller   Lors de l'initialisation du poller, les actions suivantes sont effectu\u00e9es :   cr\u00e9ation d'un zpoller   cr\u00e9ation d'une liste vide de end-points", 
            "title": "Fonction virtuelle de cr\u00e9ation de poller"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-dajout-dun-end-point", 
            "text": "Cette fonction ajoute le end-point pass\u00e9 en param\u00e8tre au poller. Le end-point est ajout\u00e9 \u00e0 la liste du poller, le socket correspondant est ajout\u00e9 au zpoller du poller.", 
            "title": "Fonction virtuelle d'ajout d'un end-point"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-de-suppression-dun-end-point", 
            "text": "Cette fonction supprime le  end-point pass\u00e9 en param\u00e8tre du poller. Le end-point est supprim\u00e9 de la liste du poller, le socket correspondant est supprim\u00e9 du zpoller du poller.", 
            "title": "Fonction virtuelle de suppression d'un end-point"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-dattente-de-message-sur-un-poller", 
            "text": "Cette fonction se met en attente de r\u00e9ception d'un message sur le zpoller associ\u00e9.  Si un message arrive avant l'expiration du timeout le end-point correspondant est recherch\u00e9 dans la liste des end-points et est retourn\u00e9 dans le param\u00e8tre correspondant. Si aucun end-point enregistr\u00e9 ne correspond une erreur est retourn\u00e9e.", 
            "title": "Fonction virtuelle d'attente de message sur un poller"
        }, 
        {
            "location": "/mal_czmq/#fonction-virtuelle-de-destruction-de-message", 
            "text": "Cette fonction v\u00e9rifie si le champ  body_owner  du message MAL est affect\u00e9.  Si c'est le cas, alors cela signifie que le message MAL a \u00e9t\u00e9 cr\u00e9\u00e9 (d\u00e9cod\u00e9) \u00e0 partir d'une trame ZMQ ( zframe ) qui doit donc \u00eatre d\u00e9truite ( zframe_destroy ).", 
            "title": "Fonction virtuelle de destruction de message"
        }, 
        {
            "location": "/stub_generator/", 
            "text": "G\u00e9n\u00e9ration du code des stubs\n\n\nLe code g\u00e9n\u00e9r\u00e9 est produit pour une mission donn\u00e9e utilisant un ensemble d'Areas de service.\n\n\nL'instruction 'calloc' (initialise \u00e0 '0' les octets allou\u00e9s) est utilis\u00e9e pour allouer des structures ou des tableaux de pointeurs afin d'\u00e9viter, en cas d'initialisation incompl\u00e8te, que le destructeur ne lib\u00e8re de la m\u00e9moire au travers de faux pointeurs.\n\n\nArea\n\n\nUn nouveau projet de type 'zproject' est cr\u00e9\u00e9 pour chaque Area. Il porte le nom de l'Area en carcat\u00e8res minuscules : \narea\n\n\nFichier include (.h)\n\n\nUn fichier \narea\n.h\n est d\u00e9fini pour chaque area.\n\n\nEnt\u00eate\n\n\n#ifndef __\nAREA\n_H_INCLUDED__\n#define __\nAREA\n_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nD\u00e9claration de la d\u00e9pendance avec l'Area MAL :\n\n\n#include \nmal.h\n\n\n\n\n\nPour chaque Area requise :\n\n\n#include \nrequired area\n.h\n\n\n\n\n\nConstantes\n\n\nD\u00e9finition des constantes suivantes :\n\n\n#define \nAREA\n_AREA_NUMBER \narea number\n\n#define \nAREA\n_AREA_VERSION \nversion\n\n\n\n\n\nPour chaque service :\n\n\n#define \nAREA\n_\nSERVICE\n_SERVICE_NUMBER \nservice number\n\n\n\n\n\nPour chaque op\u00e9ration de service :\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER \noperation number\n\n\n\n\n\nPour chaque erreur lev\u00e9e par une op\u00e9ration :\n\n\n#define \nAREA\n_\nSERVICE\n_\nOPERATION\n_\nERROR\n_ERROR_NUMBER \nerror number\n\n\n\n\n\nTypes\n\n\nPour chaque type Enumeration :\n\n\ntypedef enum {\n  \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_\nENUMERATED NAME\n,\n} \narea\n_[\nservice\n_]\nenumeration\n_t;\n\n\n\n\nPour chaque Composite :\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ncomposite\n_t\n  \narea\n_[\nservice\n_]\ncomposite\n_t;\n\n\n\n\nPour chaque type de donn\u00e9e d\u00e9fini pr\u00e9c\u00e9demment (Enumeration, Composite) :\n\n\ntypedef struct _\narea\n_[\nservice\n_]\ntype\n_list_t\n  \narea\n_[\nservice\n_]\ntype\n_list_t;\n\n\n\n\nPour chaque type de donn\u00e9e, calcul de l'identifiant entier 'short form' (typ\u00e9 'long') comme d\u00e9fini en section 5.2.3 du livre MAL/SPP :\n\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM \nshort form\n\n#define \nAREA\n_[\nSERVICE\n_]\nTYPE\n_LIST_SHORT_FORM \nshort form\n\n\n\n\n\nOp\u00e9rations\n\n\nPour chaque op\u00e9ration de service, except\u00e9 si le pattern d'interaction est Publish/Subscribe, les fonctions suivantes sont d\u00e9finies :\n\n\n\n\nune fonction d'envoi de message pour l'initiation d'une interaction (premi\u00e8re \u00e9tape) ;\n\n\nune fonction d'envoi de message pour chaque \u00e9tape de r\u00e9sultat d'une interaction (seconde \u00e9tape et suivantes).\n\n\n\n\nInitiation d'interaction (except\u00e9 Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nfirst stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri);\n\n\n\n\nR\u00e9sultat d'interaction (except\u00e9 Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nresult stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message, mal_message_t *result_message,\n  bool is_error_message);\n\n\n\n\nPour chaque op\u00e9ration de service dont le pattern d'interaction est Publish/Subscribe, des fonctions sont d\u00e9finies pour les \u00e9tapes suivantes de l'interaction : register, publishRegister, publish, deregister, publishDeregister.\n\n\nAbonnement (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_register(\n  mal_ctx_t *mal_ctx, mal_endpoint_t *endpoint, mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nD\u00e9claration de publication (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nPublication (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid);\n\n\n\n\nD\u00e9sabonnement (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nArr\u00eat de publication (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);\n\n\n\n\nFonctions d'encodage\n\n\nPour chaque message d'\u00e9tape d'interaction de chaque op\u00e9ration de service, les fonctions suivantes sont d\u00e9finies :\n\n\n\n\npour chaque \u00e9l\u00e9ment de corps de message (identifi\u00e9 par son index), et pour chaque type en cas de polymorphisme (voir 9.4.1) :\n\n\nune fonction de calcul de taille d'encodage\n\n\nune fonction d'encodage\n\n\npour chaque \u00e9l\u00e9ment de corps de message (identifi\u00e9 par son index et son type d\u00e9clar\u00e9) :\n\n\nune fonction de d\u00e9codage\n\n\n\n\n\n\n\n\nLes op\u00e9rations dont le pattern d'interaction est Publish/Subscribe sont trait\u00e9es de mani\u00e8re particuli\u00e8re. Les trois fonctions d'encodage ne sont g\u00e9n\u00e9r\u00e9es que pour une seule \u00e9tape d'interaction fictive, l'\u00e9tape update, qui correspond aux deux \u00e9tapes publish et notify, et dont les types de param\u00e8tres sont d\u00e9finis dans la sp\u00e9cification de l'op\u00e9ration sous la forme d'un message publishNotify. De plus les param\u00e8tres effectivement utilis\u00e9s dans les fonctions d'encodage sont des listes du type d\u00e9clar\u00e9 dans la sp\u00e9cification.\n\n\nLes fonctions d'encodage li\u00e9es aux messages d'erreur suivent le sch\u00e9ma g\u00e9n\u00e9ral avec les particularit\u00e9s suivantes :\n\n\n\n\nle nom des fonctions ne comprend pas d'index,\n\n\nle nom des fonctions d'encodage comprend syst\u00e9matiquement le suffixe de type \n_qftype\n,\n\n\nla fonction de d\u00e9codage suit le mod\u00e8le de d\u00e9codage avec polymorphisme d'Element.\n\n\n\n\nCalcul de taille d'encodage\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length);\n\n\n\n\nSinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  \nqftype\n_t element, unsigned int *encoding_length);\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, \nqftype\n_[list_]t *element,\n  unsigned int *encoding_length);\n\n\n\n\nSi l'op\u00e9ration est Pub/Sub, la fonction est g\u00e9n\u00e9r\u00e9e pour le type liste du type d\u00e9clar\u00e9 dans la sp\u00e9cification :\n\n\nint \nqfop\n_update_add_encoding_length[_\nindex\n][_\nqftype\n_list](\n    int encoding_format_code, void * encoder,\n    \nqftype\n_list_t *element,\n    unsigned int *encoding_length);\n\n\n\n\nEncodage\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);\n\n\n\n\nSinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, \nqftype\n_t element);\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, \nqftype\n_[list_]t *element);\n\n\n\n\nSi l'op\u00e9ration est Pub/Sub, la fonction est g\u00e9n\u00e9r\u00e9e pour le type liste du type d\u00e9clar\u00e9 dans la sp\u00e9cification :\n\n\nint \nqfop\n_update_encode[_\nindex\n][_\nqftype\n_list](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, \nqftype\n_list_t *element);\n\n\n\n\nD\u00e9codage\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);\n\n\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment, y compris si l'op\u00e9ration est PubSub (stage = update), et/ou pour un message d'erreur :\n\n\nint \nqfop\n_\nstage|error\n_decode[_\nindex\n](\n  int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder);\n\n\n\n\nSi le type de l'\u00e9l\u00e9ment est connu :\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res, \nqftype\n_t *element_res);\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, \nqftype\n_[list_]t **element_res);\n\n\n\n\nSi l'op\u00e9ration est Pub/Sub, la fonction est g\u00e9n\u00e9r\u00e9e pour le type liste du type d\u00e9clar\u00e9 dans la sp\u00e9cification, except\u00e9 en cas de polymorphisme o\u00f9 le cas standard de polymorphisme d'\u00e9l\u00e9ment est repris.\n\n\nint \nqfop\n_update_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, \nqftype\n_list_t **element_res);\n\n\n\n\nFin du fichier\n\n\nUne fonction de test :\n\n\nvoid \narea\n_test(bool verbose);\n\n\n\n\nPour chaque structure Composite :\n\n\n#include \narea\n_[\nservice\n_]\ncomposite\n.h\n\n\n\n\n\nPour chaque liste de Composite :\n\n\n#include \narea\n_[\nservice\n_]\ncomposite\n_list.h\n\n\n\n\n\nPour chaque liste d'\u00e9num\u00e9r\u00e9:\n\n\n#include \narea\n_[\nservice\n_]\nenumeration\n_list.h\n\n\n\n\n\nFin du ficher :\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nFichier source (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nPour chaque \u00e9num\u00e9ration :\n\n\nint \nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_NUMERIC_VALUES[] = {\n  \nnumeric value\n,\n}\n\n\n\n\nInitiation d'interaction (except\u00e9 Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nfirst stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration appel\u00e9e :\n\n\n  mal_message_init(init_message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_\nIP\n,\n    MAL_IP_STAGE_\nSTAGE\n);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_init_operation(\n    endpoint, init_message, provider_uri, true);\n  return rc;\n}\n\n\n\n\nR\u00e9sultat d'interaction (except\u00e9 Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_\nresult stage\n(\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_message_t *result_message,\n  bool is_error_message) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration :\n\n\n  mal_message_init(result_message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_\nIP\n,\n    MAL_IP_STAGE_\nSTAGE\n);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_return_operation(\n    endpoint, init_message, result_message, is_error_message);\n  return rc;\n}\n\n\n\n\nAbonnement (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration :\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_REGISTER);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nD\u00e9claration de publication (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration :\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nPublication (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration :\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH);\n\n\n\n\nAffectation du \nTransaction Id\n :\n\n\n  mal_message_set_transaction_id(message, initial_publish_register_tid);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, false);\n  return rc;\n}\n\n\n\n\nD\u00e9sabonnement (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration :\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_DEREGISTER);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nArr\u00eat de publication (Publish/Subscribe)\n\n\nint \narea\n_\nservice\n_\noperation\n_publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;\n\n\n\n\nAffectation des champs li\u00e9s \u00e0 l'op\u00e9ration :\n\n\n  mal_message_init(message, \nAREA\n_AREA_NUMBER,\n    \nAREA\n_AREA_VERSION, \nAREA\n_\nSERVICE\n_SERVICE_NUMBER,\n    \nAREA\n_\nSERVICE\n_\nOPERATION\n_OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER);\n\n\n\n\nEnvoi du message :\n\n\n  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}\n\n\n\n\nCalcul de taille d'encodage\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length) {\n\n\n\n\nSinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  \nqftype\n_t element, unsigned int *encoding_length) {\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\n\nint \nqfop\n_\nstage|error\n_add_encoding_length[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, void *encoder, \nqftype\n_[list_]t *element,\n  unsigned int *encoding_length) {\n```c\n\nInitialisation du code d'erreur :\n\n```c\n  int rc = 0;\n\n\n\n\nTest du type de l'encodage :\n\n\n  switch (encoding_format_code) {\n\n\n\n\nPour chaque format disponible :\n\n\n  case \nFORMAT\n_FORMAT_CODE: {\n    \nformat\n_encoder_t *\nformat\n_encoder =\n      (\nformat\n_encoder_t *) encoder;\n\n\n\n\nCalcul de la taille d'encodage d'un champ optionnel :\n  - Pour le format \nmalbinary\n, voir section 11.1.1.\n\n\n    break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}\n\n\n\n\nEncodage\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element) {\n\n\n\n\nSinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n  - Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, \nqftype\n_t element) {\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :\n\n\n\n\nint \nqfop\n_\nstage|error\n_encode[_\nindex\n][_\nqftype\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, \nqftype\n_[list_]t *element) {\n  presence_flag = (element != NULL);\n\n\n\n\nInitialisation du code d'erreur :\n\n\n  int rc = 0;\n\n\n\n\nTest du type de l'encodage :\n\n\n  switch (encoding_format_code) {\n\n\n\n\nPour chaque format disponible :\n\n\n  case \nFORMAT\n_FORMAT_CODE: {\n    \nformat\n_encoder_t *\nformat\n_encoder =\n      (\nformat\n_encoder_t *) encoder;\n\n\n\n\nEncodage d'un champ optionnel :\n\n\n\n\nPour le format \nmalbinary\n, voir section 11.2.2.\n\n\n\n\n    break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}\n\n\n\n\nD\u00e9codage\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res) {\n\n\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment et/ou pour un message d'erreur :\n\n\nint \nqfop\n_\nstage|error\n_decode[_\nindex\n](\n  int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder) {\n\n\n\n\nSi le type de l'\u00e9l\u00e9ment est connu :\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes , unsigned int *offset,\n  void *decoder, bool *presence_flag_res, \nqftype\n_t *element_res) {\n\n\n\n\n\n\nSi l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :\n\n\n\n\nint \nqfop\n_\nstage\n_decode[_\nindex\n](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, \nqftype\n_[list_]t **element_res) {\n\n\n\n\nInitialisation du code d'erreur :\n\n\n  int rc = 0;\n\n\n\n\nTest du type de l'encodage :\n\n\n  switch (encoding_format_code) {\n\n\n\n\nPour chaque format disponible :\n\n\n  case \nFORMAT\n_FORMAT_CODE: {\n    \nformat\n_decoder_t *\nformat\n_decoder =\n      (\nformat\n_encoder_t *) decoder;\n      bool presence_flag;\n\n\n\n\nD\u00e9codage d'un champ optionnel :\n\n\n\n\nPour le format \nmalbinary\n, voir section 11.3.1.\n\n\nLe d\u00e9codage est r\u00e9alis\u00e9 directement dans la structure ou le pointeur r\u00e9sultat.\n\n\nEn cas de polymorphisme d'Attribut ou si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 : \n(*presence_flag_res) = presence_flag;\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment : \nmal_element_holder_set_presence_flag(element_holder, presence_flag);\n\n\n\n\n\n\n\n\nFin du d\u00e9codage.\n\n\n    break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}\n\n\n\n\nComposite\n\n\nFichier include (.h)\n\n\n#ifndef __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_H_INCLUDED__\n#define __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nConstructeur sans param\u00e8tre :\n\n\narea\n_[\nservice\n_]\ncomposite\n_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_new(void);\n\n\n\n\nPour chaque format d'encodage :\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_add_encoding_length_\nformat\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nformat\n_encoder_t *encoder,\n    unsigned int *encoding_length);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_encode_\nformat\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nformat\n_encoder_t *encoder,\n    char *bytes, unsigned int *offset);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_decode_\nformat\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nformat\n_decoder_t *decoder,\n    char *bytes, unsigned int *offset);\n\n\n\n\nPour chaque champ du composite (y compris les champs h\u00e9rit\u00e9s) :\n\n\nfield type\n \narea\n_[\nservice\n_]\ncomposite\n_get_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_set_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nfield type\n \nfield\n);\n\n\n\n\nSi le champ n'est pas un pointeur (valeur NULL interdite) :\n\n\nbool \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_is_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, bool is_present);\n\n\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nunsigned char \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_get_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self);\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, unsigned char attribute_tag);\n\n\n\n\nDestructeur :\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_t **self_p);\n\n\n\n\nFonction de test :\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_test(bool verbose);\n\n\n\n\nFin du fichier :\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nFichier source (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nD\u00e9finition de la structure\n\n\nstruct _\narea\n_[\nservice\n_]\ncomposite\n_t {\n\n\n\n\nPour chaque champ (y compris les champs h\u00e9rit\u00e9s) :\n\n\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nSi le champ est optionnel (canBeNull = 'true') : \nbool \nfield\n_is_present\n;\n\n\nD\u00e9claration du champ :\n\n\n\n\n  unsigned char \nfield\n_attribute_tag;\n  union mal_attribute_t \nfield\n;\n\n\n\n\n\n\nSi le champ est de type Attribut non pointeur, ou \u00e9num\u00e9r\u00e9 :\n\n\nSi le champ est optionnel (canBeNull = 'true') : \nbool \nfield\n_is_present;\n\n\nD\u00e9claration du champ : \nfield type\n \nfield\n;\n\n\nSinon : \nfield type\n *\nfield\n;\n\nFin de la d\u00e9finition de la structure : \n};\n\n\n\n\nConstructeur\n\n\narea\n_[\nservice\n_]\ncomposite\n_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_new(void) {\n  \narea\n_[\nservice\n_]\ncomposite\n_t *self =\n      (\narea\n_[\nservice\n_]\ncomposite\n_t *) calloc(\n          1, sizeof(\narea\n_[\nservice\n_]\ncomposite\n_t));\n  if (!self)\n    return NULL;\n  return self;\n}\n\n\n\n\nGetters et setters\n\n\nPour chaque champ du composite (y compris les champs h\u00e9rit\u00e9s) :\n\n\nfield type\n \narea\n_[\nservice\n_]\ncomposite\n_get_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self) {\n  return self-\nfield\n;\n}\n\n\n\n\nLa fonction \nsetter\n n'affecte que la valeur du champ. Le flag de pr\u00e9sence ne doit pas \u00eatre modifi\u00e9.\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_set_\nfield\n(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, \nfield type\n \nfield\n) {\n  self-\nfield\n = \nfield\n;\n}\n\n\n\n\nSi le champ est optionnel (canBeNull = 'true') et si le champ n'est pas un pointeur :\n\n\nbool \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_is_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self) {\n  return self-\nfield\n_is_present;\n}\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_present(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self, bool is_present) {\n  self-\nfield\n_is_present = is_present;\n}\n\n\n\n\nEn cas de polymorphisme d'Attribut :\n\n\nunsigned char \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_get_attribute_tag(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self) {\n  return self-\nfield\n_attribute_tag;\n}\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_\nfield\n_set_attribute_tag(\n  \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n  unsigned char attribute_tag) {\n  self-\nfield\n_attribute_tag = attribute_tag;\n}\n\n\n\n\nCalcul de la taille encod\u00e9e (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_add_encoding_length_malbinary(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n    malbinary_encoder_t *malbinary_encoder,\n    unsigned int *encoding_length) {\n  int rc = 0;\n\n\n\n\nPour chaque champ (les champs h\u00e9rit\u00e9s en premier) :\n\n\n\n\nSi le champ est optionnel, voir section 11.1.1.\n\n\nSinon voir section 11.1.2.\n\n\n\n\nFin de la fonction :\n  return rc;\n}\n\n\n\n\nEncodage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_encode_malbinary(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n    malbinary_encoder_t *malbinary_encoder,\n    char *bytes, unsigned int *offset) {\n\n\n\n\nS'il existe au moins un champ optionnel :\n\n\n  bool presence_flag;\n\n\n\n\nPour chaque champ (les champs h\u00e9rit\u00e9s en premier) :\n\n\n\n\nSi le champ est optionnel :\n\n\nSi le champ est de type Attribut non pointeur, ou \u00e9num\u00e9r\u00e9 : \n\n\n\n\npresence_flag = self-\nfield\n_is_present;\n\n\n\n\n\n\nSinon : \n\n\n\n\npresence_flag = (self-\nfield\n != NULL);\n\n\n\n\n\n\nVoir section 11.2.1.\n\n\nSinon voir section 11.2.2.\n\n\n\n\nFin de l'encodage :\n\n\n  return rc;\n}\n\n\n\n\nD\u00e9codage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_decode_malbinary(\n    \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n    malbinary_decoder_t *malbinary_decoder,\n    char *bytes, unsigned int *offset) {\n\n\n\n\nS'il existe au moins un champ optionnel : \nbool presence_flag;\n\n\nPour chaque champ (les champs h\u00e9rit\u00e9s en premier) :\n\n\n\n\nSi le champ est optionnel, voir section 11.3.1.\n\n\nSinon voir section 11.3.2.\n\n\n\n\nLe d\u00e9codage est r\u00e9alis\u00e9 directement dans la structure ou le pointeur r\u00e9sultat.\nSi le champ est optionnel et de type Attribut abstrait, Attribut non pointeur, ou \u00e9num\u00e9r\u00e9 :\n\n\n    self-\nfield\n_is_present = presence_flag;\n\n\n\n\nFin du d\u00e9codage :\n\n\n  return rc;\n}\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la structure composite et les structures contenues dans les champs (composites, listes, cha\u00eenes de caract\u00e8res, Blobs).\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_t **self_p) {\n\n\n\n\nPour chaque champ, y compris les champs h\u00e9rit\u00e9s :\n\n\n\n\nEn cas de polymorphisme d'Attribut, si le champ est optionnel (canBeNull = 'true') :\n\n\n\n\n  if ((*self_p)-\nfield\n_is_present)\n\n\n\n\n\n\nEn cas de polymorphisme d'Attribut, destruction du champ optionnel:\n\n\n\n\n  mal_attribute_destroy(\n(*self_p)-\nfield\n,\n    (*self_p)-\nfield\n_attribute_tag);\n\n\n\n\n\n\nSi le champ est de type Attribut pointeur :\n\n\n\n\n  if ((*self_p)-\nfield\n!= NULL)\n    mal_\nattribute\n_destroy(\n(*self_p)-\nfield\n);\n\n\n\n\n\n\nSi le champ est de type Composite :\n\n\n\n\n  if ((*self_p)-\nfield\n!= NULL)\n    \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n(*self_p)-\nfield\n);\n\n\n\n\n\n\nSi le champ est de type liste :\n\n\n\n\n  if ((*self_p)-\nfield\n!= NULL)\n    \narea\n_[\nservice\n_]\ntype\n_list_destroy(\n(*self_p)-\nfield\n);\n\n\n\n\nLib\u00e9ration de la m\u00e9moire et effacement du pointeur :\n\n\n  free(*self_p);\n  (*self_p) = NULL;\n}\n\n\n\n\nListes de Composite\n\n\nFichier include (.h)\n\n\n#ifndef __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_LIST_H_INCLUDED__\n#define __\nAREA\n_[\nSERVICE\n_]\nCOMPOSITE\n_LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nConstructeur :\n\n\narea\n_[\nservice\n_]\ncomposite\n_list_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_list_new(unsigned int element_count);\n\n\n\n\nGetters :\n\n\nunsigned int \narea\n_[\nservice\n_]\ncomposite\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\n\narea\n_[\nservice\n_]\ncomposite\n_t **mal_list_get_content(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self);\n\n\n\n\nPour chaque format d'encodage :\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_add_encoding_length_\nformat\n(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  \nformat\n_encoder_t *encoder, unsigned int *encoding_length);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_encode_\nformat\n(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  \nformat\n_encoder_t *encoder, char *bytes, unsigned int *offset);\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_decode_\nformat\n(\n  \narea\n_[\nservice\n_]\ncomposite\n_t *self,\n  \nformat\n_decoder_t *decoder, char *bytes, unsigned int *offset);\n\n\n\n\nDestructeur :\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t **self_p);\n\n\n\n\nFonction de test :\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_test(bool verbose);\n\n\n\n\nFin du fichier :\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nFichier source (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nConstructeur\n\n\nD\u00e9finition de la structure :\n\n\nstruct _\narea\n_[\nservice\n_]\ncomposite\n_list_t {\n  unsigned int element_count;\n  \narea\n_[\nservice\n_]\ncomposite\n_t **content;\n};\n\n\n\n\nConstructeur :\n\n\narea\n_[\nservice\n_]\ncomposite\n_list_t\n  *\narea\n_[\nservice\n_]\ncomposite\n_list_new(unsigned int element_count) {\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self =\n    (\narea\n_[\nservice\n_]\ncomposite\n_list_t *) calloc(1,\n      sizeof(\narea\n_[\nservice\n_]\ncomposite\n_list_t));\n  if (!self) return NULL;\n  self-\nelement_count = element_count;\n  self-\ncontent = (\narea\n_[\nservice\n_]\ncomposite\n_t **) calloc(\n      element_count, sizeof(\narea\n_[\nservice\n_]\ncomposite\n_t *));\n  return self;\n}\n\n\n\n\nGetters\n\n\nunsigned int \narea\n_[\nservice\n_]\ncomposite\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self) {\n  return self-\nelement_count;\n}\n\n\narea\n_[\nservice\n_]\ncomposite\n_t **\n  \narea\n_[\nservice\n_]\ncomposite\n_list_get_content(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t *self) {\n  return self-\ncontent;\n}\n\n\n\n\nCalcul de la taille d'encodage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_add_encoding_length_malbinary(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  malbinary_encoder_t *encoder, unsigned int *encoding_length) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n\n\n\n\nEncodage de la taille de la liste :\n\n\n  malbinary_encoder_add_list_size_encoding_length(encoder, list_size,\n      encoding_length);\n\n\n\n\nTous les \u00e9l\u00e9ments de la liste peuvent \u00eatre nuls. Un champ de pr\u00e9sence doit donc \u00eatre ajout\u00e9 pour chacun d'eux :\n\n\n  (*encoding_length) += list_size;\n\n\n\n\nEncodage des \u00e9l\u00e9ments de la liste :\n\n\n  \narea\n_[\nservice\n_]\ncomposite\n_t **content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    \narea\n_[\nservice\n_]\ncomposite\n_t *element = content[i];\n\n\n\n\nCalcul de la taille d'encodage d'un champ Composite optionnel : voir section 11.1.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nEncodage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_encode_malbinary(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  malbinary_encoder_t *encoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n  malbinary_encoder_encode_list_size(encoder, bytes, offset, list_size);\n  \narea\n_[\nservice\n_]\ncomposite\n_t *content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    \narea\n_[\nservice\n_]\ncomposite\n_t *element = content[i];\n\n\n\n\nEncodage d'un Composite optionnel : voir section 11.2.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nD\u00e9codage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\ncomposite\n_list_decode_malbinary(\n  \narea\n_[\nservice\n_]\ncomposite\n_list_t *self,\n  malbinary_decoder_t *decoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size;\n  malbinary_decoder_decode_list_size(decoder, bytes, offset, \nlist_size);\n  \narea\n_[\nservice\n_]\ncomposite\n_t **list_content =\n    (\narea\n_[\nservice\n_]\ncomposite\n_t **) calloc(\n      sizeof(\narea\n_[\nservice\n_]\ncomposite\n_t *) * list_size);\n  for (int i = 0; i \n list_size; i++) {\n    \narea\n_[\nservice\n_]\ncomposite\n_t *element;\n\n\n\n\nD\u00e9codage d'un Composite optionnel : voir section 11.3.1.\n\n\n    list_content[i] = element;\n  }\n  self-\nelement_count = list_size;\n  self-\ncontent = list_content;\n  return rc;\n}\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste, son contenu et les \u00e9l\u00e9ments de la liste.\n\n\nvoid \narea\n_[\nservice\n_]\ncomposite\n_list_destroy(\n    \narea\n_[\nservice\n_]\ncomposite\n_list_t **self_p) {\n  if ((*self_p)-\nelement_count \n 0) {\n    for (int i = 0; i \n (*self_p)-\nelement_count; i++) {\n      if ((*self_p)-\ncontent[i] != NULL)\n        \narea\n_[\nservice\n_]\ncomposite\n_destroy(\n(*self_p)-\ncontent[i]);\n    }\n    free((*self_p)-\ncontent);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}\n\n\n\n\nListes d'\u00e9num\u00e9r\u00e9\n\n\nFichier include (.h)\n\n\n#ifndef __\nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_LIST_H_INCLUDED__\n#define __\nAREA\n_[\nSERVICE\n_]\nENUMERATION\n_LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\n\n\n\nConstructeur :\n\n\narea\n_[\nservice\n_]\nenumeration\n_list_t\n  *\narea\n_[\nservice\n_]\nenumeration\n_list_new(\n    unsigned int element_count);\n\n\n\n\nGetters :\n\n\nunsigned int \narea\n_[\nservice\n_]\nenumeration\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self);\n\nbool *\narea\n_[\nservice\n_]\nenumeration\n_list_get_presence_flags(\n    \narea\n_[\nservice\n_]\nenumeration\n_list_t *self);\n\n\narea\n_[\nservice\n_]\nenumeration\n_t *mal_list_get_content(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self);\n\n\n\n\nPour chaque format d'encodage :\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_add_encoding_length_\nformat\n(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  \nformat\n_encoder_t *encoder, unsigned int *encoding_length);\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_encode_\nformat\n(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  \nformat\n_encoder_t *encoder, char *bytes, unsigned int *offset);\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_decode_\nformat\n(\n  \narea\n_[\nservice\n_]\nenumeration\n_t *self,\n  \nformat\n_decoder_t *decoder, char *bytes, unsigned int *offset);\n\n\n\n\nDestructeur :\n\n\nvoid \narea\n_[\nservice\n_]\nenumeration\n_list_destroy(\n    \narea\n_[\nservice\n_]\nenumeration\n_list_t **self_p);\nFonction de test :\nvoid \narea\n_[\nservice\n_]\nenumeration\n_list_test(bool verbose);\n\n\n\n\nFin du fichier :\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n\n\nFichier source (.c)\n\n\n#include \narea\n.h\n\n\n\n\n\nConstructeur\n\n\nD\u00e9claration de la structure :\n\n\nstruct _\narea\n_[\nservice\n_]\nenumeration\n_list_t {\n  unsigned int element_count;\n  bool *presence_flags;\n  \narea\n_[\nservice\n_]\nenumeration\n_t *content;\n};\n\n\n\n\nConstructeur :\n\n\narea\n_[\nservice\n_]\nenumeration\n_list_t\n  *\narea\n_[\nservice\n_]\nenumeration\n_list_new(\n    unsigned int element_count) {\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self =\n    (\narea\n_[\nservice\n_]\nenumeration\n_list_t *) calloc(1,\n      sizeof(\narea\n_[\nservice\n_]\nenumeration\n_list_t));\n  if (!self) return NULL;\n  self-\nelement_count = element_count;\n  if (element_count == 0) return self;\n  self-\npresence_flags = (bool *) calloc(element_count, sizeof(bool));\n  if (!self-\npresence_flags) {\n    free(self);\n    return NULL;\n  }\n  self-\ncontent = (\narea\n_[\nservice\n_]\nenumeration\n_t *) calloc(\n      element_count, sizeof(\narea\n_[\nservice\n_]\nenumeration\n_t));\n  if (!self-\ncontent) {\n    free(self-\npresence_flags);\n    free(self);\n    return NULL;\n  }\n  return self;\n}\n\n\n\n\nGetters\n\n\nunsigned int \narea\n_[\nservice\n_]\nenumeration\n_list_get_element_count(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self) {\n  return self-\nelement_count;\n}\n\nbool *\narea\n_[\nservice\n_]\nenumeration\n_list_get_presence_flags(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self) {\n  return self-\npresence_flags;\n}\n\n\narea\n_[\nservice\n_]\nenumeration\n_t\n  *\narea\n_[\nservice\n_]\nenumeration\n_list_get_content(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self) {\n  return self-\ncontent;\n}\n\n\n\n\nCalcul de la taille d'encodage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_add_encoding_length_malbinary(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  malbinary_encoder_t *encoder, unsigned int *encoding_length) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n\n\n\n\nEncodage de la taille de la liste :\n\n\n  malbinary_encoder_add_list_size_encoding_length(encoder, list_size,\n      encoding_length);\n\n\n\n\nTous les \u00e9l\u00e9ments de la liste peuvent \u00eatre nuls. Un champ de pr\u00e9sence doit donc \u00eatre ajout\u00e9 pour chacun d'eux :\n\n\n  (*encoding_length) += list_size * MALBINARY_PRESENCE_FLAG_SIZE;\n\n\n\n\nEncodage des \u00e9l\u00e9ments de la liste :\n\n\n  bool *presence_flags = self-\npresence_flags;\n  \narea\n_[\nservice\n_]\nenumeration\n_t *content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    bool presence_flag = presence_flags[i];\n    \narea\n_[\nservice\n_]\nenumeration\n_t element = content[i];\n\n\n\n\nCalcul de la taille d'encodage d'un champ \u00e9num\u00e9r\u00e9 optionnel : voir section 11.1.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nEncodage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_encode_malbinary(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  malbinary_encoder_t *encoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size = self-\nelement_count;\n  malbinary_encoder_encode_list_size(encoder, bytes, offset, list_size);\n  \narea\n_[\nservice\n_]\nenumeration\n_t *content = self-\ncontent;\n  for (int i = 0; i \n list_size; i++) {\n    bool presence_flag = presence_flags[i];\n    \narea\n_[\nservice\n_]\nenumeration\n_t *element = content[i];\n\n\n\n\nEncodage d'un \u00e9num\u00e9r\u00e9 optionnel : voir section 11.2.1.\n\n\n  }\n  return rc;\n}\n\n\n\n\nD\u00e9codage (\nmalbinary\n)\n\n\nint \narea\n_[\nservice\n_]\nenumeration\n_list_decode_malbinary(\n  \narea\n_[\nservice\n_]\nenumeration\n_list_t *self,\n  malbinary_decoder_t *decoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size;\n  malbinary_decoder_decode_list_size(decoder, bytes, offset, \nlist_size);\n  bool *presence_flags = (bool *) malloc(sizeof(bool) * list_size);\n  \narea\n_[\nservice\n_]\nenumeration\n_t *list_content =\n    \narea\n_[\nservice\n_]\nenumeration\n_t *list_content =\n    (\narea\n_[\nservice\n_]\nenumeration\n_t *) malloc(\n      sizeof(\narea\n_[\nservice\n_]\nenumeration\n_t) * list_size);\n  for (int i = 0; i \n list_size; i++) {\n    bool presence_flag;\n    int element;\n\n\n\n\nD\u00e9codage d'un \u00e9num\u00e9r\u00e9 optionnel : voir section 11.3.1.\n\n\n    presence_flags[i] = presence_flag;\n    list_content[i] = (\narea\n_[\nservice\n_]\nenumeration\n_t) element;\n  }\n  self-\nelement_count = list_size;\n  self-\n presence_flags = presence_flags;\n  self-\ncontent = list_content;\n  return rc;\n}\n\n\n\n\nDestructeur\n\n\nD\u00e9truit la liste et son contenu (tableau).\n\n\nvoid \narea\n_[\nservice\n_]\nenum\n_list_destroy(\n    \narea\n_[\nservice\n_]\nenum\n_list_t **self_p) {\n  if ((*self_p)-\nelement_count \n 0) {\n    free((*self_p)-\npresence_flags);\n    free((*self_p)-\ncontent);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Stubs de service"
        }, 
        {
            "location": "/stub_generator/#generation-du-code-des-stubs", 
            "text": "Le code g\u00e9n\u00e9r\u00e9 est produit pour une mission donn\u00e9e utilisant un ensemble d'Areas de service.  L'instruction 'calloc' (initialise \u00e0 '0' les octets allou\u00e9s) est utilis\u00e9e pour allouer des structures ou des tableaux de pointeurs afin d'\u00e9viter, en cas d'initialisation incompl\u00e8te, que le destructeur ne lib\u00e8re de la m\u00e9moire au travers de faux pointeurs.", 
            "title": "G\u00e9n\u00e9ration du code des stubs"
        }, 
        {
            "location": "/stub_generator/#area", 
            "text": "Un nouveau projet de type 'zproject' est cr\u00e9\u00e9 pour chaque Area. Il porte le nom de l'Area en carcat\u00e8res minuscules :  area", 
            "title": "Area"
        }, 
        {
            "location": "/stub_generator/#fichier-include-h", 
            "text": "Un fichier  area .h  est d\u00e9fini pour chaque area.", 
            "title": "Fichier include (.h)"
        }, 
        {
            "location": "/stub_generator/#entete", 
            "text": "#ifndef __ AREA _H_INCLUDED__\n#define __ AREA _H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif  D\u00e9claration de la d\u00e9pendance avec l'Area MAL :  #include  mal.h   Pour chaque Area requise :  #include  required area .h", 
            "title": "Ent\u00eate"
        }, 
        {
            "location": "/stub_generator/#constantes", 
            "text": "D\u00e9finition des constantes suivantes :  #define  AREA _AREA_NUMBER  area number \n#define  AREA _AREA_VERSION  version   Pour chaque service :  #define  AREA _ SERVICE _SERVICE_NUMBER  service number   Pour chaque op\u00e9ration de service :  #define  AREA _ SERVICE _ OPERATION _OPERATION_NUMBER  operation number   Pour chaque erreur lev\u00e9e par une op\u00e9ration :  #define  AREA _ SERVICE _ OPERATION _ ERROR _ERROR_NUMBER  error number", 
            "title": "Constantes"
        }, 
        {
            "location": "/stub_generator/#types", 
            "text": "Pour chaque type Enumeration :  typedef enum {\n   AREA _[ SERVICE _] ENUMERATION _ ENUMERATED NAME ,\n}  area _[ service _] enumeration _t;  Pour chaque Composite :  typedef struct _ area _[ service _] composite _t\n   area _[ service _] composite _t;  Pour chaque type de donn\u00e9e d\u00e9fini pr\u00e9c\u00e9demment (Enumeration, Composite) :  typedef struct _ area _[ service _] type _list_t\n   area _[ service _] type _list_t;  Pour chaque type de donn\u00e9e, calcul de l'identifiant entier 'short form' (typ\u00e9 'long') comme d\u00e9fini en section 5.2.3 du livre MAL/SPP :  #define  AREA _[ SERVICE _] TYPE _SHORT_FORM  short form \n#define  AREA _[ SERVICE _] TYPE _LIST_SHORT_FORM  short form", 
            "title": "Types"
        }, 
        {
            "location": "/stub_generator/#operations", 
            "text": "Pour chaque op\u00e9ration de service, except\u00e9 si le pattern d'interaction est Publish/Subscribe, les fonctions suivantes sont d\u00e9finies :   une fonction d'envoi de message pour l'initiation d'une interaction (premi\u00e8re \u00e9tape) ;  une fonction d'envoi de message pour chaque \u00e9tape de r\u00e9sultat d'une interaction (seconde \u00e9tape et suivantes).   Initiation d'interaction (except\u00e9 Publish/Subscribe)  int  area _ service _ operation _ first stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri);  R\u00e9sultat d'interaction (except\u00e9 Publish/Subscribe)  int  area _ service _ operation _ result stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message, mal_message_t *result_message,\n  bool is_error_message);  Pour chaque op\u00e9ration de service dont le pattern d'interaction est Publish/Subscribe, des fonctions sont d\u00e9finies pour les \u00e9tapes suivantes de l'interaction : register, publishRegister, publish, deregister, publishDeregister.  Abonnement (Publish/Subscribe)  int  area _ service _ operation _register(\n  mal_ctx_t *mal_ctx, mal_endpoint_t *endpoint, mal_message_t *message,\n  mal_uri_t *broker_uri);  D\u00e9claration de publication (Publish/Subscribe)  int  area _ service _ operation _publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);  Publication (Publish/Subscribe)  int  area _ service _ operation _publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid);  D\u00e9sabonnement (Publish/Subscribe)  int  area _ service _ operation _deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);  Arr\u00eat de publication (Publish/Subscribe)  int  area _ service _ operation _publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri);", 
            "title": "Op\u00e9rations"
        }, 
        {
            "location": "/stub_generator/#fonctions-dencodage", 
            "text": "Pour chaque message d'\u00e9tape d'interaction de chaque op\u00e9ration de service, les fonctions suivantes sont d\u00e9finies :   pour chaque \u00e9l\u00e9ment de corps de message (identifi\u00e9 par son index), et pour chaque type en cas de polymorphisme (voir 9.4.1) :  une fonction de calcul de taille d'encodage  une fonction d'encodage  pour chaque \u00e9l\u00e9ment de corps de message (identifi\u00e9 par son index et son type d\u00e9clar\u00e9) :  une fonction de d\u00e9codage     Les op\u00e9rations dont le pattern d'interaction est Publish/Subscribe sont trait\u00e9es de mani\u00e8re particuli\u00e8re. Les trois fonctions d'encodage ne sont g\u00e9n\u00e9r\u00e9es que pour une seule \u00e9tape d'interaction fictive, l'\u00e9tape update, qui correspond aux deux \u00e9tapes publish et notify, et dont les types de param\u00e8tres sont d\u00e9finis dans la sp\u00e9cification de l'op\u00e9ration sous la forme d'un message publishNotify. De plus les param\u00e8tres effectivement utilis\u00e9s dans les fonctions d'encodage sont des listes du type d\u00e9clar\u00e9 dans la sp\u00e9cification.  Les fonctions d'encodage li\u00e9es aux messages d'erreur suivent le sch\u00e9ma g\u00e9n\u00e9ral avec les particularit\u00e9s suivantes :   le nom des fonctions ne comprend pas d'index,  le nom des fonctions d'encodage comprend syst\u00e9matiquement le suffixe de type  _qftype ,  la fonction de d\u00e9codage suit le mod\u00e8le de d\u00e9codage avec polymorphisme d'Element.", 
            "title": "Fonctions d'encodage"
        }, 
        {
            "location": "/stub_generator/#calcul-de-taille-dencodage", 
            "text": "En cas de polymorphisme d'Attribut :  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length);  Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n   qftype _t element, unsigned int *encoding_length);   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder,  qftype _[list_]t *element,\n  unsigned int *encoding_length);  Si l'op\u00e9ration est Pub/Sub, la fonction est g\u00e9n\u00e9r\u00e9e pour le type liste du type d\u00e9clar\u00e9 dans la sp\u00e9cification :  int  qfop _update_add_encoding_length[_ index ][_ qftype _list](\n    int encoding_format_code, void * encoder,\n     qftype _list_t *element,\n    unsigned int *encoding_length);", 
            "title": "Calcul de taille d'encodage"
        }, 
        {
            "location": "/stub_generator/#encodage", 
            "text": "En cas de polymorphisme d'Attribut :  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element);  Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag,  qftype _t element);   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder,  qftype _[list_]t *element);  Si l'op\u00e9ration est Pub/Sub, la fonction est g\u00e9n\u00e9r\u00e9e pour le type liste du type d\u00e9clar\u00e9 dans la sp\u00e9cification :  int  qfop _update_encode[_ index ][_ qftype _list](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder,  qftype _list_t *element);", 
            "title": "Encodage"
        }, 
        {
            "location": "/stub_generator/#decodage", 
            "text": "En cas de polymorphisme d'Attribut :  int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);  En cas de polymorphisme d'\u00e9l\u00e9ment, y compris si l'op\u00e9ration est PubSub (stage = update), et/ou pour un message d'erreur :  int  qfop _ stage|error _decode[_ index ](\n  int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder);  Si le type de l'\u00e9l\u00e9ment est connu :   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,  qftype _t *element_res);   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder,  qftype _[list_]t **element_res);  Si l'op\u00e9ration est Pub/Sub, la fonction est g\u00e9n\u00e9r\u00e9e pour le type liste du type d\u00e9clar\u00e9 dans la sp\u00e9cification, except\u00e9 en cas de polymorphisme o\u00f9 le cas standard de polymorphisme d'\u00e9l\u00e9ment est repris.  int  qfop _update_decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder,  qftype _list_t **element_res);", 
            "title": "D\u00e9codage"
        }, 
        {
            "location": "/stub_generator/#fin-du-fichier", 
            "text": "Une fonction de test :  void  area _test(bool verbose);  Pour chaque structure Composite :  #include  area _[ service _] composite .h   Pour chaque liste de Composite :  #include  area _[ service _] composite _list.h   Pour chaque liste d'\u00e9num\u00e9r\u00e9:  #include  area _[ service _] enumeration _list.h   Fin du ficher :  #ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "Fin du fichier"
        }, 
        {
            "location": "/stub_generator/#fichier-source-c", 
            "text": "#include  area .h   Pour chaque \u00e9num\u00e9ration :  int  AREA _[ SERVICE _] ENUMERATION _NUMERIC_VALUES[] = {\n   numeric value ,\n}", 
            "title": "Fichier source (.c)"
        }, 
        {
            "location": "/stub_generator/#initiation-dinteraction-excepte-publishsubscribe", 
            "text": "int  area _ service _ operation _ first stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_uri_t *provider_uri) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration appel\u00e9e :    mal_message_init(init_message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_ IP ,\n    MAL_IP_STAGE_ STAGE );  Envoi du message :    rc = mal_endpoint_init_operation(\n    endpoint, init_message, provider_uri, true);\n  return rc;\n}", 
            "title": "Initiation d'interaction (except\u00e9 Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#resultat-dinteraction-excepte-publishsubscribe", 
            "text": "int  area _ service _ operation _ result stage (\n  mal_endpoint_t *endpoint,\n  mal_message_t *init_message,\n  mal_message_t *result_message,\n  bool is_error_message) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration :    mal_message_init(result_message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_ IP ,\n    MAL_IP_STAGE_ STAGE );  Envoi du message :    rc = mal_endpoint_return_operation(\n    endpoint, init_message, result_message, is_error_message);\n  return rc;\n}", 
            "title": "R\u00e9sultat d'interaction (except\u00e9 Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#abonnement-publishsubscribe", 
            "text": "int  area _ service _ operation _register(\n  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration :    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_REGISTER);  Envoi du message :    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "Abonnement (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#declaration-de-publication-publishsubscribe", 
            "text": "int  area _ service _ operation _publish_register(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration :    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER);  Envoi du message :    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "D\u00e9claration de publication (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#publication-publishsubscribe", 
            "text": "int  area _ service _ operation _publish(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri,\n  long initial_publish_register_tid) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration :    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH);  Affectation du  Transaction Id  :    mal_message_set_transaction_id(message, initial_publish_register_tid);  Envoi du message :    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, false);\n  return rc;\n}", 
            "title": "Publication (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#desabonnement-publishsubscribe", 
            "text": "int  area _ service _ operation _deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration :    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_DEREGISTER);  Envoi du message :    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "D\u00e9sabonnement (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#arret-de-publication-publishsubscribe", 
            "text": "int  area _ service _ operation _publish_deregister(\n  mal_endpoint_t *endpoint,\n  mal_message_t *message,\n  mal_uri_t *broker_uri) {\n  int rc = 0;  Affectation des champs li\u00e9s \u00e0 l'op\u00e9ration :    mal_message_init(message,  AREA _AREA_NUMBER,\n     AREA _AREA_VERSION,  AREA _ SERVICE _SERVICE_NUMBER,\n     AREA _ SERVICE _ OPERATION _OPERATION_NUMBER,\n    MAL_INTERACTIONTYPE_PUBSUB,\n    MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER);  Envoi du message :    rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);\n  return rc;\n}", 
            "title": "Arr\u00eat de publication (Publish/Subscribe)"
        }, 
        {
            "location": "/stub_generator/#calcul-de-taille-dencodage_1", 
            "text": "En cas de polymorphisme d'Attribut :  int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n  unsigned char attribute_tag, union mal_attribute_t element,\n  unsigned int *encoding_length) {  Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur, ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder, bool presence_flag,\n   qftype _t element, unsigned int *encoding_length) {   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :   int  qfop _ stage|error _add_encoding_length[_ index ][_ qftype ](\n  int encoding_format_code, void *encoder,  qftype _[list_]t *element,\n  unsigned int *encoding_length) {\n```c\n\nInitialisation du code d'erreur :\n\n```c\n  int rc = 0;  Test du type de l'encodage :    switch (encoding_format_code) {  Pour chaque format disponible :    case  FORMAT _FORMAT_CODE: {\n     format _encoder_t * format _encoder =\n      ( format _encoder_t *) encoder;  Calcul de la taille d'encodage d'un champ optionnel :\n  - Pour le format  malbinary , voir section 11.1.1.      break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}", 
            "title": "Calcul de taille d'encodage"
        }, 
        {
            "location": "/stub_generator/#encodage_1", 
            "text": "En cas de polymorphisme d'Attribut :  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag, unsigned char attribute_tag,\n  union mal_attribute_t element) {  Sinon, le type de l'\u00e9l\u00e9ment est connu (m\u00eame en cas de polymorphisme) :\n  - Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :  int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder, bool presence_flag,  qftype _t element) {   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite, ou une liste :   int  qfop _ stage|error _encode[_ index ][_ qftype ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *encoder,  qftype _[list_]t *element) {\n  presence_flag = (element != NULL);  Initialisation du code d'erreur :    int rc = 0;  Test du type de l'encodage :    switch (encoding_format_code) {  Pour chaque format disponible :    case  FORMAT _FORMAT_CODE: {\n     format _encoder_t * format _encoder =\n      ( format _encoder_t *) encoder;  Encodage d'un champ optionnel :   Pour le format  malbinary , voir section 11.2.2.       break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}", 
            "title": "Encodage"
        }, 
        {
            "location": "/stub_generator/#decodage_1", 
            "text": "En cas de polymorphisme d'Attribut :  int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder, bool *presence_flag_res,\n  unsigned char *attribute_tag_res, union mal_attribute_t *element_res) {  En cas de polymorphisme d'\u00e9l\u00e9ment et/ou pour un message d'erreur :  int  qfop _ stage|error _decode[_ index ](\n  int encoding_format_code,\n  char *bytes, unsigned int *offset, void *decoder,\n  mal_element_holder_t *element_holder) {  Si le type de l'\u00e9l\u00e9ment est connu :   Si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes , unsigned int *offset,\n  void *decoder, bool *presence_flag_res,  qftype _t *element_res) {   Si l\u2019\u00e9l\u00e9ment est un Attribut pointeur, un Composite ou une liste :   int  qfop _ stage _decode[_ index ](\n  int encoding_format_code, char *bytes, unsigned int *offset,\n  void *decoder,  qftype _[list_]t **element_res) {  Initialisation du code d'erreur :    int rc = 0;  Test du type de l'encodage :    switch (encoding_format_code) {  Pour chaque format disponible :    case  FORMAT _FORMAT_CODE: {\n     format _decoder_t * format _decoder =\n      ( format _encoder_t *) decoder;\n      bool presence_flag;  D\u00e9codage d'un champ optionnel :   Pour le format  malbinary , voir section 11.3.1.  Le d\u00e9codage est r\u00e9alis\u00e9 directement dans la structure ou le pointeur r\u00e9sultat.  En cas de polymorphisme d'Attribut ou si l\u2019\u00e9l\u00e9ment est un Attribut non pointeur ou un \u00e9num\u00e9r\u00e9 :  (*presence_flag_res) = presence_flag;  En cas de polymorphisme d'\u00e9l\u00e9ment :  mal_element_holder_set_presence_flag(element_holder, presence_flag);     Fin du d\u00e9codage.      break;\n  }\n  default:\n    rc = -1;\n  }\n  return rc;\n}", 
            "title": "D\u00e9codage"
        }, 
        {
            "location": "/stub_generator/#composite", 
            "text": "", 
            "title": "Composite"
        }, 
        {
            "location": "/stub_generator/#fichier-include-h_1", 
            "text": "#ifndef __ AREA _[ SERVICE _] COMPOSITE _H_INCLUDED__\n#define __ AREA _[ SERVICE _] COMPOSITE _H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif  Constructeur sans param\u00e8tre :  area _[ service _] composite _t\n  * area _[ service _] composite _new(void);  Pour chaque format d'encodage :  int  area _[ service _] composite _add_encoding_length_ format (\n     area _[ service _] composite _t *self,  format _encoder_t *encoder,\n    unsigned int *encoding_length);\n\nint  area _[ service _] composite _encode_ format (\n     area _[ service _] composite _t *self,  format _encoder_t *encoder,\n    char *bytes, unsigned int *offset);\n\nint  area _[ service _] composite _decode_ format (\n     area _[ service _] composite _t *self,  format _decoder_t *decoder,\n    char *bytes, unsigned int *offset);  Pour chaque champ du composite (y compris les champs h\u00e9rit\u00e9s) :  field type   area _[ service _] composite _get_ field (\n     area _[ service _] composite _t *self);\n\nvoid  area _[ service _] composite _set_ field (\n     area _[ service _] composite _t *self,  field type   field );  Si le champ n'est pas un pointeur (valeur NULL interdite) :  bool  area _[ service _] composite _ field _is_present(\n     area _[ service _] composite _t *self);\n\nvoid  area _[ service _] composite _ field _set_present(\n     area _[ service _] composite _t *self, bool is_present);  En cas de polymorphisme d'Attribut :  unsigned char  area _[ service _] composite _ field _get_attribute_tag(\n     area _[ service _] composite _t *self);\n\nvoid  area _[ service _] composite _ field _set_attribute_tag(\n     area _[ service _] composite _t *self, unsigned char attribute_tag);  Destructeur :  void  area _[ service _] composite _destroy(\n     area _[ service _] composite _t **self_p);  Fonction de test :  void  area _[ service _] composite _test(bool verbose);  Fin du fichier :  #ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "Fichier include (.h)"
        }, 
        {
            "location": "/stub_generator/#fichier-source-c_1", 
            "text": "#include  area .h", 
            "title": "Fichier source (.c)"
        }, 
        {
            "location": "/stub_generator/#definition-de-la-structure", 
            "text": "struct _ area _[ service _] composite _t {  Pour chaque champ (y compris les champs h\u00e9rit\u00e9s) :   En cas de polymorphisme d'Attribut :  Si le champ est optionnel (canBeNull = 'true') :  bool  field _is_present ;  D\u00e9claration du champ :     unsigned char  field _attribute_tag;\n  union mal_attribute_t  field ;   Si le champ est de type Attribut non pointeur, ou \u00e9num\u00e9r\u00e9 :  Si le champ est optionnel (canBeNull = 'true') :  bool  field _is_present;  D\u00e9claration du champ :  field type   field ;  Sinon :  field type  * field ; \nFin de la d\u00e9finition de la structure :  };", 
            "title": "D\u00e9finition de la structure"
        }, 
        {
            "location": "/stub_generator/#constructeur", 
            "text": "area _[ service _] composite _t\n  * area _[ service _] composite _new(void) {\n   area _[ service _] composite _t *self =\n      ( area _[ service _] composite _t *) calloc(\n          1, sizeof( area _[ service _] composite _t));\n  if (!self)\n    return NULL;\n  return self;\n}", 
            "title": "Constructeur"
        }, 
        {
            "location": "/stub_generator/#getters-et-setters", 
            "text": "Pour chaque champ du composite (y compris les champs h\u00e9rit\u00e9s) :  field type   area _[ service _] composite _get_ field (\n     area _[ service _] composite _t *self) {\n  return self- field ;\n}  La fonction  setter  n'affecte que la valeur du champ. Le flag de pr\u00e9sence ne doit pas \u00eatre modifi\u00e9.  void  area _[ service _] composite _set_ field (\n     area _[ service _] composite _t *self,  field type   field ) {\n  self- field  =  field ;\n}  Si le champ est optionnel (canBeNull = 'true') et si le champ n'est pas un pointeur :  bool  area _[ service _] composite _ field _is_present(\n     area _[ service _] composite _t *self) {\n  return self- field _is_present;\n}\n\nvoid  area _[ service _] composite _ field _set_present(\n     area _[ service _] composite _t *self, bool is_present) {\n  self- field _is_present = is_present;\n}  En cas de polymorphisme d'Attribut :  unsigned char  area _[ service _] composite _ field _get_attribute_tag(\n     area _[ service _] composite _t *self) {\n  return self- field _attribute_tag;\n}\n\nvoid  area _[ service _] composite _ field _set_attribute_tag(\n   area _[ service _] composite _t *self,\n  unsigned char attribute_tag) {\n  self- field _attribute_tag = attribute_tag;\n}", 
            "title": "Getters et setters"
        }, 
        {
            "location": "/stub_generator/#calcul-de-la-taille-encodee-malbinary", 
            "text": "int  area _[ service _] composite _add_encoding_length_malbinary(\n     area _[ service _] composite _t *self,\n    malbinary_encoder_t *malbinary_encoder,\n    unsigned int *encoding_length) {\n  int rc = 0;  Pour chaque champ (les champs h\u00e9rit\u00e9s en premier) :   Si le champ est optionnel, voir section 11.1.1.  Sinon voir section 11.1.2.   Fin de la fonction :\n  return rc;\n}", 
            "title": "Calcul de la taille encod\u00e9e (malbinary)"
        }, 
        {
            "location": "/stub_generator/#encodage-malbinary", 
            "text": "int  area _[ service _] composite _encode_malbinary(\n     area _[ service _] composite _t *self,\n    malbinary_encoder_t *malbinary_encoder,\n    char *bytes, unsigned int *offset) {  S'il existe au moins un champ optionnel :    bool presence_flag;  Pour chaque champ (les champs h\u00e9rit\u00e9s en premier) :   Si le champ est optionnel :  Si le champ est de type Attribut non pointeur, ou \u00e9num\u00e9r\u00e9 :    presence_flag = self- field _is_present;   Sinon :    presence_flag = (self- field  != NULL);   Voir section 11.2.1.  Sinon voir section 11.2.2.   Fin de l'encodage :    return rc;\n}", 
            "title": "Encodage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#decodage-malbinary", 
            "text": "int  area _[ service _] composite _decode_malbinary(\n     area _[ service _] composite _t *self,\n    malbinary_decoder_t *malbinary_decoder,\n    char *bytes, unsigned int *offset) {  S'il existe au moins un champ optionnel :  bool presence_flag;  Pour chaque champ (les champs h\u00e9rit\u00e9s en premier) :   Si le champ est optionnel, voir section 11.3.1.  Sinon voir section 11.3.2.   Le d\u00e9codage est r\u00e9alis\u00e9 directement dans la structure ou le pointeur r\u00e9sultat.\nSi le champ est optionnel et de type Attribut abstrait, Attribut non pointeur, ou \u00e9num\u00e9r\u00e9 :      self- field _is_present = presence_flag;  Fin du d\u00e9codage :    return rc;\n}", 
            "title": "D\u00e9codage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#destructeur", 
            "text": "D\u00e9truit la structure composite et les structures contenues dans les champs (composites, listes, cha\u00eenes de caract\u00e8res, Blobs).  void  area _[ service _] composite _destroy(\n     area _[ service _] composite _t **self_p) {  Pour chaque champ, y compris les champs h\u00e9rit\u00e9s :   En cas de polymorphisme d'Attribut, si le champ est optionnel (canBeNull = 'true') :     if ((*self_p)- field _is_present)   En cas de polymorphisme d'Attribut, destruction du champ optionnel:     mal_attribute_destroy( (*self_p)- field ,\n    (*self_p)- field _attribute_tag);   Si le champ est de type Attribut pointeur :     if ((*self_p)- field != NULL)\n    mal_ attribute _destroy( (*self_p)- field );   Si le champ est de type Composite :     if ((*self_p)- field != NULL)\n     area _[ service _] composite _destroy( (*self_p)- field );   Si le champ est de type liste :     if ((*self_p)- field != NULL)\n     area _[ service _] type _list_destroy( (*self_p)- field );  Lib\u00e9ration de la m\u00e9moire et effacement du pointeur :    free(*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Destructeur"
        }, 
        {
            "location": "/stub_generator/#listes-de-composite", 
            "text": "", 
            "title": "Listes de Composite"
        }, 
        {
            "location": "/stub_generator/#fichier-include-h_2", 
            "text": "#ifndef __ AREA _[ SERVICE _] COMPOSITE _LIST_H_INCLUDED__\n#define __ AREA _[ SERVICE _] COMPOSITE _LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif", 
            "title": "Fichier include (.h)"
        }, 
        {
            "location": "/stub_generator/#constructeur_1", 
            "text": "area _[ service _] composite _list_t\n  * area _[ service _] composite _list_new(unsigned int element_count);", 
            "title": "Constructeur :"
        }, 
        {
            "location": "/stub_generator/#getters", 
            "text": "unsigned int  area _[ service _] composite _list_get_element_count(\n   area _[ service _] composite _list_t *self); area _[ service _] composite _t **mal_list_get_content(\n   area _[ service _] composite _list_t *self);", 
            "title": "Getters :"
        }, 
        {
            "location": "/stub_generator/#pour-chaque-format-dencodage", 
            "text": "int  area _[ service _] composite _list_add_encoding_length_ format (\n   area _[ service _] composite _list_t *self,\n   format _encoder_t *encoder, unsigned int *encoding_length);\n\nint  area _[ service _] composite _list_encode_ format (\n   area _[ service _] composite _list_t *self,\n   format _encoder_t *encoder, char *bytes, unsigned int *offset);\n\nint  area _[ service _] composite _list_decode_ format (\n   area _[ service _] composite _t *self,\n   format _decoder_t *decoder, char *bytes, unsigned int *offset);", 
            "title": "Pour chaque format d'encodage :"
        }, 
        {
            "location": "/stub_generator/#destructeur_1", 
            "text": "void  area _[ service _] composite _list_destroy(\n     area _[ service _] composite _list_t **self_p);", 
            "title": "Destructeur :"
        }, 
        {
            "location": "/stub_generator/#fonction-de-test", 
            "text": "void  area _[ service _] composite _list_test(bool verbose);", 
            "title": "Fonction de test :"
        }, 
        {
            "location": "/stub_generator/#fin-du-fichier_1", 
            "text": "#ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "Fin du fichier :"
        }, 
        {
            "location": "/stub_generator/#fichier-source-c_2", 
            "text": "#include  area .h", 
            "title": "Fichier source (.c)"
        }, 
        {
            "location": "/stub_generator/#constructeur_2", 
            "text": "D\u00e9finition de la structure :  struct _ area _[ service _] composite _list_t {\n  unsigned int element_count;\n   area _[ service _] composite _t **content;\n};  Constructeur :  area _[ service _] composite _list_t\n  * area _[ service _] composite _list_new(unsigned int element_count) {\n   area _[ service _] composite _list_t *self =\n    ( area _[ service _] composite _list_t *) calloc(1,\n      sizeof( area _[ service _] composite _list_t));\n  if (!self) return NULL;\n  self- element_count = element_count;\n  self- content = ( area _[ service _] composite _t **) calloc(\n      element_count, sizeof( area _[ service _] composite _t *));\n  return self;\n}", 
            "title": "Constructeur"
        }, 
        {
            "location": "/stub_generator/#getters_1", 
            "text": "unsigned int  area _[ service _] composite _list_get_element_count(\n   area _[ service _] composite _list_t *self) {\n  return self- element_count;\n} area _[ service _] composite _t **\n   area _[ service _] composite _list_get_content(\n     area _[ service _] composite _list_t *self) {\n  return self- content;\n}", 
            "title": "Getters"
        }, 
        {
            "location": "/stub_generator/#calcul-de-la-taille-dencodage-malbinary", 
            "text": "int  area _[ service _] composite _list_add_encoding_length_malbinary(\n   area _[ service _] composite _list_t *self,\n  malbinary_encoder_t *encoder, unsigned int *encoding_length) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;  Encodage de la taille de la liste :    malbinary_encoder_add_list_size_encoding_length(encoder, list_size,\n      encoding_length);  Tous les \u00e9l\u00e9ments de la liste peuvent \u00eatre nuls. Un champ de pr\u00e9sence doit donc \u00eatre ajout\u00e9 pour chacun d'eux :    (*encoding_length) += list_size;  Encodage des \u00e9l\u00e9ments de la liste :     area _[ service _] composite _t **content = self- content;\n  for (int i = 0; i   list_size; i++) {\n     area _[ service _] composite _t *element = content[i];  Calcul de la taille d'encodage d'un champ Composite optionnel : voir section 11.1.1.    }\n  return rc;\n}", 
            "title": "Calcul de la taille d'encodage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#encodage-malbinary_1", 
            "text": "int  area _[ service _] composite _list_encode_malbinary(\n   area _[ service _] composite _list_t *self,\n  malbinary_encoder_t *encoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;\n  malbinary_encoder_encode_list_size(encoder, bytes, offset, list_size);\n   area _[ service _] composite _t *content = self- content;\n  for (int i = 0; i   list_size; i++) {\n     area _[ service _] composite _t *element = content[i];  Encodage d'un Composite optionnel : voir section 11.2.1.    }\n  return rc;\n}", 
            "title": "Encodage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#decodage-malbinary_1", 
            "text": "int  area _[ service _] composite _list_decode_malbinary(\n   area _[ service _] composite _list_t *self,\n  malbinary_decoder_t *decoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size;\n  malbinary_decoder_decode_list_size(decoder, bytes, offset,  list_size);\n   area _[ service _] composite _t **list_content =\n    ( area _[ service _] composite _t **) calloc(\n      sizeof( area _[ service _] composite _t *) * list_size);\n  for (int i = 0; i   list_size; i++) {\n     area _[ service _] composite _t *element;  D\u00e9codage d'un Composite optionnel : voir section 11.3.1.      list_content[i] = element;\n  }\n  self- element_count = list_size;\n  self- content = list_content;\n  return rc;\n}", 
            "title": "D\u00e9codage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#destructeur_2", 
            "text": "D\u00e9truit la liste, son contenu et les \u00e9l\u00e9ments de la liste.  void  area _[ service _] composite _list_destroy(\n     area _[ service _] composite _list_t **self_p) {\n  if ((*self_p)- element_count   0) {\n    for (int i = 0; i   (*self_p)- element_count; i++) {\n      if ((*self_p)- content[i] != NULL)\n         area _[ service _] composite _destroy( (*self_p)- content[i]);\n    }\n    free((*self_p)- content);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Destructeur"
        }, 
        {
            "location": "/stub_generator/#listes-denumere", 
            "text": "", 
            "title": "Listes d'\u00e9num\u00e9r\u00e9"
        }, 
        {
            "location": "/stub_generator/#fichier-include-h_3", 
            "text": "#ifndef __ AREA _[ SERVICE _] ENUMERATION _LIST_H_INCLUDED__\n#define __ AREA _[ SERVICE _] ENUMERATION _LIST_H_INCLUDED__\n\n#ifdef __cplusplus\nextern  C  {\n#endif", 
            "title": "Fichier include (.h)"
        }, 
        {
            "location": "/stub_generator/#constructeur_3", 
            "text": "area _[ service _] enumeration _list_t\n  * area _[ service _] enumeration _list_new(\n    unsigned int element_count);", 
            "title": "Constructeur :"
        }, 
        {
            "location": "/stub_generator/#getters_2", 
            "text": "unsigned int  area _[ service _] enumeration _list_get_element_count(\n   area _[ service _] enumeration _list_t *self);\n\nbool * area _[ service _] enumeration _list_get_presence_flags(\n     area _[ service _] enumeration _list_t *self); area _[ service _] enumeration _t *mal_list_get_content(\n   area _[ service _] enumeration _list_t *self);", 
            "title": "Getters :"
        }, 
        {
            "location": "/stub_generator/#pour-chaque-format-dencodage_1", 
            "text": "int  area _[ service _] enumeration _list_add_encoding_length_ format (\n   area _[ service _] enumeration _list_t *self,\n   format _encoder_t *encoder, unsigned int *encoding_length);\n\nint  area _[ service _] enumeration _list_encode_ format (\n   area _[ service _] enumeration _list_t *self,\n   format _encoder_t *encoder, char *bytes, unsigned int *offset);\n\nint  area _[ service _] enumeration _list_decode_ format (\n   area _[ service _] enumeration _t *self,\n   format _decoder_t *decoder, char *bytes, unsigned int *offset);", 
            "title": "Pour chaque format d'encodage :"
        }, 
        {
            "location": "/stub_generator/#destructeur_3", 
            "text": "void  area _[ service _] enumeration _list_destroy(\n     area _[ service _] enumeration _list_t **self_p);\nFonction de test :\nvoid  area _[ service _] enumeration _list_test(bool verbose);", 
            "title": "Destructeur :"
        }, 
        {
            "location": "/stub_generator/#fin-du-fichier_2", 
            "text": "#ifdef __cplusplus\n}\n#endif\n\n#endif", 
            "title": "Fin du fichier :"
        }, 
        {
            "location": "/stub_generator/#fichier-source-c_3", 
            "text": "#include  area .h", 
            "title": "Fichier source (.c)"
        }, 
        {
            "location": "/stub_generator/#constructeur_4", 
            "text": "D\u00e9claration de la structure :  struct _ area _[ service _] enumeration _list_t {\n  unsigned int element_count;\n  bool *presence_flags;\n   area _[ service _] enumeration _t *content;\n};  Constructeur :  area _[ service _] enumeration _list_t\n  * area _[ service _] enumeration _list_new(\n    unsigned int element_count) {\n   area _[ service _] enumeration _list_t *self =\n    ( area _[ service _] enumeration _list_t *) calloc(1,\n      sizeof( area _[ service _] enumeration _list_t));\n  if (!self) return NULL;\n  self- element_count = element_count;\n  if (element_count == 0) return self;\n  self- presence_flags = (bool *) calloc(element_count, sizeof(bool));\n  if (!self- presence_flags) {\n    free(self);\n    return NULL;\n  }\n  self- content = ( area _[ service _] enumeration _t *) calloc(\n      element_count, sizeof( area _[ service _] enumeration _t));\n  if (!self- content) {\n    free(self- presence_flags);\n    free(self);\n    return NULL;\n  }\n  return self;\n}", 
            "title": "Constructeur"
        }, 
        {
            "location": "/stub_generator/#getters_3", 
            "text": "unsigned int  area _[ service _] enumeration _list_get_element_count(\n   area _[ service _] enumeration _list_t *self) {\n  return self- element_count;\n}\n\nbool * area _[ service _] enumeration _list_get_presence_flags(\n   area _[ service _] enumeration _list_t *self) {\n  return self- presence_flags;\n} area _[ service _] enumeration _t\n  * area _[ service _] enumeration _list_get_content(\n   area _[ service _] enumeration _list_t *self) {\n  return self- content;\n}", 
            "title": "Getters"
        }, 
        {
            "location": "/stub_generator/#calcul-de-la-taille-dencodage-malbinary_1", 
            "text": "int  area _[ service _] enumeration _list_add_encoding_length_malbinary(\n   area _[ service _] enumeration _list_t *self,\n  malbinary_encoder_t *encoder, unsigned int *encoding_length) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;  Encodage de la taille de la liste :    malbinary_encoder_add_list_size_encoding_length(encoder, list_size,\n      encoding_length);  Tous les \u00e9l\u00e9ments de la liste peuvent \u00eatre nuls. Un champ de pr\u00e9sence doit donc \u00eatre ajout\u00e9 pour chacun d'eux :    (*encoding_length) += list_size * MALBINARY_PRESENCE_FLAG_SIZE;  Encodage des \u00e9l\u00e9ments de la liste :    bool *presence_flags = self- presence_flags;\n   area _[ service _] enumeration _t *content = self- content;\n  for (int i = 0; i   list_size; i++) {\n    bool presence_flag = presence_flags[i];\n     area _[ service _] enumeration _t element = content[i];  Calcul de la taille d'encodage d'un champ \u00e9num\u00e9r\u00e9 optionnel : voir section 11.1.1.    }\n  return rc;\n}", 
            "title": "Calcul de la taille d'encodage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#encodage-malbinary_2", 
            "text": "int  area _[ service _] enumeration _list_encode_malbinary(\n   area _[ service _] enumeration _list_t *self,\n  malbinary_encoder_t *encoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size = self- element_count;\n  malbinary_encoder_encode_list_size(encoder, bytes, offset, list_size);\n   area _[ service _] enumeration _t *content = self- content;\n  for (int i = 0; i   list_size; i++) {\n    bool presence_flag = presence_flags[i];\n     area _[ service _] enumeration _t *element = content[i];  Encodage d'un \u00e9num\u00e9r\u00e9 optionnel : voir section 11.2.1.    }\n  return rc;\n}", 
            "title": "Encodage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#decodage-malbinary_2", 
            "text": "int  area _[ service _] enumeration _list_decode_malbinary(\n   area _[ service _] enumeration _list_t *self,\n  malbinary_decoder_t *decoder, char *bytes, unsigned int *offset) {\n  int rc = 0;\n  unsigned int list_size;\n  malbinary_decoder_decode_list_size(decoder, bytes, offset,  list_size);\n  bool *presence_flags = (bool *) malloc(sizeof(bool) * list_size);\n   area _[ service _] enumeration _t *list_content =\n     area _[ service _] enumeration _t *list_content =\n    ( area _[ service _] enumeration _t *) malloc(\n      sizeof( area _[ service _] enumeration _t) * list_size);\n  for (int i = 0; i   list_size; i++) {\n    bool presence_flag;\n    int element;  D\u00e9codage d'un \u00e9num\u00e9r\u00e9 optionnel : voir section 11.3.1.      presence_flags[i] = presence_flag;\n    list_content[i] = ( area _[ service _] enumeration _t) element;\n  }\n  self- element_count = list_size;\n  self-  presence_flags = presence_flags;\n  self- content = list_content;\n  return rc;\n}", 
            "title": "D\u00e9codage (malbinary)"
        }, 
        {
            "location": "/stub_generator/#destructeur_4", 
            "text": "D\u00e9truit la liste et son contenu (tableau).  void  area _[ service _] enum _list_destroy(\n     area _[ service _] enum _list_t **self_p) {\n  if ((*self_p)- element_count   0) {\n    free((*self_p)- presence_flags);\n    free((*self_p)- content);\n  }\n  free (*self_p);\n  (*self_p) = NULL;\n}", 
            "title": "Destructeur"
        }, 
        {
            "location": "/malbinary_generator/", 
            "text": "G\u00e9n\u00e9ration du code d'encodage 'malbinary'\n\n\nCe code est partag\u00e9 par les fonctions d'encodage g\u00e9n\u00e9r\u00e9es par Area et par Composite (voir sections 10.1.2 et 10.2.2).\n\n\nCalcul de la taille encod\u00e9e\n\n\nLes param\u00e8tres suivants doivent \u00eatre transmis par le code appelant :\n\n\n\n\n : \u00e9l\u00e9ment MAL \u00e0 encoder en fonction de son type\n\n\npresence_flag : champ de pr\u00e9sence si l'\u00e9l\u00e9ment n'est pas de type pointeur\n\n\nattribute_tag : identifiant du type d'Attribut en cas de polymorphisme d'Attribut\n\n\nmalbinary_encoder : configuration de l'encodeur\n\n\nencoding_length : r\u00e9sultat du calcul\n\n\n\n\nChamp optionnel\n\n\nAjout de la taille du champ de pr\u00e9sence :\n\n\n(*encoding_length) += MALBINARY_PRESENCE_FLAG_SIZE;\n\n\n\n\nSi le champ est de type pointeur :\n\n\nif (\nelement\n != NULL) {\n\n\n\n\nSinon, test du champ de pr\u00e9sence :\n\n\nif (presence_flag) {\n\n\n\n\nAjout de la taille de l'\u00e9l\u00e9ment encod\u00e9. Voir section 11.1.2.\n\n\n}\n\n\n\n\nChamp non optionnel\n\n\nPolymorphisme\n\n\nEn cas de polymorphisme d'Attribut :\n\n\n(*encoding_length) += MALBINARY_ATTRIBUTE_TAG_SIZE;\n\n\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment :\n\n\n(*encoding_length) += MALBINARY_SHORT_FORM_SIZE;\n\n\n\n\nValeur de l'\u00e9l\u00e9ment\n\n\nSi le type d\u00e9clar\u00e9 est \nMAL::Attribute\n :\n\n\nrc = malbinary_encoder_add_attribute_encoding_length(malbinary_encoder,\n  \nattribute_tag\n, \nelement\n, encoding_length);\n\n\n\n\nSi le type de l'\u00e9l\u00e9ment est un Attribut :\n\n\nrc = malbinary_encoder_add_\nattribute\n_encoding_length(malbinary_encoder,\n  \nelement\n, encoding_length);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Composite :\n\n\nrc = \narea\n_[\nservice\n_]\ncomposite\n_add_encoding_length_malbinary(\n  \nelement\n, malbinary_encoder, encoding_length);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type liste:\n\n\nrc = \narea\n_[\nservice\n_]\ntype\n_list_add_encoding_length_malbinary(\n  \nelement\n, malbinary_encoder, encoding_length);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Enumeration :\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^8 :\n\n\n\n\n(*encoding_length) += MALBINARY_SMALL_ENUM_SIZE;\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^16 :\n\n\n\n\n(*encoding_length) += MALBINARY_MEDIUM_ENUM_SIZE;\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^32 :\n\n\n\n\n(*encoding_length) += MALBINARY_LARGE_ENUM_SIZE;\n\n\n\n\nTest du code d'erreur :\n\n\nif (rc \n 0) return rc;\n\n\n\n\nEncodage\n\n\nLes param\u00e8tres suivants doivent \u00eatre transmis par le code appelant :\n\n\n\n\nelement\n : \u00e9l\u00e9ment MAL \u00e0 encoder en fonction de son type\n\n\npresence_flag\n : champ de pr\u00e9sence si l'\u00e9l\u00e9ment n'est pas de type pointeur\n\n\nattribute_tag\n : identifiant du type d'Attribut en cas de polymorphisme d'Attribut\n\n\nmalbinary_encoder\n : configuration de l'encodeur MALBinary\n\n\nbytes\n : tableau d'octets o\u00f9 les \u00e9l\u00e9ments MAL sont encod\u00e9s\n\n\noffset\n : index de d\u00e9but de l'encodage\n\n\n\n\nChamp optionnel\n\n\nEncodage du champ de pr\u00e9sence :\n\n\nrc = malbinary_encoder_encode_presence_flag(malbinary_encoder,\n  bytes, offset, \npresence_flag\n);\nif (rc \n 0) return rc;\n\n\n\n\nTest du champ de pr\u00e9sence :\n\n\nif (\npresence_flag\n) {\n\n\n\n\nEncodage de l'\u00e9l\u00e9ment. Voir section 11.2.2.\n\n\n}\n\n\n\n\nChamp non optionnel\n\n\nPolymorphisme\n\n\nEn cas de polymorphisme d'Attribut, encodage du tag d'attribut (voir section 5.2.2 du livre MAL/SPP) :\n\n\nrc = malbinary_encoder_encode_attribute_tag(malbinary_encoder,\n  bytes, offset, \nattribute_tag\n);\n\n\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment :\n\n\nrc = malbinary_encoder_encode_short_form(malbinary_encoder,\n  bytes, offset, \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM);\n\n\n\n\nTest du code d'erreur :\n\n\nif (rc \n 0) return rc;\n\n\n\n\nValeur de l'\u00e9l\u00e9ment\n\n\nSi le type d\u00e9clar\u00e9 est \nMAL::Attribute\n :\n\n\nrc = malbinary_encoder_encode_attribute(malbinary_encoder,\n  bytes, offset, \nattribute_tag\n, \nelement\n);\n\n\n\n\nSi le type de l'\u00e9l\u00e9ment est un Attribut :\n\n\nrc = malbinary_encoder_encode_\nattribute\n(malbinary_encoder,\n  bytes, offset, \nelement\n);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Composite:\n\n\nrc = \narea\n_[\nservice\n_]\ncomposite\n_encode_malbinary(\n  \nelement\n, malbinary_encoder, bytes, offset);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type liste:\n\n\nrc = \narea\n_[\nservice\n_]\ntype\n_list_encode_malbinary(\n  \nelement\n, malbinary_encoder, encoding_length);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Enumeration :\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^8 :\n\n\n\n\nrc = malbinary_encoder_encode_small_enum(malbinary_encoder, bytes,\n  offset, \nelement\n);\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^16 :\n\n\n\n\nrc = malbinary_encoder_encode_medium_enum(malbinary_encoder, bytes,\n  offset, \nelement\n);\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^32 :\n\n\n\n\nrc = malbinary_encoder_encode_large_enum(malbinary_encoder, bytes,\n  offset, \nelement\n);\n\n\n\n\nTest du code d'erreur :\n\n\nif (rc \n 0) return rc;\n\n\n\n\nD\u00e9codage\n\n\nLes param\u00e8tres suivants doivent \u00eatre transmis par le code appelant :\n\n\n\n\npresence_flag\n : champ de pr\u00e9sence d\u00e9cod\u00e9\n\n\nmalbinary_decoder\n : configuration de l'encodeur MALBinary\n\n\nbytes\n : tableau d'octets o\u00f9 les \u00e9l\u00e9ments MAL sont encod\u00e9s\n\n\noffset\n : index de d\u00e9but du d\u00e9codage\n\n\n\n\nChamp optionnel\n\n\nD\u00e9codage du champ de pr\u00e9sence :\n\n\nrc = malbinary_decoder_decode_presence_flag(malbinary_decoder,\n  bytes, offset, \npresence_flag);\nif (rc \n 0) return rc;\nif (presence_flag) {\n\n\n\n\nD\u00e9codage de l'\u00e9l\u00e9ment. Voir section 11.3.2.\n\n\n}\n\n\n\n\nSi le champ est de type pointeur :\n\n\nelse {\n  \nelement\n = NULL;\n\n}\n\n\n\n\nChamp non optionnel\n\n\nPolymorphisme d'Attribut\n\n\nEn cas de polymorphisme d'Attribut, d\u00e9codage du tag d'Attribut :\n\n\nunsigned char attribute_tag;\n\n\n\n\n\nrc = malbinary_decoder_decode_attribute_tag(malbinary_decoder,\n  bytes, offset, \nattribute_tag\n);\n\n\n\n\nTest du code d'erreur :\n\n\nif (rc \n 0) return rc;\n\n\n\n\nD\u00e9codage de l'attribut :\n\n\nrc = malbinary_decoder_decode_attribute(malbinary_decoder,\n    bytes, offset, attribute_tag , \nelement\n);\n\n\n\n\nPolymorphisme d'\u00e9l\u00e9ment\n\n\nEn cas de polymorphisme d'\u00e9l\u00e9ment, d\u00e9codage du \nshort form\n :\n\n\nrc = malbinary_decoder_decode_short_form(malbinary_decoder,\n  bytes, offset, \nelement_holder-\nshort_form);\n\n\n\n\nTest du code d'erreur :\n\n\nif (rc \n 0) return rc;\n\n\n\n\nPour chaque valeur de 'short_form' qui correspond \u00e0 un type conforme au type abstrait :\n\n\nif (element_holder-\nshort_form == \nAREA\n_[\nSERVICE\n_]\nTYPE\n_SHORT_FORM) {\n\n\n\n\nD\u00e9codage d'un \u00e9l\u00e9ment du type sp\u00e9cifi\u00e9. Voir section 11.3.2.3. L'\u00e9l\u00e9ment est d\u00e9cod\u00e9 directement dans la structure :\n\n\n\n\nSi le type de l'\u00e9l\u00e9ment est un Attribut :\n\n\n\n\n      \nelement_holder-\nvalue.\nattribute\n_value\n\n\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Composite :\n\n\n\n\n      \nelement_holder-\nvalue.composite_value\n\n\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type liste :\n\n\n\n\n      \nelement_holder-\nvalue.list_value\n\n\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Enumeration :\n\n\n\n\n      \nelement_holder-\nvalue.enumerated_value\n\n\n\n\n}[ else ]\n\n\n\n\nValeur de l'\u00e9l\u00e9ment\n\n\nSi le type de l'\u00e9l\u00e9ment est un Attribut :\n\n\nrc = malbinary_decoder_decode_\nattribute\n(malbinary_decoder,\n  bytes, offset, \nelement\n);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Composite :\n\n\nelement\n = \narea\n_[\nservice\n_]\ncomposite\n_new();\nif (\nelement\n == NULL) return -1;\nrc = \narea\n_[\nservice\n_]\ncomposite\n_decode_malbinary(\n  \nelement\n, malbinary_decoder, bytes, offset);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type liste :\n\n\nelement\n = \narea\n_[\nservice\n_]\ntype\n_list_new(0);\nif (\nelement\n == NULL) return -1;\nrc = \narea\n_[\nservice\n_]\ntype\n_list_decode_malbinary(\n  \nelement\n, malbinary_decoder, bytes, offset);\n\n\n\n\nSi l'\u00e9l\u00e9ment est de type Enumeration :\n\n\nint enumerated_value;\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure ou \u00e9gale \u00e0 2^8 :\n\n\n\n\nrc = malbinary_decoder_decode_small_enum(malbinary_decoder,\n  bytes, offset, \nenumerated_value);\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure ou \u00e9gale \u00e0 2^16 :\n\n\n\n\nrc = malbinary_decoder_decode_medium_enum(malbinary_decoder,\n  bytes, offset, \nenumerated_value);\n\n\n\n\n\n\nSi la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure ou \u00e9gale \u00e0 2^32 :\n\n\n\n\nrc = malbinary_decoder_decode_large_enum(malbinary_decoder,\n  bytes, offset, \nenumerated_value);\n\n\n\n\nAffectation de l'\u00e9l\u00e9ment d\u00e9cod\u00e9 :\n\n\nelement\n = (\narea\n_[\nservice\n_]\nenum\n_t) enumerated_value;\n\n\n\n\nTest du code d'erreur :\n\n\nif (rc \n 0) return rc;", 
            "title": "MalBinary"
        }, 
        {
            "location": "/malbinary_generator/#generation-du-code-dencodage-malbinary", 
            "text": "Ce code est partag\u00e9 par les fonctions d'encodage g\u00e9n\u00e9r\u00e9es par Area et par Composite (voir sections 10.1.2 et 10.2.2).", 
            "title": "G\u00e9n\u00e9ration du code d'encodage 'malbinary'"
        }, 
        {
            "location": "/malbinary_generator/#calcul-de-la-taille-encodee", 
            "text": "Les param\u00e8tres suivants doivent \u00eatre transmis par le code appelant :    : \u00e9l\u00e9ment MAL \u00e0 encoder en fonction de son type  presence_flag : champ de pr\u00e9sence si l'\u00e9l\u00e9ment n'est pas de type pointeur  attribute_tag : identifiant du type d'Attribut en cas de polymorphisme d'Attribut  malbinary_encoder : configuration de l'encodeur  encoding_length : r\u00e9sultat du calcul", 
            "title": "Calcul de la taille encod\u00e9e"
        }, 
        {
            "location": "/malbinary_generator/#champ-optionnel", 
            "text": "Ajout de la taille du champ de pr\u00e9sence :  (*encoding_length) += MALBINARY_PRESENCE_FLAG_SIZE;  Si le champ est de type pointeur :  if ( element  != NULL) {  Sinon, test du champ de pr\u00e9sence :  if (presence_flag) {  Ajout de la taille de l'\u00e9l\u00e9ment encod\u00e9. Voir section 11.1.2.  }", 
            "title": "Champ optionnel"
        }, 
        {
            "location": "/malbinary_generator/#champ-non-optionnel", 
            "text": "", 
            "title": "Champ non optionnel"
        }, 
        {
            "location": "/malbinary_generator/#polymorphisme", 
            "text": "En cas de polymorphisme d'Attribut :  (*encoding_length) += MALBINARY_ATTRIBUTE_TAG_SIZE;  En cas de polymorphisme d'\u00e9l\u00e9ment :  (*encoding_length) += MALBINARY_SHORT_FORM_SIZE;", 
            "title": "Polymorphisme"
        }, 
        {
            "location": "/malbinary_generator/#valeur-de-lelement", 
            "text": "Si le type d\u00e9clar\u00e9 est  MAL::Attribute  :  rc = malbinary_encoder_add_attribute_encoding_length(malbinary_encoder,\n   attribute_tag ,  element , encoding_length);  Si le type de l'\u00e9l\u00e9ment est un Attribut :  rc = malbinary_encoder_add_ attribute _encoding_length(malbinary_encoder,\n   element , encoding_length);  Si l'\u00e9l\u00e9ment est de type Composite :  rc =  area _[ service _] composite _add_encoding_length_malbinary(\n   element , malbinary_encoder, encoding_length);  Si l'\u00e9l\u00e9ment est de type liste:  rc =  area _[ service _] type _list_add_encoding_length_malbinary(\n   element , malbinary_encoder, encoding_length);  Si l'\u00e9l\u00e9ment est de type Enumeration :   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^8 :   (*encoding_length) += MALBINARY_SMALL_ENUM_SIZE;   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^16 :   (*encoding_length) += MALBINARY_MEDIUM_ENUM_SIZE;   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^32 :   (*encoding_length) += MALBINARY_LARGE_ENUM_SIZE;  Test du code d'erreur :  if (rc   0) return rc;", 
            "title": "Valeur de l'\u00e9l\u00e9ment"
        }, 
        {
            "location": "/malbinary_generator/#encodage", 
            "text": "Les param\u00e8tres suivants doivent \u00eatre transmis par le code appelant :   element  : \u00e9l\u00e9ment MAL \u00e0 encoder en fonction de son type  presence_flag  : champ de pr\u00e9sence si l'\u00e9l\u00e9ment n'est pas de type pointeur  attribute_tag  : identifiant du type d'Attribut en cas de polymorphisme d'Attribut  malbinary_encoder  : configuration de l'encodeur MALBinary  bytes  : tableau d'octets o\u00f9 les \u00e9l\u00e9ments MAL sont encod\u00e9s  offset  : index de d\u00e9but de l'encodage", 
            "title": "Encodage"
        }, 
        {
            "location": "/malbinary_generator/#champ-optionnel_1", 
            "text": "Encodage du champ de pr\u00e9sence :  rc = malbinary_encoder_encode_presence_flag(malbinary_encoder,\n  bytes, offset,  presence_flag );\nif (rc   0) return rc;  Test du champ de pr\u00e9sence :  if ( presence_flag ) {  Encodage de l'\u00e9l\u00e9ment. Voir section 11.2.2.  }", 
            "title": "Champ optionnel"
        }, 
        {
            "location": "/malbinary_generator/#champ-non-optionnel_1", 
            "text": "", 
            "title": "Champ non optionnel"
        }, 
        {
            "location": "/malbinary_generator/#polymorphisme_1", 
            "text": "En cas de polymorphisme d'Attribut, encodage du tag d'attribut (voir section 5.2.2 du livre MAL/SPP) :  rc = malbinary_encoder_encode_attribute_tag(malbinary_encoder,\n  bytes, offset,  attribute_tag );  En cas de polymorphisme d'\u00e9l\u00e9ment :  rc = malbinary_encoder_encode_short_form(malbinary_encoder,\n  bytes, offset,  AREA _[ SERVICE _] TYPE _SHORT_FORM);  Test du code d'erreur :  if (rc   0) return rc;", 
            "title": "Polymorphisme"
        }, 
        {
            "location": "/malbinary_generator/#valeur-de-lelement_1", 
            "text": "Si le type d\u00e9clar\u00e9 est  MAL::Attribute  :  rc = malbinary_encoder_encode_attribute(malbinary_encoder,\n  bytes, offset,  attribute_tag ,  element );  Si le type de l'\u00e9l\u00e9ment est un Attribut :  rc = malbinary_encoder_encode_ attribute (malbinary_encoder,\n  bytes, offset,  element );  Si l'\u00e9l\u00e9ment est de type Composite:  rc =  area _[ service _] composite _encode_malbinary(\n   element , malbinary_encoder, bytes, offset);  Si l'\u00e9l\u00e9ment est de type liste:  rc =  area _[ service _] type _list_encode_malbinary(\n   element , malbinary_encoder, encoding_length);  Si l'\u00e9l\u00e9ment est de type Enumeration :   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^8 :   rc = malbinary_encoder_encode_small_enum(malbinary_encoder, bytes,\n  offset,  element );   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^16 :   rc = malbinary_encoder_encode_medium_enum(malbinary_encoder, bytes,\n  offset,  element );   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure \u00e0 2^32 :   rc = malbinary_encoder_encode_large_enum(malbinary_encoder, bytes,\n  offset,  element );  Test du code d'erreur :  if (rc   0) return rc;", 
            "title": "Valeur de l'\u00e9l\u00e9ment"
        }, 
        {
            "location": "/malbinary_generator/#decodage", 
            "text": "Les param\u00e8tres suivants doivent \u00eatre transmis par le code appelant :   presence_flag  : champ de pr\u00e9sence d\u00e9cod\u00e9  malbinary_decoder  : configuration de l'encodeur MALBinary  bytes  : tableau d'octets o\u00f9 les \u00e9l\u00e9ments MAL sont encod\u00e9s  offset  : index de d\u00e9but du d\u00e9codage", 
            "title": "D\u00e9codage"
        }, 
        {
            "location": "/malbinary_generator/#champ-optionnel_2", 
            "text": "D\u00e9codage du champ de pr\u00e9sence :  rc = malbinary_decoder_decode_presence_flag(malbinary_decoder,\n  bytes, offset,  presence_flag);\nif (rc   0) return rc;\nif (presence_flag) {  D\u00e9codage de l'\u00e9l\u00e9ment. Voir section 11.3.2.  }  Si le champ est de type pointeur :  else {\n   element  = NULL;\n\n}", 
            "title": "Champ optionnel"
        }, 
        {
            "location": "/malbinary_generator/#champ-non-optionnel_2", 
            "text": "", 
            "title": "Champ non optionnel"
        }, 
        {
            "location": "/malbinary_generator/#polymorphisme-dattribut", 
            "text": "En cas de polymorphisme d'Attribut, d\u00e9codage du tag d'Attribut :  unsigned char attribute_tag;   rc = malbinary_decoder_decode_attribute_tag(malbinary_decoder,\n  bytes, offset,  attribute_tag );  Test du code d'erreur :  if (rc   0) return rc;  D\u00e9codage de l'attribut :  rc = malbinary_decoder_decode_attribute(malbinary_decoder,\n    bytes, offset, attribute_tag ,  element );", 
            "title": "Polymorphisme d'Attribut"
        }, 
        {
            "location": "/malbinary_generator/#polymorphisme-delement", 
            "text": "En cas de polymorphisme d'\u00e9l\u00e9ment, d\u00e9codage du  short form  :  rc = malbinary_decoder_decode_short_form(malbinary_decoder,\n  bytes, offset,  element_holder- short_form);  Test du code d'erreur :  if (rc   0) return rc;  Pour chaque valeur de 'short_form' qui correspond \u00e0 un type conforme au type abstrait :  if (element_holder- short_form ==  AREA _[ SERVICE _] TYPE _SHORT_FORM) {  D\u00e9codage d'un \u00e9l\u00e9ment du type sp\u00e9cifi\u00e9. Voir section 11.3.2.3. L'\u00e9l\u00e9ment est d\u00e9cod\u00e9 directement dans la structure :   Si le type de l'\u00e9l\u00e9ment est un Attribut :          element_holder- value. attribute _value   Si l'\u00e9l\u00e9ment est de type Composite :          element_holder- value.composite_value   Si l'\u00e9l\u00e9ment est de type liste :          element_holder- value.list_value   Si l'\u00e9l\u00e9ment est de type Enumeration :          element_holder- value.enumerated_value  }[ else ]", 
            "title": "Polymorphisme d'\u00e9l\u00e9ment"
        }, 
        {
            "location": "/malbinary_generator/#valeur-de-lelement_2", 
            "text": "Si le type de l'\u00e9l\u00e9ment est un Attribut :  rc = malbinary_decoder_decode_ attribute (malbinary_decoder,\n  bytes, offset,  element );  Si l'\u00e9l\u00e9ment est de type Composite :  element  =  area _[ service _] composite _new();\nif ( element  == NULL) return -1;\nrc =  area _[ service _] composite _decode_malbinary(\n   element , malbinary_decoder, bytes, offset);  Si l'\u00e9l\u00e9ment est de type liste :  element  =  area _[ service _] type _list_new(0);\nif ( element  == NULL) return -1;\nrc =  area _[ service _] type _list_decode_malbinary(\n   element , malbinary_decoder, bytes, offset);  Si l'\u00e9l\u00e9ment est de type Enumeration :  int enumerated_value;   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure ou \u00e9gale \u00e0 2^8 :   rc = malbinary_decoder_decode_small_enum(malbinary_decoder,\n  bytes, offset,  enumerated_value);   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure ou \u00e9gale \u00e0 2^16 :   rc = malbinary_decoder_decode_medium_enum(malbinary_decoder,\n  bytes, offset,  enumerated_value);   Si la taille de l'\u00e9num\u00e9ration est inf\u00e9rieure ou \u00e9gale \u00e0 2^32 :   rc = malbinary_decoder_decode_large_enum(malbinary_decoder,\n  bytes, offset,  enumerated_value);  Affectation de l'\u00e9l\u00e9ment d\u00e9cod\u00e9 :  element  = ( area _[ service _] enum _t) enumerated_value;  Test du code d'erreur :  if (rc   0) return rc;", 
            "title": "Valeur de l'\u00e9l\u00e9ment"
        }, 
        {
            "location": "/annexes/", 
            "text": "Annexes\n\n\nExemple d'Area \u00ab TestArea \u00bb\n\n\nCet exemple permet de tester les aspects suivants du livre MAL :\n\n\n\n\npattern d'interaction SEND\n\n\nstructure Composite\n\n\nliste d'\u00e9l\u00e9ments\n\n\ncorps de message avec de multiples \u00e9l\u00e9ments\n\n\nchamp optionnel ('canBeNull=true')\n\n\npolymorphisme du dernier \u00e9l\u00e9ment de corps de message\n\n\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nmal:specification xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n                   xmlns:mal=\nhttp://www.ccsds.org/schema/ServiceSchema\n\n  \nmal:area name=\nTestArea\n number=\n200\n version=\n1\n\n    \nmal:service name=\nTestService\n number=\n1\n\n      \nmal:capabilitySet number=\n100\n\n        \nmal:sendIP name=\ntestSend\n number=\n100\n supportInReplay=\nfalse\n\n         comment=\n\n          \nmal:messages\n\n            \nmal:send\n\n              \nmal:type area=\nTestArea\n service=\nTestService\n\n               name=\nTestComposite\n /\n\n              \nmal:type list=\ntrue\n area=\nMAL\n name=\nString\n /\n\n              \nmal:type area=\nTestArea\n service=\nTestService\n\n               name=\nTestAbstractComposite\n /\n\n            \n/mal:send\n\n          \n/mal:messages\n\n        \n/mal:sendIP\n\n      \n/mal:capabilitySet\n\n      \nmal:dataTypes\n\n        \nmal:composite name=\nTestComposite\n shortFormPart=\n1\n comment=\n\n          \nmal:extends\n\n            \nmal:type area=\nMAL\n name=\nComposite\n /\n\n          \n/mal:extends\n\n          \nmal:field name=\nstringField\n canBeNull=\ntrue\n comment=\n\n            \nmal:type area=\nMAL\n name=\nString\n /\n\n          \n/mal:field\n\n          \nmal:field name=\nintField\n canBeNull=\ntrue\n comment=\n\n            \nmal:type area=\nMAL\n name=\nInteger\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n        \nsmc:composite name=\nTestAbstractComposite\n comment=\n\n          \nsmc:extends\n\n            \nsmc:type area=\nMAL\n name=\nComposite\n /\n\n          \n/smc:extends\n\n          \nmal:field name=\nintField\n canBeNull=\nfalse\n comment=\n\n            \nmal:type area=\nMAL\n name=\nInteger\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n        \nsmc:composite name=\nTestFinalCompositeA\n shortFormPart=\n2\n\n         comment=\n\n          \nsmc:extends\n\n            \nsmc:type area=\nTestArea\n service=\nTestService\n\n                      name=\nTestAbstractComposite\n /\n\n          \n/smc:extends\n\n          \nmal:field name=\nintField2\n canBeNull=\nfalse\n comment=\n\n            \nmal:type area=\nMAL\n name=\nInteger\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n        \nsmc:composite name=\nTestFinalCompositeB\n shortFormPart=\n3\n\n         comment=\n\n          \nsmc:extends\n\n            \nsmc:type area=\nTestArea\n service=\nTestService\n\n                      name=\nTestAbstractComposite\n /\n\n          \n/smc:extends\n\n          \nmal:field name=\nstringField\n canBeNull=\nfalse\n comment=\n\n            \nmal:type area=\nMAL\n name=\nString\n /\n\n          \n/mal:field\n\n        \n/mal:composite\n\n      \n/mal:dataTypes\n\n    \n/mal:service\n\n  \n/mal:area\n\n\n/mal:specification\n\n\n\n\n\nRisques de collision\n\n\nCette annexe liste des risques de collision de noms qui pourraient survenir lors de la g\u00e9n\u00e9ration de code. Des solutions sont propos\u00e9es. Elles ne sont pour l'instant pas appliqu\u00e9e \u00e0 la g\u00e9n\u00e9ration de code.\n\n\nChamp dans un composite\n\n\nAjout du suffixe \n_f\n au nom du champ de valeur pour \u00e9viter une collision possible avec le champ de pr\u00e9sence, par exemple pour deux champs MAL nomm\u00e9s \ntoto\n et \ntoto_is_present\n.\n\n\nbool \nfield\n_is_present;\nunsigned int \nfield\n_attribute_tag;\n\nfield type\n \nfield\n_f;\n\n\n\n\nFormat d'encodage du header MALZMQ\n\n\nPour simplifier le format d'encodage du header MAL, les champs \nURI From\n et \nURI To\n sont encod\u00e9s syst\u00e9matiquement et enti\u00e8rement. \n\n\n\n\n\n\n\n\nVersion Number\n\n\nSDU Type\n\n\nService Area\n\n\nService\n\n\nOperation\n\n\nArea Version\n\n\nIs Error Message\n\n\nQoSlevel\n\n\nSession\n\n\nTransaction Id\n\n\n\n\n\n\n\n\n\n\nBinary value (3 bits)\n\n\nUnsigned 5-bit Integer (5 bits)\n\n\nUnsigned 16-bit Integer (16 bits)\n\n\nUnsigned 16-bit Integer (16 bits)\n\n\nUnsigned 16-bit Integer (16 bits)\n\n\nUnsigned 8-bit Integer (8 bits)\n\n\nBinary value (1 bit)\n\n\nUnsigned 3-bit Integer (3 bits)\n\n\nUnsigned 4-bit Integer (4 bits)\n\n\nUnsigned 64-bit Integer (64 bits)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpare\n\n\nPriority Flag\n\n\nTime-stamp Flag\n\n\nNetwork Zone Flag\n\n\nSession Name Flag\n\n\nDomain Flag\n\n\nAuthentication Id Flag\n\n\n\n\n\n\n\n\n\n\nBinary value (2 bits)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\nBinary value (1 bit)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPriority\n\n\nURI From\n\n\nURI To\n\n\n\n\n\n\n\n\n\n\nUInteger (var. mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\n\n\n\n\nIf \u2018Priority Flag\u2019 is \u20181\u2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTimestamp\n\n\nNetwork Zone\n\n\nSession Name\n\n\nDomain\n\n\nAuthentication Id\n\n\n\n\n\n\n\n\n\n\nTime (var., mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\nOptional MDK (var., mult. of octet)\n\n\nList\n (var., mult. of octet)\n\n\nBlob (var., mult. of octet)\n\n\n\n\n\n\nIf \u2018Timestamp Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Network Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Session Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Domain Flag\u2019 is \u20181\u2019\n\n\nIf \u2018Authentication Id Flag\u2019 is \u20181\u2019\n\n\n\n\n\n\n\n\nSch\u00e9ma de description des \u00ab classes \u00bb\n\n\nLe sch\u00e9ma ci-dessous d\u00e9crit les diff\u00e9rentes classes de l'implantation et leurs relations, les classes sont s\u00e9par\u00e9es en deux espaces MAL et transport MAL/CZMQ. La plupart des ces relations sont unitaires, seule la classe malzmq_poller_data_t contient une liste de r\u00e9f\u00e9rence vers la classe \nmalzmq_endpoint_data_t\n.\n\n\n\n\nFigure 1 - Description des \"classes\" du MAL", 
            "title": "Annexes"
        }, 
        {
            "location": "/annexes/#annexes", 
            "text": "", 
            "title": "Annexes"
        }, 
        {
            "location": "/annexes/#exemple-darea-testarea", 
            "text": "Cet exemple permet de tester les aspects suivants du livre MAL :   pattern d'interaction SEND  structure Composite  liste d'\u00e9l\u00e9ments  corps de message avec de multiples \u00e9l\u00e9ments  champ optionnel ('canBeNull=true')  polymorphisme du dernier \u00e9l\u00e9ment de corps de message   ?xml version= 1.0  encoding= UTF-8 ?  mal:specification xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n                   xmlns:mal= http://www.ccsds.org/schema/ServiceSchema \n   mal:area name= TestArea  number= 200  version= 1 \n     mal:service name= TestService  number= 1 \n       mal:capabilitySet number= 100 \n         mal:sendIP name= testSend  number= 100  supportInReplay= false \n         comment= \n           mal:messages \n             mal:send \n               mal:type area= TestArea  service= TestService \n               name= TestComposite  / \n               mal:type list= true  area= MAL  name= String  / \n               mal:type area= TestArea  service= TestService \n               name= TestAbstractComposite  / \n             /mal:send \n           /mal:messages \n         /mal:sendIP \n       /mal:capabilitySet \n       mal:dataTypes \n         mal:composite name= TestComposite  shortFormPart= 1  comment= \n           mal:extends \n             mal:type area= MAL  name= Composite  / \n           /mal:extends \n           mal:field name= stringField  canBeNull= true  comment= \n             mal:type area= MAL  name= String  / \n           /mal:field \n           mal:field name= intField  canBeNull= true  comment= \n             mal:type area= MAL  name= Integer  / \n           /mal:field \n         /mal:composite \n         smc:composite name= TestAbstractComposite  comment= \n           smc:extends \n             smc:type area= MAL  name= Composite  / \n           /smc:extends \n           mal:field name= intField  canBeNull= false  comment= \n             mal:type area= MAL  name= Integer  / \n           /mal:field \n         /mal:composite \n         smc:composite name= TestFinalCompositeA  shortFormPart= 2 \n         comment= \n           smc:extends \n             smc:type area= TestArea  service= TestService \n                      name= TestAbstractComposite  / \n           /smc:extends \n           mal:field name= intField2  canBeNull= false  comment= \n             mal:type area= MAL  name= Integer  / \n           /mal:field \n         /mal:composite \n         smc:composite name= TestFinalCompositeB  shortFormPart= 3 \n         comment= \n           smc:extends \n             smc:type area= TestArea  service= TestService \n                      name= TestAbstractComposite  / \n           /smc:extends \n           mal:field name= stringField  canBeNull= false  comment= \n             mal:type area= MAL  name= String  / \n           /mal:field \n         /mal:composite \n       /mal:dataTypes \n     /mal:service \n   /mal:area  /mal:specification", 
            "title": "Exemple d'Area \u00ab TestArea \u00bb"
        }, 
        {
            "location": "/annexes/#risques-de-collision", 
            "text": "Cette annexe liste des risques de collision de noms qui pourraient survenir lors de la g\u00e9n\u00e9ration de code. Des solutions sont propos\u00e9es. Elles ne sont pour l'instant pas appliqu\u00e9e \u00e0 la g\u00e9n\u00e9ration de code.", 
            "title": "Risques de collision"
        }, 
        {
            "location": "/annexes/#champ-dans-un-composite", 
            "text": "Ajout du suffixe  _f  au nom du champ de valeur pour \u00e9viter une collision possible avec le champ de pr\u00e9sence, par exemple pour deux champs MAL nomm\u00e9s  toto  et  toto_is_present .  bool  field _is_present;\nunsigned int  field _attribute_tag; field type   field _f;", 
            "title": "Champ dans un composite"
        }, 
        {
            "location": "/annexes/#format-dencodage-du-header-malzmq", 
            "text": "Pour simplifier le format d'encodage du header MAL, les champs  URI From  et  URI To  sont encod\u00e9s syst\u00e9matiquement et enti\u00e8rement.      Version Number  SDU Type  Service Area  Service  Operation  Area Version  Is Error Message  QoSlevel  Session  Transaction Id      Binary value (3 bits)  Unsigned 5-bit Integer (5 bits)  Unsigned 16-bit Integer (16 bits)  Unsigned 16-bit Integer (16 bits)  Unsigned 16-bit Integer (16 bits)  Unsigned 8-bit Integer (8 bits)  Binary value (1 bit)  Unsigned 3-bit Integer (3 bits)  Unsigned 4-bit Integer (4 bits)  Unsigned 64-bit Integer (64 bits)        Spare  Priority Flag  Time-stamp Flag  Network Zone Flag  Session Name Flag  Domain Flag  Authentication Id Flag      Binary value (2 bits)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)  Binary value (1 bit)        Priority  URI From  URI To      UInteger (var. mult. of octet)  Optional MDK (var., mult. of octet)  Optional MDK (var., mult. of octet)    If \u2018Priority Flag\u2019 is \u20181\u2019          Timestamp  Network Zone  Session Name  Domain  Authentication Id      Time (var., mult. of octet)  Optional MDK (var., mult. of octet)  Optional MDK (var., mult. of octet)  List  (var., mult. of octet)  Blob (var., mult. of octet)    If \u2018Timestamp Flag\u2019 is \u20181\u2019  If \u2018Network Flag\u2019 is \u20181\u2019  If \u2018Session Flag\u2019 is \u20181\u2019  If \u2018Domain Flag\u2019 is \u20181\u2019  If \u2018Authentication Id Flag\u2019 is \u20181\u2019", 
            "title": "Format d'encodage du header MALZMQ"
        }, 
        {
            "location": "/annexes/#schema-de-description-des-classes", 
            "text": "Le sch\u00e9ma ci-dessous d\u00e9crit les diff\u00e9rentes classes de l'implantation et leurs relations, les classes sont s\u00e9par\u00e9es en deux espaces MAL et transport MAL/CZMQ. La plupart des ces relations sont unitaires, seule la classe malzmq_poller_data_t contient une liste de r\u00e9f\u00e9rence vers la classe  malzmq_endpoint_data_t .   Figure 1 - Description des \"classes\" du MAL", 
            "title": "Sch\u00e9ma de description des \u00ab classes \u00bb"
        }
    ]
}