<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Stubs generator - MAL C API</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MAL C API</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../tutorial/">Tutorial</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">MAL APIs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_attributes/">Attributes</a>
</li>

                        
                            
<li >
    <a href="../mal_encoding/">Encoding</a>
</li>

                        
                            
<li >
    <a href="../mal_api/">MAL</a>
</li>

                        
                            
<li >
    <a href="../mal_transport/">Transport</a>
</li>

                        
                            
<li >
    <a href="../area/">Area</a>
</li>

                        
                            
<li >
    <a href="../mal_actor/">Actor</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transports <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_czmq/">MAL/ZMQ</a>
</li>

                        
                            
<li >
    <a href="../mal_tcp/">MAL/TCP</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Generators <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">Stubs generator</a>
</li>

                        
                            
<li >
    <a href="../malbinary_generator/">MalBinary</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../annexes/">Annexs</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../mal_tcp/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../malbinary_generator/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#stubs-code-generation">Stubs code generation</a></li>
        
            <li><a href="#area">Area</a></li>
        
            <li><a href="#composite">Composite</a></li>
        
            <li><a href="#lists-of-composite">Lists of Composite</a></li>
        
            <li><a href="#lists-of-enumerated-values">Lists of enumerated values</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="stubs-code-generation">Stubs code generation</h1>
<p>Generated code is produced for a dedicated mission which uses a set of service Areas.</p>
<p>The C statement 'calloc' (initializes allocated bytes with 0) is used to allocate the structures and pointers arrays. It guarantees that the destructor will not free memory through false pointers when the initialization has not completed properly.</p>
<h2 id="area">Area</h2>
<p>A new project of type 'zproject' is created for each Area. Il is named as the area name in lower case: <code>&lt;area&gt;</code></p>
<h3 id="include-file-h">Include file (.h)</h3>
<p>A file <code>&lt;area&gt;.h</code> is defined for each area.</p>
<h4 id="header">Header</h4>
<pre><code class="c">#ifndef __&lt;AREA&gt;_H_INCLUDED__
#define __&lt;AREA&gt;_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<p>Declare the dependency on the MAL Area:</p>
<pre><code class="c">#include &quot;mal.h&quot;
</code></pre>

<p>For each required Area:</p>
<pre><code class="c">#include &quot;&lt;required area&gt;.h&quot;
</code></pre>

<h4 id="constants">Constants</h4>
<p>Definition of area specific constants:</p>
<pre><code class="c">#define &lt;AREA&gt;_AREA_NUMBER &lt;area number&gt;
#define &lt;AREA&gt;_AREA_VERSION &lt;version&gt;
</code></pre>

<p>For each service:</p>
<pre><code class="c">#define &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER &lt;service number&gt;
</code></pre>

<p>For each service operation:</p>
<pre><code class="c">#define &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER &lt;operation number&gt;
</code></pre>

<p>For each error raised by an operation:</p>
<pre><code class="c">#define &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_&lt;ERROR&gt;_ERROR_NUMBER &lt;error number&gt;
</code></pre>

<h4 id="types">Types</h4>
<p>For each Enumeration type:</p>
<pre><code class="c">typedef enum {
  &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_&lt;ENUMERATED NAME&gt;,
} &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t;
</code></pre>

<p>For each Composite type:</p>
<pre><code class="c">typedef struct _&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t;
</code></pre>

<p>For each data type defined above (Enumeration, Composite):</p>
<pre><code class="c">typedef struct _&lt;area&gt;_[&lt;service&gt;_]&lt;type&gt;_list_t
  &lt;area&gt;_[&lt;service&gt;_]&lt;type&gt;_list_t;
</code></pre>

<p>For each data type, define the numerical identifier 'short form' (typed as 'long') according to the definition in section 5.2.3 of the MAL/SPP book:</p>
<pre><code class="c">#define &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;TYPE&gt;_SHORT_FORM &lt;short form&gt;
#define &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;TYPE&gt;_LIST_SHORT_FORM &lt;short form&gt;
</code></pre>

<h4 id="operations">Operations</h4>
<p>For each service operation, except when the IP is Publish/Subscribe, the following functions are defined:</p>
<ul>
<li>a function sending a message to initiate the interaction (first step);</li>
<li>a function sending a message for each result step of the interaction (second and following steps).</li>
</ul>
<p>Interaction initiation (except Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;first stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message,
  mal_uri_t *provider_uri);
</code></pre>

<p>Interaction result (except Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;result stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message, mal_message_t *result_message,
  bool is_error_message);
</code></pre>

<p>For each service operation when the IP is Publish/Subscribe, functions are defined for the following interaction steps: register, publishRegister, publish, deregister, publishDeregister.</p>
<p>Subscription (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_register(
  mal_ctx_t *mal_ctx, mal_endpoint_t *endpoint, mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<p>Declaration of publish (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_register(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<p>Publish (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri,
  long initial_publish_register_tid);
</code></pre>

<p>Unsubscription (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<p>Stop of publish (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<h4 id="encoding-functions">Encoding functions</h4>
<p>For each message of an interaction step, the following functions are defined:</p>
<ul>
<li>for each element of a message body (identified by its index), and for each type in case of polymorphism (cf 9.4.1):<ul>
<li>a function to get the size required to encode the data</li>
<li>a function to encode the data</li>
</ul>
</li>
<li>for each element of a message body (identified by its index and its declared type):<ul>
<li>a function to decode the data</li>
</ul>
</li>
</ul>
<p>The operations with IP Publish/Subscribe are handled in a special way. The three en/decoding functions are only generated for a single fictional interaction step, the update step, which matches the two steps publish and notify. The parameters types of those interaction steps are defined in the operation specification as a publishNotify message. Moreover the actual parameters types used in the functions, and in the en/decoding functions, are lists of the types declared in the specification.</p>
<p>The en/decoding functions related to the error messages follow the general schema with the following specificities:</p>
<ul>
<li>the name of the functions does not include an index,</li>
<li>the name of the encoding functions always includes the type suffix &lt;_qftype&gt;,</li>
<li>the decoding function follows the rule of decoding with polymorphism of Element.</li>
</ul>
<h5 id="computing-the-encoding-length">Computing the encoding length</h5>
<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  mal_encoder_t *encoder, bool presence_flag,
  unsigned char attribute_tag, union mal_attribute_t element,
  void *cursor);
</code></pre>

<p>Else the type of the element is known (even in case of polymorphism):</p>
<ul>
<li>If the element is a non pointer Attribute or an enumerated value:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  mal_encoder_t *encoder, bool presence_flag,
  &lt;qftype&gt;_t element, void *cursor);
</code></pre>

<ul>
<li>If the element is a pointer Attribute, a Composite or a list:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  mal_encoder_t *encoder, &lt;qftype&gt;_[list_]t *element,
  void *cursor);
</code></pre>

<p>If the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification:</p>
<pre><code class="c">int &lt;qfop&gt;_update_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;_list](
  mal_encoder_t *encoder,
    &lt;qftype&gt;_list_t *element,
    void *cursor);
</code></pre>

<h5 id="encoding">Encoding</h5>
<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  void *cursor, mal_encoder_t *encoder,
  bool presence_flag, unsigned char attribute_tag,
  union mal_attribute_t element);
</code></pre>

<p>Else the type of the element is known (even in case of polymorphism):</p>
<ul>
<li>If the element is a non pointer Attribute or an enumerated value:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  void *cursor, mal_encoder_t *encoder,
  bool presence_flag, &lt;qftype&gt;_t element);
</code></pre>

<ul>
<li>If the element is a pointer Attribute, a Composite or a list:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  void *cursor, mal_encoder_t *encoder,
  &lt;qftype&gt;_[list_]t *element);
</code></pre>

<p>If the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification:</p>
<pre><code class="c">int &lt;qfop&gt;_update_encode[_&lt;index&gt;][_&lt;qftype&gt;_list](
  void *cursor, mal_encoder_t *encoder,
  &lt;qftype&gt;_list_t *element);
</code></pre>

<h5 id="decoding">Decoding</h5>
<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  bool *presence_flag_res, unsigned char *attribute_tag_res,
  union mal_attribute_t *element_res);
</code></pre>

<p>In case of polymorphism of Element, including if the operation is PubSub (stage = update), and/or for an error message:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  mal_element_holder_t *element_holder);
</code></pre>

<p>If the element type is known:</p>
<ul>
<li>If the element is a non pointer Attribute or an enumerated value:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  bool *presence_flag_res, &lt;qftype&gt;_t *element_res);
</code></pre>

<ul>
<li>If the element is a pointer Attribute, a Composite or a list:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  &lt;qftype&gt;_[list_]t **element_res);
</code></pre>

<p>If the operation is Pub/Sub, the function is generated for the type list of the type declared in the specification, except in case of polymorphism where the standard case of polymorphism of Element is reused.</p>
<pre><code class="c">int &lt;qfop&gt;_update_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  &lt;qftype&gt;_list_t **element_res);
</code></pre>

<h4 id="end-of-file">End of file</h4>
<p>A test function:</p>
<pre><code class="c">void &lt;area&gt;_test(bool verbose);
</code></pre>

<p>For each Composite structure:</p>
<pre><code class="c">#include &quot;&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;.h&quot;
</code></pre>

<p>For each list of Composite:</p>
<pre><code class="c">#include &quot;&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list.h&quot;
</code></pre>

<p>For each list of enumrated values:</p>
<pre><code class="c">#include &quot;&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list.h&quot;
</code></pre>

<p>end of file:</p>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="source-file-c">Source file (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<p>For each enumeration:</p>
<pre><code class="c">int &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_NUMERIC_VALUES[] = {
  &lt;numeric value&gt;,
}
</code></pre>

<h4 id="interaction-initiation-except-publishsubscribe">Interaction initiation (except Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;first stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message,
  mal_uri_t *provider_uri) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(init_message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_&lt;IP&gt;,
    MAL_IP_STAGE_&lt;STAGE&gt;);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(
    endpoint, init_message, provider_uri, true);
  return rc;
}
</code></pre>

<h4 id="interaction-result-except-publishsubscribe">Interaction result (except Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;result stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message,
  mal_message_t *result_message,
  bool is_error_message) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(result_message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_&lt;IP&gt;,
    MAL_IP_STAGE_&lt;STAGE&gt;);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_return_operation(
    endpoint, init_message, result_message, is_error_message);
  return rc;
}
</code></pre>

<h4 id="subscription-publishsubscribe">Subscription (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_register(
  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_REGISTER);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="declaration-of-publish-publishsubscribe">Declaration of publish (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_register(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="publish-publishsubscribe">Publish (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri,
  long initial_publish_register_tid) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_PUBLISH);
</code></pre>

<p>Set the <code>Transaction Id</code>:</p>
<pre><code class="c">  mal_message_set_transaction_id(message, initial_publish_register_tid);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, false);
  return rc;
}
</code></pre>

<h4 id="unsubscription-publishsubscribe">Unsubscription (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_DEREGISTER);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="stop-of-publish-publishsubscribe">Stop of publish (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Set the fields related to the called operation:</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER);
</code></pre>

<p>Send the message:</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="computing-the-encoding-length_1">Computing the encoding length</h4>
<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  mal_encoder_t *encoder, bool presence_flag,
  unsigned char attribute_tag, union mal_attribute_t element,
  void *cursor) {
</code></pre>

<p>Else the type of the element is known (even in case of polymorphism):</p>
<ul>
<li>If the element is a non pointer Attribute or an enumerated value:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  mal_encoder_t *encoder, bool presence_flag,
  &lt;qftype&gt;_t element, void *cursor) {
</code></pre>

<ul>
<li>If the element is a pointer Attribute, a Composite or a list:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  mal_encoder_t *encoder, &lt;qftype&gt;_[list_]t *element,
  void *cursor) {
```c

Initialize the error code:

```c
  int rc = 0;
</code></pre>

<p>Test the encoding format allowing for format specific encoding:</p>
<pre><code class="c">  switch (encoder-&gt;encoding_format_code) {
</code></pre>

<p>For each available format:</p>
<pre><code class="c">  case &lt;FORMAT&gt;_FORMAT_CODE: {
</code></pre>

<p>Compute the encoding length of an optional field:
  - For the encoding format <code>malbinary</code>, cf section 11.1.1.</p>
<pre><code class="c">    break;
  }
  default:
    rc = -1;
  }
  return rc;
}
</code></pre>

<h4 id="encoding_1">Encoding</h4>
<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  void *cursor, mal_encoder_t *encoder,
  bool presence_flag, unsigned char attribute_tag,
  union mal_attribute_t element) {
</code></pre>

<p>Else the type of the element is known (even in case of polymorphism):</p>
<ul>
<li>If the element is a non pointer Attribute or an enumerated value:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  void *cursor, mal_encoder_t *encoder,
  bool presence_flag, &lt;qftype&gt;_t element) {
</code></pre>

<ul>
<li>If the element is a pointer Attribute, a Composite or a list:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  void *cursor, mal_encoder_t *encoder,
  &lt;qftype&gt;_[list_]t *element) {
  bool presence_flag = (element != NULL);
</code></pre>

<p>Initialize the error code:</p>
<pre><code class="c">  int rc = 0;
</code></pre>

<p>Test the encoding format allowing for format specific encoding:</p>
<pre><code class="c">  switch (encoder-&gt;encoding_format_code) {
</code></pre>

<p>For each available format:</p>
<pre><code class="c">  case &lt;FORMAT&gt;_FORMAT_CODE: {
</code></pre>

<p>Encode an optional field:</p>
<ul>
<li>For the encoding format <code>malbinary</code>, cf section 11.2.2.</li>
</ul>
<pre><code class="c">    break;
  }
  default:
    rc = -1;
  }
  return rc;
}
</code></pre>

<h4 id="decoding_1">Decoding</h4>
<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  bool *presence_flag_res, unsigned char *attribute_tag_res,
  union mal_attribute_t *element_res) {
</code></pre>

<p>In case of polymorphism of Element and/or for an error message:</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  mal_element_holder_t *element_holder) {
</code></pre>

<p>If the element type is known:</p>
<ul>
<li>If the element is a non pointer Attribute or an enumerated value:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  bool *presence_flag_res, &lt;qftype&gt;_t *element_res) {
</code></pre>

<ul>
<li>If the element is a pointer Attribute, a Composite or a list:</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  void *cursor, mal_decoder_t *decoder,
  &lt;qftype&gt;_[list_]t **element_res) {
</code></pre>

<p>Initialize the error code:</p>
<pre><code class="c">  int rc = 0;
</code></pre>

<p>Test the decoding format allowing for format specific decoding:</p>
<pre><code class="c">  switch (decoder-&gt;encoding_format_code) {
</code></pre>

<p>For each available format:</p>
<pre><code class="c">  case &lt;FORMAT&gt;_FORMAT_CODE: {
      bool presence_flag;
</code></pre>

<p>Decode an optional field:</p>
<ul>
<li>For the encoding format <code>malbinary</code>, cf section 11.3.1.</li>
<li>Data are decoded directly into the result structure or pointer.</li>
</ul>
<p>In case of polymorphism of Attribute or if the element is a non pointer Attribute or an enumerated value:</p>
<pre><code class="c">    (*presence_flag_res) = presence_flag;
</code></pre>

<p>In case of polymorphism of Element:</p>
<pre><code class="c">    mal_element_holder_set_presence_flag(element_holder, presence_flag);
</code></pre>

<p>End of decoding.</p>
<pre><code class="c">    break;
  }
  default:
    rc = -1;
  }
  return rc;
}
</code></pre>

<h2 id="composite">Composite</h2>
<h3 id="include-file-h_1">Include file (.h)</h3>
<pre><code class="c">#ifndef __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_H_INCLUDED__
#define __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<p>Empty constructor:</p>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_new(void);
</code></pre>

<p>For each encoding format:</p>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_add_encoding_length_&lt;format&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, mal_encoder_t *encoder,
    void *cursor);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_encode_&lt;format&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, mal_encoder_t *encoder,
    void *cursor);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_decode_&lt;format&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, mal_decoder_t *decoder,
    void *cursor);
</code></pre>

<p>For each field in the composite (including nherited fields):</p>
<pre><code class="c">&lt;field type&gt; &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_get_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self);

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_set_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;field type&gt; &lt;field&gt;);
</code></pre>

<p>If the field is not a pointer (cannot store a NULL value):</p>
<pre><code class="c">bool &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_is_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self);

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, bool is_present);
</code></pre>

<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">unsigned char &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_get_attribute_tag(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self);

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_attribute_tag(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, unsigned char attribute_tag);
</code></pre>

<p>Destructor:</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **self_p);
</code></pre>

<p>Test function:</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_test(bool verbose);
</code></pre>

<p>End of file:</p>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="source-file-c_1">Source file (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<h4 id="define-the-structure">Define the structure</h4>
<pre><code class="c">struct _&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t {
</code></pre>

<p>For each field (including inherited fields):</p>
<ul>
<li>
<p>In case of polymorphism of Attribute:</p>
<ul>
<li>
<p>If the field is not mandatory (canBeNull = 'true'):</p>
<p><code>c
bool &lt;field&gt;_is_present;</code></p>
</li>
<li>
<p>Declare the field:</p>
<p><code>c
unsigned char &lt;field&gt;_attribute_tag;
union mal_attribute_t &lt;field&gt;;</code></p>
</li>
</ul>
</li>
<li>
<p>If the element is a non pointer Attribute or an enumerated value:</p>
<ul>
<li>
<p>If the field is not mandatory (canBeNull = 'true'):</p>
<p><code>c
bool &lt;field&gt;_is_present;</code></p>
</li>
<li>
<p>Declare the field:</p>
<p><code>c
&lt;field type&gt; \&lt;field&gt;;</code></p>
</li>
</ul>
</li>
<li>
<p>Else:</p>
<p><code>c
&lt;field type&gt; *\&lt;field&gt;;</code></p>
</li>
</ul>
<p>End the structure definition*:</p>
<pre><code class="c">};
</code></pre>

<h4 id="constructor">Constructor</h4>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_new(void) {
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self =
      (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *) calloc(
          1, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t));
  if (!self)
    return NULL;
  return self;
}
</code></pre>

<h4 id="getters-and-setters">Getters and setters</h4>
<p>For each field (including inherited fields):</p>
<pre><code class="c">&lt;field type&gt; &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_get_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self) {
  return self-&gt;&lt;field&gt;;
}
</code></pre>

<p>The <code>setter</code> function only changes the field value. It shall leave the presence flag unchanged.</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_set_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;field type&gt; &lt;field&gt;) {
  self-&gt;&lt;field&gt; = &lt;field&gt;;
}
</code></pre>

<p>If the field is not mandatory (canBeNull = 'true') and if the field is not a pointer:</p>
<pre><code class="c">bool &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_is_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self) {
  return self-&gt;&lt;field&gt;_is_present;
}

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, bool is_present) {
  self-&gt;&lt;field&gt;_is_present = is_present;
}
</code></pre>

<p>In case of polymorphism of Attribute:</p>
<pre><code class="c">unsigned char &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_get_attribute_tag(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self) {
  return self-&gt;&lt;field&gt;_attribute_tag;
}

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_attribute_tag(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
  unsigned char attribute_tag) {
  self-&gt;&lt;field&gt;_attribute_tag = attribute_tag;
}
</code></pre>

<h4 id="computing-the-encoding-length-malbinary">Computing the encoding length (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_add_encoding_length_malbinary(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, mal_encoder_t *mal_encoder,
    void *cursor) {
  int rc = 0;
</code></pre>

<p>For each field (inherited fields first):</p>
<ul>
<li>If the field is not mandatory, cf section 11.1.1.</li>
<li>Else cf section 11.1.2.</li>
</ul>
<p>End of function:</p>
<pre><code class="c">  return rc;
}
</code></pre>

<h4 id="encoding-malbinary">Encoding (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_encode_malbinary(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, mal_encoder_t *mal_encoder,
    void *cursor) {
</code></pre>

<p>If there is at least one non mandatory field:</p>
<pre><code class="c">  bool presence_flag;
</code></pre>

<p>For each field (inherited fields first):</p>
<ul>
<li>If the field is not mandatory:<ul>
<li>If the field is a non pointer Attribute or an enumerated value: 
    <code>c
    presence_flag = self-&gt;&lt;field&gt;_is_present;</code></li>
<li>Else: 
    <code>c
    presence_flag = (self-&gt;&lt;field&gt; != NULL);</code></li>
<li>Cf section 11.2.1.</li>
</ul>
</li>
<li>Else cf section 11.2.2.</li>
</ul>
<p>End of encoding:</p>
<pre><code class="c">  return rc;
}
</code></pre>

<h4 id="decoding-malbinary">Decoding (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_decode_malbinary(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, mal_decoder_t *mal_decoder,
    void *cursor) {
</code></pre>

<p>If there is at least one non mandatory field:</p>
<pre><code class="c">  bool presence_flag;
</code></pre>

<p>For each field (inherited fields first):</p>
<ul>
<li>If the field is not mandatory, cf section 11.3.1.</li>
<li>Else cf section 11.3.2.</li>
</ul>
<p>Data are decoded directly into the result structure or pointer.</p>
<p>If the field is not mandatory and is typed as an abstract Attribute, a non pointer Attribute or an enumerated value:</p>
<pre><code class="c">    self-&gt;&lt;field&gt;_is_present = presence_flag;
</code></pre>

<p>End of decoding:</p>
<pre><code class="c">  return rc;
}
</code></pre>

<h4 id="destructor">Destructor</h4>
<p>Frees the composite structure and the structures embedded in the composite fields (composites, lists, Strings, Blobs).</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **self_p) {
</code></pre>

<p>For each field, including inherited fields:</p>
<ul>
<li>In case of polymorphism of Attribute:<ul>
<li>if the field is not mandatory (canBeNull = 'true'):
    <code>c
    if ((*self_p)-&gt;&lt;field&gt;_is_present)</code></li>
<li>free the field:
    <code>c
    mal_attribute_destroy(&amp;(*self_p)-&gt;&lt;field&gt;,
      (*self_p)-&gt;&lt;field&gt;_attribute_tag);</code></li>
</ul>
</li>
<li>If the field is a pointer Attribute:
    <code>c
    if ((*self_p)-&gt;&lt;field&gt;!= NULL)
      mal_&lt;attribute&gt;_destroy(&amp;(*self_p)-&gt;&lt;field&gt;);</code></li>
<li>If the field is a Composite:
    <code>c
    if ((*self_p)-&gt;&lt;field&gt;!= NULL)
      &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(&amp;(*self_p)-&gt;&lt;field&gt;);</code></li>
<li>If the field is a list:
    <code>c
    if ((*self_p)-&gt;&lt;field&gt;!= NULL)
      &lt;area&gt;_[&lt;service&gt;_]&lt;type&gt;_list_destroy(&amp;(*self_p)-&gt;&lt;field&gt;);</code></li>
</ul>
<p>Free the memory and reset the pointer:</p>
<pre><code class="c">  free(*self_p);
  (*self_p) = NULL;
}
</code></pre>

<h2 id="lists-of-composite">Lists of Composite</h2>
<h3 id="include-file-h_2">Include file (.h)</h3>
<pre><code class="c">#ifndef __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_LIST_H_INCLUDED__
#define __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_LIST_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<h4 id="constructor_1">Constructor:</h4>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_new(unsigned int element_count);
</code></pre>

<h4 id="getters">Getters:</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self);

&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **mal_list_get_content(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self);
</code></pre>

<h4 id="for-each-encoding-format">For each encoding format:</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_add_encoding_length_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_encode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_decode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
  mal_decoder_t *decoder, void *cursor);
</code></pre>

<h4 id="destructor_1">Destructor:</h4>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t **self_p);
</code></pre>

<h4 id="test-function">Test function:</h4>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_test(bool verbose);
</code></pre>

<h4 id="end-of-file_1">End of file :</h4>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="source-file-c_2">Source file (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<h4 id="constructor_2">Constructor</h4>
<p>Structure definition:</p>
<pre><code class="c">struct _&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t {
  unsigned int element_count;
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **content;
};
</code></pre>

<p>Constructor:</p>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_new(unsigned int element_count) {
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self =
    (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *) calloc(1,
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t));
  if (!self) return NULL;
  self-&gt;element_count = element_count;
  self-&gt;content = (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **) calloc(
      element_count, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *));
  return self;
}
</code></pre>

<h4 id="getters_1">Getters</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self) {
  return self-&gt;element_count;
}

&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_get_content(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self) {
  return self-&gt;content;
}
</code></pre>

<h4 id="computing-the-encoding-length-malbinary_1">Computing the encoding length (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_add_encoding_length_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
</code></pre>

<p>Encoding the list size:</p>
<pre><code class="c">  mal_encoder_add_list_size_encoding_length(encoder, list_size, cursor);
</code></pre>

<p>Encoding the list elements:</p>
<pre><code class="c">  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *element = content[i];
</code></pre>

<p>All the elements of the list may be null. A presence flag is encoded for each of them:</p>
<pre><code class="c">    bool presence_flag = (element != NULL);
    mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);
</code></pre>

<p>Compute the encoding length of a non mandatory composite field: cf section 11.1.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="encoding-malbinary_1">Encoding (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_encode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
  rc = mal_encoder_encode_list_size(encoder, cursor, list_size);
  if (rc &lt; 0) return rc;
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *element = content[i];
</code></pre>

<p>Encoding a non mandatory Composite : cf section 11.2.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="decoding-malbinary_1">Decoding (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_decode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  mal_decoder_t *decoder, void *cursor) {
  int rc = 0;
  int rc = mal_decoder_decode_list_size(decoder, cursor, &amp;self-&gt;element_count);
  if (rc &lt; 0) return rc;
  if (self-&gt;element_count == 0) {
    self-&gt;content = NULL;
    return 0;
  }
  self-&gt;content = (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **) calloc(
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *) * self-&gt;element_count);
  if (self-&gt;content == NULL)
    return -1;
  for (int i = 0; i &lt; self-&gt;element_count; i++) {
</code></pre>

<p>Decoding a non mandatory Composite: cf section 11.3.1.</p>
<p>Data are decoded directly into the result structure or pointer (i.e. <code>self-&gt;content[i]</code>).</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="destructor_2">Destructor</h4>
<p>Frees the list, its content, and the list elements.</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t **self_p) {
  if ((*self_p)-&gt;element_count &gt; 0) {
    for (int i = 0; i &lt; (*self_p)-&gt;element_count; i++) {
      if ((*self_p)-&gt;content[i] != NULL)
        &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(&amp;(*self_p)-&gt;content[i]);
    }
    free((*self_p)-&gt;content);
  }
  free (*self_p);
  (*self_p) = NULL;
}
</code></pre>

<h2 id="lists-of-enumerated-values">Lists of enumerated values</h2>
<h3 id="include-file-h_3">Include file (.h)</h3>
<pre><code class="c">#ifndef __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_LIST_H_INCLUDED__
#define __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_LIST_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<h4 id="constructor_3">Constructor:</h4>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_new(
    unsigned int element_count);
</code></pre>

<h4 id="getters_2">Getters:</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self);

bool *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_presence_flags(
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self);

&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *mal_list_get_content(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self);
</code></pre>

<h4 id="for-each-encoding-format_1">For each encoding format:</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_add_encoding_length_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor);

int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_encode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor);

int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_decode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *self,
  &lt;format&gt;_decoder_t *decoder, void *cursor);
</code></pre>

<h4 id="destructor_3">Destructor:</h4>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t **self_p);
Fonction de test :
void &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_test(bool verbose);
</code></pre>

<h5 id="end-of-file_2">End of file:</h5>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="source-file-c_3">Source file (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<h4 id="constructor_4">Constructor</h4>
<p>Declare the structure:</p>
<pre><code class="c">struct _&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t {
  unsigned int element_count;
  bool *presence_flags;
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *content;
};
</code></pre>

<p>Constructor:</p>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_new(
    unsigned int element_count) {
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self =
    (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *) calloc(1,
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t));
  if (!self) return NULL;
  self-&gt;element_count = element_count;
  if (element_count == 0) return self;
  self-&gt;presence_flags = (bool *) calloc(element_count, sizeof(bool));
  if (!self-&gt;presence_flags) {
    free(self);
    return NULL;
  }
  self-&gt;content = (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *) calloc(
      element_count, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t));
  if (!self-&gt;content) {
    free(self-&gt;presence_flags);
    free(self);
    return NULL;
  }
  return self;
}
</code></pre>

<h4 id="getters_3">Getters</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self) {
  return self-&gt;element_count;
}

bool *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_presence_flags(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self) {
  return self-&gt;presence_flags;
}

&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_content(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self) {
  return self-&gt;content;
}
</code></pre>

<h4 id="computing-the-encoding-length-malbinary_2">Computing the encoding length (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_add_encoding_length_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
</code></pre>

<p>Encoding the list size:</p>
<pre><code class="c">  mal_encoder_add_list_size_encoding_length(encoder, list_size, cursor);
</code></pre>

<p>Encoding the list elements:</p>
<pre><code class="c">  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *element = content[i];
</code></pre>

<p>All the elements of the list may be null. A presence flag is encoded for each of them:</p>
<pre><code class="c">    bool presence_flag = self-&gt;presence_flags[i];
    mal_encoder_add_presence_flag_encoding_length(encoder, presence_flag, cursor);
</code></pre>

<p>Compute the encoding length of a non mandatory enumeration field: cf section 11.1.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="encoding-malbinary_2">Encoding (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_encode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  mal_encoder_t *encoder, void *cursor) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
  rc = mal_encoder_encode_list_size(encoder, cursor, list_size);
  if (rc &lt; 0) return rc;
  for (int i = 0; i &lt; list_size; i++) {
    bool presence_flag = self-&gt;presence_flags[i];
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t element = self-&gt;content[i];
</code></pre>

<p>Encoding a non mandatory enumerated value: cf section 11.2.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="decoding-malbinary_2">Decoding (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_decode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  mal_decoder_t *decoder, void *cursor) {
  int rc = 0;
  rc = mal_decoder_decode_list_size(decoder, cursor, &amp;self-&gt;element_count);
  if (rc &lt; 0) return rc;
  if (self-&gt;element_count == 0) {
    self-&gt;presence_flags = NULL;
    self-&gt;content = NULL;
    return 0;
  }
  self-&gt;presence_flags = (bool *) calloc(self-&gt;element_count, sizeof(bool));
  if (self-&gt;presence_flags == NULL)
    return -1;
  self-&gt;content = (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *) calloc(self-&gt;element_count, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t));
  if (self-&gt;content == NULL) {
    free(self-&gt;presence_flags);
    return -1;
  }
  for (int i = 0; i &lt; self-&gt;element_count; i++) {
</code></pre>

<p>Decoding a non mandatory enumerated value: cf section 11.3.1.</p>
<p>Data are decoded directly into the result structure or pointer (i.e. <code>self-&gt;presence_flags[i]</code> and <code>self-&gt;content[i]</code>).</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="destructor_4">Destructor</h4>
<p>Free the list and its content.</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;enum&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;enum&gt;_list_t **self_p) {
  if ((*self_p)-&gt;element_count &gt; 0) {
    free((*self_p)-&gt;presence_flags);
    free((*self_p)-&gt;content);
  }
  free (*self_p);
  (*self_p) = NULL;
}
</code></pre></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
