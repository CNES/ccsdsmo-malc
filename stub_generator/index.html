<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Stubs de service - MAL C API</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MAL C API</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Accueil</a>
                    </li>
                
                
                
                    <li >
                        <a href="../tutorial/">Tutoriel</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">APIs MAL <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_attributes/">Attributs</a>
</li>

                        
                            
<li >
    <a href="../mal_encoding/">Encodage</a>
</li>

                        
                            
<li >
    <a href="../mal_api/">MAL</a>
</li>

                        
                            
<li >
    <a href="../mal_transport/">Transport</a>
</li>

                        
                            
<li >
    <a href="../area/">Area</a>
</li>

                        
                            
<li >
    <a href="../mal_actor/">Actor</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transports <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_czmq/">MAL/CZMQ</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Générateurs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">Stubs de service</a>
</li>

                        
                            
<li >
    <a href="../malbinary_generator/">MalBinary</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../annexes/">Annexes</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../mal_czmq/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../malbinary_generator/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#generation-du-code-des-stubs">Génération du code des stubs</a></li>
        
            <li><a href="#area">Area</a></li>
        
            <li><a href="#composite">Composite</a></li>
        
            <li><a href="#listes-de-composite">Listes de Composite</a></li>
        
            <li><a href="#listes-denumere">Listes d'énuméré</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="generation-du-code-des-stubs">Génération du code des stubs</h1>
<p>Le code généré est produit pour une mission donnée utilisant un ensemble d'Areas de service.</p>
<p>L'instruction 'calloc' (initialise à '0' les octets alloués) est utilisée pour allouer des structures ou des tableaux de pointeurs afin d'éviter, en cas d'initialisation incomplète, que le destructeur ne libère de la mémoire au travers de faux pointeurs.</p>
<h2 id="area">Area</h2>
<p>Un nouveau projet de type 'zproject' est créé pour chaque Area. Il porte le nom de l'Area en carcatères minuscules : <code>&lt;area&gt;</code></p>
<h3 id="fichier-include-h">Fichier include (.h)</h3>
<p>Un fichier <code>&lt;area&gt;.h</code> est défini pour chaque area.</p>
<h4 id="entete">Entête</h4>
<pre><code class="c">#ifndef __&lt;AREA&gt;_H_INCLUDED__
#define __&lt;AREA&gt;_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<p>Déclaration de la dépendance avec l'Area MAL :</p>
<pre><code class="c">#include &quot;mal.h&quot;
</code></pre>

<p>Pour chaque Area requise :</p>
<pre><code class="c">#include &quot;&lt;required area&gt;.h&quot;
</code></pre>

<h4 id="constantes">Constantes</h4>
<p>Définition des constantes suivantes :</p>
<pre><code class="c">#define &lt;AREA&gt;_AREA_NUMBER &lt;area number&gt;
#define &lt;AREA&gt;_AREA_VERSION &lt;version&gt;
</code></pre>

<p>Pour chaque service :</p>
<pre><code class="c">#define &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER &lt;service number&gt;
</code></pre>

<p>Pour chaque opération de service :</p>
<pre><code class="c">#define &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER &lt;operation number&gt;
</code></pre>

<p>Pour chaque erreur levée par une opération :</p>
<pre><code class="c">#define &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_&lt;ERROR&gt;_ERROR_NUMBER &lt;error number&gt;
</code></pre>

<h4 id="types">Types</h4>
<p>Pour chaque type Enumeration :</p>
<pre><code class="c">typedef enum {
  &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_&lt;ENUMERATED NAME&gt;,
} &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t;
</code></pre>

<p>Pour chaque Composite :</p>
<pre><code class="c">typedef struct _&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t;
</code></pre>

<p>Pour chaque type de donnée défini précédemment (Enumeration, Composite) :</p>
<pre><code class="c">typedef struct _&lt;area&gt;_[&lt;service&gt;_]&lt;type&gt;_list_t
  &lt;area&gt;_[&lt;service&gt;_]&lt;type&gt;_list_t;
</code></pre>

<p>Pour chaque type de donnée, calcul de l'identifiant entier 'short form' (typé 'long') comme défini en section 5.2.3 du livre MAL/SPP :</p>
<pre><code class="c">#define &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;TYPE&gt;_SHORT_FORM &lt;short form&gt;
#define &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;TYPE&gt;_LIST_SHORT_FORM &lt;short form&gt;
</code></pre>

<h4 id="operations">Opérations</h4>
<p>Pour chaque opération de service, excepté si le pattern d'interaction est Publish/Subscribe, les fonctions suivantes sont définies :</p>
<ul>
<li>une fonction d'envoi de message pour l'initiation d'une interaction (première étape) ;</li>
<li>une fonction d'envoi de message pour chaque étape de résultat d'une interaction (seconde étape et suivantes).</li>
</ul>
<p>Initiation d'interaction (excepté Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;first stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message,
  mal_uri_t *provider_uri);
</code></pre>

<p>Résultat d'interaction (excepté Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;result stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message, mal_message_t *result_message,
  bool is_error_message);
</code></pre>

<p>Pour chaque opération de service dont le pattern d'interaction est Publish/Subscribe, des fonctions sont définies pour les étapes suivantes de l'interaction : register, publishRegister, publish, deregister, publishDeregister.</p>
<p>Abonnement (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_register(
  mal_ctx_t *mal_ctx, mal_endpoint_t *endpoint, mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<p>Déclaration de publication (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_register(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<p>Publication (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri,
  long initial_publish_register_tid);
</code></pre>

<p>Désabonnement (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<p>Arrêt de publication (Publish/Subscribe)</p>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri);
</code></pre>

<h3 id="fonctions-dencodage">Fonctions d'encodage</h3>
<p>Pour chaque message d'étape d'interaction de chaque opération de service, les fonctions suivantes sont définies :</p>
<ul>
<li>pour chaque élément de corps de message (identifié par son index), et pour chaque type en cas de polymorphisme (voir 9.4.1) :</li>
<li>une fonction de calcul de taille d'encodage</li>
<li>une fonction d'encodage</li>
<li>pour chaque élément de corps de message (identifié par son index et son type déclaré) :<ul>
<li>une fonction de décodage</li>
</ul>
</li>
</ul>
<p>Les opérations dont le pattern d'interaction est Publish/Subscribe sont traitées de manière particulière. Les trois fonctions d'encodage ne sont générées que pour une seule étape d'interaction fictive, l'étape update, qui correspond aux deux étapes publish et notify, et dont les types de paramètres sont définis dans la spécification de l'opération sous la forme d'un message publishNotify. De plus les paramètres effectivement utilisés dans les fonctions d'encodage sont des listes du type déclaré dans la spécification.</p>
<p>Les fonctions d'encodage liées aux messages d'erreur suivent le schéma général avec les particularités suivantes :</p>
<ul>
<li>le nom des fonctions ne comprend pas d'index,</li>
<li>le nom des fonctions d'encodage comprend systématiquement le suffixe de type &lt;_qftype&gt;,</li>
<li>la fonction de décodage suit le modèle de décodage avec polymorphisme d'Element.</li>
</ul>
<h4 id="calcul-de-taille-dencodage">Calcul de taille d'encodage</h4>
<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, void *encoder, bool presence_flag,
  unsigned char attribute_tag, union mal_attribute_t element,
  unsigned int *encoding_length);
</code></pre>

<p>Sinon, le type de l'élément est connu (même en cas de polymorphisme) :</p>
<ul>
<li>Si l’élément est un Attribut non pointeur, ou un énuméré :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, void *encoder, bool presence_flag,
  &lt;qftype&gt;_t element, unsigned int *encoding_length);
</code></pre>

<ul>
<li>Si l’élément est un Attribut pointeur, un Composite ou une liste :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, void *encoder, &lt;qftype&gt;_[list_]t *element,
  unsigned int *encoding_length);
</code></pre>

<p>Si l'opération est Pub/Sub, la fonction est générée pour le type liste du type déclaré dans la spécification :</p>
<pre><code class="c">int &lt;qfop&gt;_update_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;_list](
    int encoding_format_code, void * encoder,
    &lt;qftype&gt;_list_t *element,
    unsigned int *encoding_length);
</code></pre>

<h4 id="encodage">Encodage</h4>
<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, bool presence_flag, unsigned char attribute_tag,
  union mal_attribute_t element);
</code></pre>

<p>Sinon, le type de l'élément est connu (même en cas de polymorphisme) :</p>
<ul>
<li>Si l’élément est un Attribut non pointeur ou un énuméré :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, bool presence_flag, &lt;qftype&gt;_t element);
</code></pre>

<ul>
<li>Si l’élément est un Attribut pointeur, un Composite, ou une liste :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, &lt;qftype&gt;_[list_]t *element);
</code></pre>

<p>Si l'opération est Pub/Sub, la fonction est générée pour le type liste du type déclaré dans la spécification :</p>
<pre><code class="c">int &lt;qfop&gt;_update_encode[_&lt;index&gt;][_&lt;qftype&gt;_list](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, &lt;qftype&gt;_list_t *element);
</code></pre>

<h4 id="decodage">Décodage</h4>
<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *decoder, bool *presence_flag_res,
  unsigned char *attribute_tag_res, union mal_attribute_t *element_res);
</code></pre>

<p>En cas de polymorphisme d'élément, y compris si l'opération est PubSub (stage = update), et/ou pour un message d'erreur :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_decode[_&lt;index&gt;](
  int encoding_format_code,
  char *bytes, unsigned int *offset, void *decoder,
  mal_element_holder_t *element_holder);
</code></pre>

<p>Si le type de l'élément est connu :</p>
<ul>
<li>Si l’élément est un Attribut non pointeur ou un énuméré :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *decoder, bool *presence_flag_res, &lt;qftype&gt;_t *element_res);
</code></pre>

<ul>
<li>Si l’élément est un Attribut pointeur, un Composite ou une liste :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *decoder, &lt;qftype&gt;_[list_]t **element_res);
</code></pre>

<p>Si l'opération est Pub/Sub, la fonction est générée pour le type liste du type déclaré dans la spécification, excepté en cas de polymorphisme où le cas standard de polymorphisme d'élément est repris.</p>
<pre><code class="c">int &lt;qfop&gt;_update_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *decoder, &lt;qftype&gt;_list_t **element_res);
</code></pre>

<h4 id="fin-du-fichier">Fin du fichier</h4>
<p>Une fonction de test :</p>
<pre><code class="c">void &lt;area&gt;_test(bool verbose);
</code></pre>

<p>Pour chaque structure Composite :</p>
<pre><code class="c">#include &quot;&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;.h&quot;
</code></pre>

<p>Pour chaque liste de Composite :</p>
<pre><code class="c">#include &quot;&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list.h&quot;
</code></pre>

<p>Pour chaque liste d'énuméré:</p>
<pre><code class="c">#include &quot;&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list.h&quot;
</code></pre>

<p>Fin du ficher :</p>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="fichier-source-c">Fichier source (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<p>Pour chaque énumération :</p>
<pre><code class="c">int &lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_NUMERIC_VALUES[] = {
  &lt;numeric value&gt;,
}
</code></pre>

<h4 id="initiation-dinteraction-excepte-publishsubscribe">Initiation d'interaction (excepté Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;first stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message,
  mal_uri_t *provider_uri) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération appelée :</p>
<pre><code class="c">  mal_message_init(init_message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_&lt;IP&gt;,
    MAL_IP_STAGE_&lt;STAGE&gt;);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(
    endpoint, init_message, provider_uri, true);
  return rc;
}
</code></pre>

<h4 id="resultat-dinteraction-excepte-publishsubscribe">Résultat d'interaction (excepté Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_&lt;result stage&gt;(
  mal_endpoint_t *endpoint,
  mal_message_t *init_message,
  mal_message_t *result_message,
  bool is_error_message) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération :</p>
<pre><code class="c">  mal_message_init(result_message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_&lt;IP&gt;,
    MAL_IP_STAGE_&lt;STAGE&gt;);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_return_operation(
    endpoint, init_message, result_message, is_error_message);
  return rc;
}
</code></pre>

<h4 id="abonnement-publishsubscribe">Abonnement (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_register(
  mal_endpoint_t *endpoint, mal_message_t *message, mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération :</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_REGISTER);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="declaration-de-publication-publishsubscribe">Déclaration de publication (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_register(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération :</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_PUBLISH_REGISTER);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="publication-publishsubscribe">Publication (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri,
  long initial_publish_register_tid) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération :</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_PUBLISH);
</code></pre>

<p>Affectation du <code>Transaction Id</code> :</p>
<pre><code class="c">  mal_message_set_transaction_id(message, initial_publish_register_tid);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, false);
  return rc;
}
</code></pre>

<h4 id="desabonnement-publishsubscribe">Désabonnement (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération :</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_DEREGISTER);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="arret-de-publication-publishsubscribe">Arrêt de publication (Publish/Subscribe)</h4>
<pre><code class="c">int &lt;area&gt;_&lt;service&gt;_&lt;operation&gt;_publish_deregister(
  mal_endpoint_t *endpoint,
  mal_message_t *message,
  mal_uri_t *broker_uri) {
  int rc = 0;
</code></pre>

<p>Affectation des champs liés à l'opération :</p>
<pre><code class="c">  mal_message_init(message, &lt;AREA&gt;_AREA_NUMBER,
    &lt;AREA&gt;_AREA_VERSION, &lt;AREA&gt;_&lt;SERVICE&gt;_SERVICE_NUMBER,
    &lt;AREA&gt;_&lt;SERVICE&gt;_&lt;OPERATION&gt;_OPERATION_NUMBER,
    MAL_INTERACTIONTYPE_PUBSUB,
    MAL_IP_STAGE_PUBSUB_PUBLISH_DEREGISTER);
</code></pre>

<p>Envoi du message :</p>
<pre><code class="c">  rc = mal_endpoint_init_operation(endpoint, message, broker_uri, true);
  return rc;
}
</code></pre>

<h4 id="calcul-de-taille-dencodage_1">Calcul de taille d'encodage</h4>
<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, void *encoder, bool presence_flag,
  unsigned char attribute_tag, union mal_attribute_t element,
  unsigned int *encoding_length) {
</code></pre>

<p>Sinon, le type de l'élément est connu (même en cas de polymorphisme) :</p>
<ul>
<li>Si l’élément est un Attribut non pointeur, ou un énuméré :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, void *encoder, bool presence_flag,
  &lt;qftype&gt;_t element, unsigned int *encoding_length) {
</code></pre>

<ul>
<li>Si l’élément est un Attribut pointeur, un Composite ou une liste :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_add_encoding_length[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, void *encoder, &lt;qftype&gt;_[list_]t *element,
  unsigned int *encoding_length) {
```c

Initialisation du code d'erreur :

```c
  int rc = 0;
</code></pre>

<p>Test du type de l'encodage :</p>
<pre><code class="c">  switch (encoding_format_code) {
</code></pre>

<p>Pour chaque format disponible :</p>
<pre><code class="c">  case &lt;FORMAT&gt;_FORMAT_CODE: {
    &lt;format&gt;_encoder_t *&lt;format&gt;_encoder =
      (&lt;format&gt;_encoder_t *) encoder;
</code></pre>

<p>Calcul de la taille d'encodage d'un champ optionnel :
  - Pour le format <code>malbinary</code>, voir section 11.1.1.</p>
<pre><code class="c">    break;
  }
  default:
    rc = -1;
  }
  return rc;
}
</code></pre>

<h4 id="encodage_1">Encodage</h4>
<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, bool presence_flag, unsigned char attribute_tag,
  union mal_attribute_t element) {
</code></pre>

<p>Sinon, le type de l'élément est connu (même en cas de polymorphisme) :
  - Si l’élément est un Attribut non pointeur ou un énuméré :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, bool presence_flag, &lt;qftype&gt;_t element) {
</code></pre>

<ul>
<li>Si l’élément est un Attribut pointeur, un Composite, ou une liste :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_encode[_&lt;index&gt;][_&lt;qftype&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *encoder, &lt;qftype&gt;_[list_]t *element) {
  presence_flag = (element != NULL);
</code></pre>

<p>Initialisation du code d'erreur :</p>
<pre><code class="c">  int rc = 0;
</code></pre>

<p>Test du type de l'encodage :</p>
<pre><code class="c">  switch (encoding_format_code) {
</code></pre>

<p>Pour chaque format disponible :</p>
<pre><code class="c">  case &lt;FORMAT&gt;_FORMAT_CODE: {
    &lt;format&gt;_encoder_t *&lt;format&gt;_encoder =
      (&lt;format&gt;_encoder_t *) encoder;
</code></pre>

<p>Encodage d'un champ optionnel :</p>
<ul>
<li>Pour le format <code>malbinary</code>, voir section 11.2.2.</li>
</ul>
<pre><code class="c">    break;
  }
  default:
    rc = -1;
  }
  return rc;
}
</code></pre>

<h4 id="decodage_1">Décodage</h4>
<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *decoder, bool *presence_flag_res,
  unsigned char *attribute_tag_res, union mal_attribute_t *element_res) {
</code></pre>

<p>En cas de polymorphisme d'élément et/ou pour un message d'erreur :</p>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage|error&gt;_decode[_&lt;index&gt;](
  int encoding_format_code,
  char *bytes, unsigned int *offset, void *decoder,
  mal_element_holder_t *element_holder) {
</code></pre>

<p>Si le type de l'élément est connu :</p>
<ul>
<li>Si l’élément est un Attribut non pointeur ou un énuméré :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes , unsigned int *offset,
  void *decoder, bool *presence_flag_res, &lt;qftype&gt;_t *element_res) {
</code></pre>

<ul>
<li>Si l’élément est un Attribut pointeur, un Composite ou une liste :</li>
</ul>
<pre><code class="c">int &lt;qfop&gt;_&lt;stage&gt;_decode[_&lt;index&gt;](
  int encoding_format_code, char *bytes, unsigned int *offset,
  void *decoder, &lt;qftype&gt;_[list_]t **element_res) {
</code></pre>

<p>Initialisation du code d'erreur :</p>
<pre><code class="c">  int rc = 0;
</code></pre>

<p>Test du type de l'encodage :</p>
<pre><code class="c">  switch (encoding_format_code) {
</code></pre>

<p>Pour chaque format disponible :</p>
<pre><code class="c">  case &lt;FORMAT&gt;_FORMAT_CODE: {
    &lt;format&gt;_decoder_t *&lt;format&gt;_decoder =
      (&lt;format&gt;_encoder_t *) decoder;
      bool presence_flag;
</code></pre>

<p>Décodage d'un champ optionnel :</p>
<ul>
<li>Pour le format <code>malbinary</code>, voir section 11.3.1.</li>
<li>Le décodage est réalisé directement dans la structure ou le pointeur résultat.<ul>
<li>En cas de polymorphisme d'Attribut ou si l’élément est un Attribut non pointeur ou un énuméré : <code>(*presence_flag_res) = presence_flag;</code></li>
<li>En cas de polymorphisme d'élément : <code>mal_element_holder_set_presence_flag(element_holder, presence_flag);</code></li>
</ul>
</li>
</ul>
<p>Fin du décodage.</p>
<pre><code class="c">    break;
  }
  default:
    rc = -1;
  }
  return rc;
}
</code></pre>

<h2 id="composite">Composite</h2>
<h3 id="fichier-include-h_1">Fichier include (.h)</h3>
<pre><code class="c">#ifndef __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_H_INCLUDED__
#define __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<p>Constructeur sans paramètre :</p>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_new(void);
</code></pre>

<p>Pour chaque format d'encodage :</p>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_add_encoding_length_&lt;format&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;format&gt;_encoder_t *encoder,
    unsigned int *encoding_length);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_encode_&lt;format&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;format&gt;_encoder_t *encoder,
    char *bytes, unsigned int *offset);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_decode_&lt;format&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;format&gt;_decoder_t *decoder,
    char *bytes, unsigned int *offset);
</code></pre>

<p>Pour chaque champ du composite (y compris les champs hérités) :</p>
<pre><code class="c">&lt;field type&gt; &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_get_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self);

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_set_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;field type&gt; &lt;field&gt;);
</code></pre>

<p>Si le champ n'est pas un pointeur (valeur NULL interdite) :</p>
<pre><code class="c">bool &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_is_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self);

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, bool is_present);
</code></pre>

<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">unsigned char &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_get_attribute_tag(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self);

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_attribute_tag(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, unsigned char attribute_tag);
</code></pre>

<p>Destructeur :</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **self_p);
</code></pre>

<p>Fonction de test :</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_test(bool verbose);
</code></pre>

<p>Fin du fichier :</p>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="fichier-source-c_1">Fichier source (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<h4 id="definition-de-la-structure">Définition de la structure</h4>
<pre><code class="c">struct _&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t {
</code></pre>

<p>Pour chaque champ (y compris les champs hérités) :</p>
<ul>
<li>En cas de polymorphisme d'Attribut :</li>
<li>Si le champ est optionnel (canBeNull = 'true') : <code>bool &lt;field&gt;_is_present</code>;</li>
<li>Déclaration du champ :</li>
</ul>
<pre><code class="c">  unsigned char &lt;field&gt;_attribute_tag;
  union mal_attribute_t &lt;field&gt;;
</code></pre>

<ul>
<li>Si le champ est de type Attribut non pointeur, ou énuméré :</li>
<li>Si le champ est optionnel (canBeNull = 'true') : <code>bool &lt;field&gt;_is_present;</code></li>
<li>Déclaration du champ : <code>&lt;field type&gt; &lt;field&gt;;</code></li>
<li>Sinon : <code>&lt;field type&gt; *&lt;field&gt;;</code>
Fin de la définition de la structure : <code>};</code></li>
</ul>
<h4 id="constructeur">Constructeur</h4>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_new(void) {
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self =
      (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *) calloc(
          1, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t));
  if (!self)
    return NULL;
  return self;
}
</code></pre>

<h4 id="getters-et-setters">Getters et setters</h4>
<p>Pour chaque champ du composite (y compris les champs hérités) :</p>
<pre><code class="c">&lt;field type&gt; &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_get_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self) {
  return self-&gt;&lt;field&gt;;
}
</code></pre>

<p>La fonction <code>setter</code> n'affecte que la valeur du champ. Le flag de présence ne doit pas être modifié.</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_set_&lt;field&gt;(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, &lt;field type&gt; &lt;field&gt;) {
  self-&gt;&lt;field&gt; = &lt;field&gt;;
}
</code></pre>

<p>Si le champ est optionnel (canBeNull = 'true') et si le champ n'est pas un pointeur :</p>
<pre><code class="c">bool &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_is_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self) {
  return self-&gt;&lt;field&gt;_is_present;
}

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_present(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self, bool is_present) {
  self-&gt;&lt;field&gt;_is_present = is_present;
}
</code></pre>

<p>En cas de polymorphisme d'Attribut :</p>
<pre><code class="c">unsigned char &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_get_attribute_tag(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self) {
  return self-&gt;&lt;field&gt;_attribute_tag;
}

void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_&lt;field&gt;_set_attribute_tag(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
  unsigned char attribute_tag) {
  self-&gt;&lt;field&gt;_attribute_tag = attribute_tag;
}
</code></pre>

<h4 id="calcul-de-la-taille-encodee-malbinary">Calcul de la taille encodée (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_add_encoding_length_malbinary(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
    malbinary_encoder_t *malbinary_encoder,
    unsigned int *encoding_length) {
  int rc = 0;
</code></pre>

<p>Pour chaque champ (les champs hérités en premier) :</p>
<ul>
<li>Si le champ est optionnel, voir section 11.1.1.</li>
<li>Sinon voir section 11.1.2.</li>
</ul>
<pre><code class="c">Fin de la fonction :
  return rc;
}
</code></pre>

<h4 id="encodage-malbinary">Encodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_encode_malbinary(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
    malbinary_encoder_t *malbinary_encoder,
    char *bytes, unsigned int *offset) {
</code></pre>

<p>S'il existe au moins un champ optionnel :</p>
<pre><code class="c">  bool presence_flag;
</code></pre>

<p>Pour chaque champ (les champs hérités en premier) :</p>
<ul>
<li>Si le champ est optionnel :</li>
<li>Si le champ est de type Attribut non pointeur, ou énuméré : </li>
</ul>
<pre><code class="c">presence_flag = self-&gt;&lt;field&gt;_is_present;
</code></pre>

<ul>
<li>Sinon : </li>
</ul>
<pre><code class="c">presence_flag = (self-&gt;&lt;field&gt; != NULL);
</code></pre>

<ul>
<li>Voir section 11.2.1.</li>
<li>Sinon voir section 11.2.2.</li>
</ul>
<p>Fin de l'encodage :</p>
<pre><code class="c">  return rc;
}
</code></pre>

<h4 id="decodage-malbinary">Décodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_decode_malbinary(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
    malbinary_decoder_t *malbinary_decoder,
    char *bytes, unsigned int *offset) {
</code></pre>

<p>S'il existe au moins un champ optionnel : <code>bool presence_flag;</code></p>
<p>Pour chaque champ (les champs hérités en premier) :</p>
<ul>
<li>Si le champ est optionnel, voir section 11.3.1.</li>
<li>Sinon voir section 11.3.2.</li>
</ul>
<p>Le décodage est réalisé directement dans la structure ou le pointeur résultat.
Si le champ est optionnel et de type Attribut abstrait, Attribut non pointeur, ou énuméré :</p>
<pre><code class="c">    self-&gt;&lt;field&gt;_is_present = presence_flag;
</code></pre>

<p>Fin du décodage :</p>
<pre><code class="c">  return rc;
}
</code></pre>

<h4 id="destructeur">Destructeur</h4>
<p>Détruit la structure composite et les structures contenues dans les champs (composites, listes, chaînes de caractères, Blobs).</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **self_p) {
</code></pre>

<p>Pour chaque champ, y compris les champs hérités :</p>
<ul>
<li>En cas de polymorphisme d'Attribut, si le champ est optionnel (canBeNull = 'true') :</li>
</ul>
<pre><code class="c">  if ((*self_p)-&gt;&lt;field&gt;_is_present)
</code></pre>

<ul>
<li>En cas de polymorphisme d'Attribut, destruction du champ optionnel:</li>
</ul>
<pre><code class="c">  mal_attribute_destroy(&amp;(*self_p)-&gt;&lt;field&gt;,
    (*self_p)-&gt;&lt;field&gt;_attribute_tag);
</code></pre>

<ul>
<li>Si le champ est de type Attribut pointeur :</li>
</ul>
<pre><code class="c">  if ((*self_p)-&gt;&lt;field&gt;!= NULL)
    mal_&lt;attribute&gt;_destroy(&amp;(*self_p)-&gt;&lt;field&gt;);
</code></pre>

<ul>
<li>Si le champ est de type Composite :</li>
</ul>
<pre><code class="c">  if ((*self_p)-&gt;&lt;field&gt;!= NULL)
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(&amp;(*self_p)-&gt;&lt;field&gt;);
</code></pre>

<ul>
<li>Si le champ est de type liste :</li>
</ul>
<pre><code class="c">  if ((*self_p)-&gt;&lt;field&gt;!= NULL)
    &lt;area&gt;_[&lt;service&gt;_]&lt;type&gt;_list_destroy(&amp;(*self_p)-&gt;&lt;field&gt;);
</code></pre>

<p>Libération de la mémoire et effacement du pointeur :</p>
<pre><code class="c">  free(*self_p);
  (*self_p) = NULL;
}
</code></pre>

<h2 id="listes-de-composite">Listes de Composite</h2>
<h3 id="fichier-include-h_2">Fichier include (.h)</h3>
<pre><code class="c">#ifndef __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_LIST_H_INCLUDED__
#define __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;COMPOSITE&gt;_LIST_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<h4 id="constructeur_1">Constructeur :</h4>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_new(unsigned int element_count);
</code></pre>

<h4 id="getters">Getters :</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self);

&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **mal_list_get_content(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self);
</code></pre>

<h4 id="pour-chaque-format-dencodage">Pour chaque format d'encodage :</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_add_encoding_length_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  &lt;format&gt;_encoder_t *encoder, unsigned int *encoding_length);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_encode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  &lt;format&gt;_encoder_t *encoder, char *bytes, unsigned int *offset);

int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_decode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *self,
  &lt;format&gt;_decoder_t *decoder, char *bytes, unsigned int *offset);
</code></pre>

<h4 id="destructeur_1">Destructeur :</h4>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t **self_p);
</code></pre>

<h4 id="fonction-de-test">Fonction de test :</h4>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_test(bool verbose);
</code></pre>

<h4 id="fin-du-fichier_1">Fin du fichier :</h4>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="fichier-source-c_2">Fichier source (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<h4 id="constructeur_2">Constructeur</h4>
<p>Définition de la structure :</p>
<pre><code class="c">struct _&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t {
  unsigned int element_count;
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **content;
};
</code></pre>

<p>Constructeur :</p>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_new(unsigned int element_count) {
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self =
    (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *) calloc(1,
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t));
  if (!self) return NULL;
  self-&gt;element_count = element_count;
  self-&gt;content = (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **) calloc(
      element_count, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *));
  return self;
}
</code></pre>

<h4 id="getters_1">Getters</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self) {
  return self-&gt;element_count;
}

&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_get_content(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self) {
  return self-&gt;content;
}
</code></pre>

<h4 id="calcul-de-la-taille-dencodage-malbinary">Calcul de la taille d'encodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_add_encoding_length_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  malbinary_encoder_t *encoder, unsigned int *encoding_length) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
</code></pre>

<p>Encodage de la taille de la liste :</p>
<pre><code class="c">  malbinary_encoder_add_list_size_encoding_length(encoder, list_size,
      encoding_length);
</code></pre>

<p>Tous les éléments de la liste peuvent être nuls. Un champ de présence doit donc être ajouté pour chacun d'eux :</p>
<pre><code class="c">  (*encoding_length) += list_size;
</code></pre>

<p>Encodage des éléments de la liste :</p>
<pre><code class="c">  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *element = content[i];
</code></pre>

<p>Calcul de la taille d'encodage d'un champ Composite optionnel : voir section 11.1.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="encodage-malbinary_1">Encodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_encode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  malbinary_encoder_t *encoder, char *bytes, unsigned int *offset) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
  malbinary_encoder_encode_list_size(encoder, bytes, offset, list_size);
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *element = content[i];
</code></pre>

<p>Encodage d'un Composite optionnel : voir section 11.2.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="decodage-malbinary_1">Décodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_decode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t *self,
  malbinary_decoder_t *decoder, char *bytes, unsigned int *offset) {
  int rc = 0;
  unsigned int list_size;
  malbinary_decoder_decode_list_size(decoder, bytes, offset, &amp;list_size);
  &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **list_content =
    (&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t **) calloc(
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *) * list_size);
  for (int i = 0; i &lt; list_size; i++) {
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_t *element;
</code></pre>

<p>Décodage d'un Composite optionnel : voir section 11.3.1.</p>
<pre><code class="c">    list_content[i] = element;
  }
  self-&gt;element_count = list_size;
  self-&gt;content = list_content;
  return rc;
}
</code></pre>

<h4 id="destructeur_2">Destructeur</h4>
<p>Détruit la liste, son contenu et les éléments de la liste.</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_list_t **self_p) {
  if ((*self_p)-&gt;element_count &gt; 0) {
    for (int i = 0; i &lt; (*self_p)-&gt;element_count; i++) {
      if ((*self_p)-&gt;content[i] != NULL)
        &lt;area&gt;_[&lt;service&gt;_]&lt;composite&gt;_destroy(&amp;(*self_p)-&gt;content[i]);
    }
    free((*self_p)-&gt;content);
  }
  free (*self_p);
  (*self_p) = NULL;
}
</code></pre>

<h2 id="listes-denumere">Listes d'énuméré</h2>
<h3 id="fichier-include-h_3">Fichier include (.h)</h3>
<pre><code class="c">#ifndef __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_LIST_H_INCLUDED__
#define __&lt;AREA&gt;_[&lt;SERVICE&gt;_]&lt;ENUMERATION&gt;_LIST_H_INCLUDED__

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
</code></pre>

<h4 id="constructeur_3">Constructeur :</h4>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_new(
    unsigned int element_count);
</code></pre>

<h4 id="getters_2">Getters :</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self);

bool *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_presence_flags(
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self);

&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *mal_list_get_content(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self);
</code></pre>

<h4 id="pour-chaque-format-dencodage_1">Pour chaque format d'encodage :</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_add_encoding_length_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  &lt;format&gt;_encoder_t *encoder, unsigned int *encoding_length);

int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_encode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  &lt;format&gt;_encoder_t *encoder, char *bytes, unsigned int *offset);

int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_decode_&lt;format&gt;(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *self,
  &lt;format&gt;_decoder_t *decoder, char *bytes, unsigned int *offset);
</code></pre>

<h4 id="destructeur_3">Destructeur :</h4>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t **self_p);
Fonction de test :
void &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_test(bool verbose);
</code></pre>

<h5 id="fin-du-fichier_2">Fin du fichier :</h5>
<pre><code class="c">#ifdef __cplusplus
}
#endif

#endif
</code></pre>

<h3 id="fichier-source-c_3">Fichier source (.c)</h3>
<pre><code class="c">#include &quot;&lt;area&gt;.h&quot;
</code></pre>

<h4 id="constructeur_4">Constructeur</h4>
<p>Déclaration de la structure :</p>
<pre><code class="c">struct _&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t {
  unsigned int element_count;
  bool *presence_flags;
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *content;
};
</code></pre>

<p>Constructeur :</p>
<pre><code class="c">&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_new(
    unsigned int element_count) {
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self =
    (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *) calloc(1,
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t));
  if (!self) return NULL;
  self-&gt;element_count = element_count;
  if (element_count == 0) return self;
  self-&gt;presence_flags = (bool *) calloc(element_count, sizeof(bool));
  if (!self-&gt;presence_flags) {
    free(self);
    return NULL;
  }
  self-&gt;content = (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *) calloc(
      element_count, sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t));
  if (!self-&gt;content) {
    free(self-&gt;presence_flags);
    free(self);
    return NULL;
  }
  return self;
}
</code></pre>

<h4 id="getters_3">Getters</h4>
<pre><code class="c">unsigned int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_element_count(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self) {
  return self-&gt;element_count;
}

bool *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_presence_flags(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self) {
  return self-&gt;presence_flags;
}

&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t
  *&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_get_content(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self) {
  return self-&gt;content;
}
</code></pre>

<h4 id="calcul-de-la-taille-dencodage-malbinary_1">Calcul de la taille d'encodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_add_encoding_length_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  malbinary_encoder_t *encoder, unsigned int *encoding_length) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
</code></pre>

<p>Encodage de la taille de la liste :</p>
<pre><code class="c">  malbinary_encoder_add_list_size_encoding_length(encoder, list_size,
      encoding_length);
</code></pre>

<p>Tous les éléments de la liste peuvent être nuls. Un champ de présence doit donc être ajouté pour chacun d'eux :</p>
<pre><code class="c">  (*encoding_length) += list_size * MALBINARY_PRESENCE_FLAG_SIZE;
</code></pre>

<p>Encodage des éléments de la liste :</p>
<pre><code class="c">  bool *presence_flags = self-&gt;presence_flags;
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    bool presence_flag = presence_flags[i];
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t element = content[i];
</code></pre>

<p>Calcul de la taille d'encodage d'un champ énuméré optionnel : voir section 11.1.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="encodage-malbinary_2">Encodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_encode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  malbinary_encoder_t *encoder, char *bytes, unsigned int *offset) {
  int rc = 0;
  unsigned int list_size = self-&gt;element_count;
  malbinary_encoder_encode_list_size(encoder, bytes, offset, list_size);
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *content = self-&gt;content;
  for (int i = 0; i &lt; list_size; i++) {
    bool presence_flag = presence_flags[i];
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *element = content[i];
</code></pre>

<p>Encodage d'un énuméré optionnel : voir section 11.2.1.</p>
<pre><code class="c">  }
  return rc;
}
</code></pre>

<h4 id="decodage-malbinary_2">Décodage (<code>malbinary</code>)</h4>
<pre><code class="c">int &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_decode_malbinary(
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_list_t *self,
  malbinary_decoder_t *decoder, char *bytes, unsigned int *offset) {
  int rc = 0;
  unsigned int list_size;
  malbinary_decoder_decode_list_size(decoder, bytes, offset, &amp;list_size);
  bool *presence_flags = (bool *) malloc(sizeof(bool) * list_size);
  &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *list_content =
    &lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *list_content =
    (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t *) malloc(
      sizeof(&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t) * list_size);
  for (int i = 0; i &lt; list_size; i++) {
    bool presence_flag;
    int element;
</code></pre>

<p>Décodage d'un énuméré optionnel : voir section 11.3.1.</p>
<pre><code class="c">    presence_flags[i] = presence_flag;
    list_content[i] = (&lt;area&gt;_[&lt;service&gt;_]&lt;enumeration&gt;_t) element;
  }
  self-&gt;element_count = list_size;
  self-&gt; presence_flags = presence_flags;
  self-&gt;content = list_content;
  return rc;
}
</code></pre>

<h4 id="destructeur_4">Destructeur</h4>
<p>Détruit la liste et son contenu (tableau).</p>
<pre><code class="c">void &lt;area&gt;_[&lt;service&gt;_]&lt;enum&gt;_list_destroy(
    &lt;area&gt;_[&lt;service&gt;_]&lt;enum&gt;_list_t **self_p) {
  if ((*self_p)-&gt;element_count &gt; 0) {
    free((*self_p)-&gt;presence_flags);
    free((*self_p)-&gt;content);
  }
  free (*self_p);
  (*self_p) = NULL;
}
</code></pre></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
