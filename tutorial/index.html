<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Tutoriel - MAL C API</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MAL C API</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Accueil</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Tutoriel</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">APIs MAL <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_attributes/">Attributs</a>
</li>

                        
                            
<li >
    <a href="../mal_encoding/">Encodage</a>
</li>

                        
                            
<li >
    <a href="../mal_api/">MAL</a>
</li>

                        
                            
<li >
    <a href="../mal_transport/">Transport</a>
</li>

                        
                            
<li >
    <a href="../area/">Area</a>
</li>

                        
                            
<li >
    <a href="../mal_actor/">Actor</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transports <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../mal_czmq/">MAL/CZMQ</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Générateurs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../stub_generator/">Stubs de service</a>
</li>

                        
                            
<li >
    <a href="../malbinary_generator/">MalBinary</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../annexes/">Annexes</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../mal_attributes/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#exemple-simple-dapplication-mal">Exemple simple d'application MAL</a></li>
        
            <li><a href="#composant-consumer">Composant « consumer »</a></li>
        
            <li><a href="#composant-provider">Composant « provider »</a></li>
        
            <li><a href="#lancement-de-lapplication">Lancement de l'application</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="exemple-simple-dapplication-mal">Exemple simple d'application MAL</h1>
<p>Cette section met en pratique les concepts de l'API MAL en C en programmant une application MAL très simple qui s'exécute dans une unique fonction 'main'.</p>
<p>Deux types de code sont distingués :</p>
<ul>
<li>le code des composants constituant l'application. Dans cet exemple, deux composants sont créés. Pour simplifier l'application, chaque composant est limité à un seul rôle : « provider » ou « consumer » de service. Un service de test très simple est défini dans une area de service nommée « TestArea » (voir section 14.1).</li>
<li>le code de lancement de l'application</li>
</ul>
<p>Le code des composants ne dépend que de l'API MAL et de l'API générée à partir de la définition de TestArea.</p>
<p>Le code de lancement de l'application (fonction 'main') dépend de l'API MAL et également de l'API de transport 'malzmq'.</p>
<p>Cet exemple utilise le modèle d'exécution des acteurs CZMQ.</p>
<p>Seul le code non généré est présenté dans les sections suivantes.</p>
<h2 id="composant-consumer">Composant « consumer »</h2>
<p>Dépendances avec l'API MAL et l'API du service (code généré) :</p>
<pre><code>#include "mal.h"
#include "testarea.h"
</code></pre>
<h3 id="constructeur">Constructeur</h3>
<p>Dans cet exemple de code, tous les paramètres nécessaires au fonctionnement du consumer sont  donnés lors de sa création :</p>
<ul>
<li>le end-point du consumer</li>
<li>l'URI du provider (auquel le consumer s'adresse)</li>
<li>les paramètres de l'entête de message MAL, par exemple l'identifiant d'authentification</li>
<li>l'identifiant du format d'encodage</li>
<li>les contextes d'encodage (non typés pour éviter la dépendance avec 'malbinary')</li>
</ul>
<p>Déclaration :</p>
<pre><code class="c">    simple_app_myconsumer_t *simple_app_myconsumer_new(
      mal_endpoint_t *endpoint,
      mal_uri_t *provider_uri,
      mal_blob_t *authentication_id,
      mal_qoslevel_t qoslevel,
      mal_uinteger_t priority,
      mal_identifier_list_t *domain,
      mal_identifier_t *network_zone,
      mal_sessiontype_t session,
      mal_identifier_t *session_name,
      int encoding_format_code,
      void *encoder, void *decoder);
</code></pre>

<h3 id="implementation">Implémentation</h3>
<p>Dans cet exemple un acteur CZMQ lié au composant « consumer » initie une interaction MAL lors de son démarrage. La signature doit être conforme à la fonction virtuelle de l'acteur définie dans l'API CZMQ :</p>
<pre><code class="c">    void simple_app_myconsumer_run(zsock_t *pipe, void *self) {
</code></pre>

<p>La référence <code>self</code> est castée pour obtenir l'état de l'acteur (le « consumer »):</p>
<pre><code class="c">    simple_app_myconsumer_t *consumer = (simple_app_myconsumer_t *) self;
</code></pre>

<p>L'URI du provider est récupérée à partir de l'état du consumer :</p>
<pre><code class="c">    mal_uri_t *uri_to = consumer-&gt;provider_uri;
</code></pre>

<p>Une structure de donnée <code>TestComposite</code> est instanciée :</p>
<pre><code class="c">    testarea_testservice_testcomposite_t *testcomposite =
      testarea_testservice_testcomposite_new();
</code></pre>

<p>Allocation d'une String MAL à partir de la chaîne statique « hello world » :</p>
<pre><code class="c">    mal_string_t *str = mal_string_new(&quot;hello world&quot;);
</code></pre>

<p>Affectation du champ <code>stringField</code> :</p>
<pre><code class="c">    testarea_testservice_testcomposite_set_stringfield(testcomposite, str);
</code></pre>

<p>A partir de ce point la structure testcomposite est responsable de la libération de la String str. Réciproquement l'usage de la String n'est possible que tant que la structure n'a pas été libérée.</p>
<p>Le champ <code>intField</code> peut être nul. Il est donc nécessaire d'affecter le flag de présence pour ce champ (à la valeur <code>true</code>), puis d'affecter la valeur du champ (<code>10</code>) :</p>
<pre><code class="c">    testarea_testservice_testcomposite_intfield_set_present(
      testcomposite,
      true);
    testarea_testservice_testcomposite_set_intfield(testcomposite, 10);
</code></pre>

<p>Une structure de donnée <code>List&lt;MAL::String&gt;</code> est instanciée :</p>
<pre><code class="c">    mal_string_list_t *string_list = mal_string_list_new(2);
    mal_string_t **string_list_content =
      mal_string_list_get_content(string_list);
    string_list_content[0] = mal_string_new(&quot;list-element-1&quot;);
    string_list_content[1] = mal_string_new(&quot;list-element-2&quot;);
</code></pre>

<p>Pour tester le polymorphisme, une structure <code>TestFinalCompositeA</code> est instanciée (elle hérite de <code>TestAbstractComposite</code>) :</p>
<pre><code class="c">    testarea_testservice_testfinalcompositea_t *testfinalcompositea =
      testarea_testservice_testfinalcompositea_new();
    testarea_testservice_testfinalcompositea_set_intfield(
      testfinalcompositea, 20);
    testarea_testservice_testfinalcompositea_set_intfield2(
      testfinalcompositea, 30);
</code></pre>

<p>La taille du corps de message encodé est calculée en faisant appel à une fonction générée pour chaque élément du corps de message.</p>
<p>Calcul de la taille d'encodage du premier élément (index '0' pour l'initiation de l'étape <code>send</code> de l'opération <code>testSend</code>) :</p>
<pre><code class="c">    unsigned int body_length = 0;
    rc = testarea_testservice_testsend_send_add_encoding_length_0(
      consumer-&gt;encoding_format_code,
      consumer-&gt;encoder, testcomposite, &amp;body_length);
</code></pre>

<p>Calcul de la taille d'encodage du deuxième élément (index '1') :</p>
<pre><code class="c">    rc = testarea_testservice_testsend_send_add_encoding_length_1(
      consumer-&gt;encoding_format_code,
      consumer-&gt;encoder, string_list, &amp;body_length);
</code></pre>

<p>Calcul de la taille d'encodage du troisième élément (index '2'), avec polymorphisme :</p>
<pre><code class="c">    rc = testarea_testservice_testsend_send_add_encoding_length_2_testarea_
    testservice_testfinalcompositea(
      consumer-&gt;encoding_format_code,
      consumer-&gt;encoder, testfinalcompositea, &amp;body_length);
</code></pre>

<p>Création d'un message MAL, avec passage en paramètre :</p>
<ul>
<li>des champs de header MAL contenus dans l'état du Handler</li>
<li>de la taille d'encodage du corps de message : <code>body_length</code></li>
</ul>
<pre><code class="c">    mal_message_t *message = mal_message_new(uri_to,
      consumer-&gt;authentication_id,
      consumer-&gt;qoslevel, consumer-&gt;priority, consumer-&gt;domain,
      consumer-&gt;network_zone, consumer-&gt;session, consumer-&gt;session_name,
      body_length);
</code></pre>

<p>Encodage du premier élément (index '0') :</p>
<pre><code class="c">    unsigned int offset = mal_message_get_body_offset(message);
    char *bytes = mal_message_get_body(message);
    rc = testarea_testservice_testsend_send_encode_0(
      consumer-&gt;encoding_format_code, bytes, &amp;offset,
      consumer-&gt;encoder, testcomposite);
</code></pre>

<p>Encodage du deuxième élément (index '1') :</p>
<pre><code class="c">    rc = testarea_testservice_testsend_send_encode_1(
      consumer-&gt;encoding_format_code, bytes, &amp;offset,
      consumer-&gt;encoder, string_list);
</code></pre>

<p>Encodage du troisième élément (index '2') :</p>
<pre><code class="c">    rc = testarea_testservice_testsend_send_encode_2_testarea_testservice_
    testfinalcompositea(
      consumer-&gt;encoding_format_code, bytes, &amp;offset,
      consumer-&gt;encoder, testfinalcompositea);
</code></pre>

<p>Envoi du message (initiation de l'étape <code>send</code> de l'opération <code>testSend</code>) :</p>
<pre><code class="c">    rc = testarea_testservice_testsend_send(
      consumer-&gt;endpoint,
      message,
      consumer-&gt;provider_uri);
</code></pre>

<p>Destruction des données allouées :</p>
<pre><code class="c">    testarea_testservice_testcomposite_destroy(&amp;testcomposite);
    mal_string_list_destroy(&amp;string_list);
    testarea_testservice_testfinalcompositea_destroy(&amp;testfinalcompositea);
</code></pre>

<h2 id="composant-provider">Composant « provider »</h2>
<p>Dépendances avec l'API MAL et l'API du service (code généré) :</p>
<pre><code>#include "mal.h"
#include "testarea.h"
</code></pre>
<h3 id="constructeur_1">Constructeur</h3>
<p>Dans cet exemple de code, tous les paramètres nécessaires au fonctionnement du provider sont  donnés lors de sa création :
  - le end-point MAL du provider
  - l'identifiant du format d'encodage
  - les contextes d'encodage (non typés pour éviter la dépendance avec 'malbinary')</p>
<p>Déclaration :</p>
<pre><code>simple_app_myprovider_t simple_app_myprovider_new(
  mal_endpoint_t *endpoint,
  int encoding_format_code,
  void *encoder, void *decoder);
</code></pre>
<h3 id="implementation_1">Implémentation</h3>
<p>Dans cet exemple un acteur CZMQ est lié au composant « provider » et enregistre un handler  lors de son démarrage. La signature doit être conforme à la fonction virtuelle de l'acteur définie dans l'API CZMQ :</p>
<pre><code>void simple_app_myprovider_run(zsock_t *pipe, void *self) {
Afin de faciliter la distribution des messages un routeur est créé :
mal_routing_t *router = mal_routing_new(self-&gt;endpoint, self);
</code></pre>
<p>Puis pour permettre son fonctionnement un handler correspondant au rôle provider de l'interaction Send doit être dynamiquement enregistré au près de l'acteur :</p>
<pre><code>rc = mal_routing_register_provider_send_handler(
     router,
     TESTAREA_AREA_NUMBER,
     TESTAREA_AREA_VERSION,
     TESTAREA_TESTSERVICE_SERVICE_NUMBER,
     TESTAREA_TESTSERVICE_TESTSEND_OPERATION_NUMBER,
     simple_app_myprovider_testarea_testservice_testsend);
</code></pre>
<p>Ces appels sont réalisés dans la fonction d'initialisation de l'acteur.
Enfin l'acteur se met en attente de réception d'un message sur le end-point :</p>
<pre><code>mal_message_t *message = NULL;
rc = mal_endpoint_recv_message(self-&gt;endpoint, &amp;message);
</code></pre>
<p>Puis il demande l'activation du handler correspondant au travers du routeur et détruit ce message si il n'a pu être traité par aucun handler :</p>
<pre><code>if (message != NULL) {
  rc = mal_routing_handle(router, message);
  if (rc != 0)
    mal_message_destroy(
      message,
      mal_endpoint_get_mal_ctx(self-&gt;endpoint));
</code></pre>
<p>Le handler peut alors réagir à la réception du message MAL correspondant via la fonction correspondante dont la signature doit être conforme à la fonction virtuelle de Handler définie dans l'API MAL (voir section 7.6.1). Le code de dispatch renvoie donc vers une fonction spécifique au traitement de l'opération 'testSend'. :</p>
<pre><code>int simple_app_myprovider_testarea_testservice_testsend(
  void *self,
  mal_ctx_t *mal_ctx,
  mal_endpoint_t *mal_endpoint,
  mal_message_t *message) {
</code></pre>
<p>La référence 'self' est castée pour obtenir l'état du router commun à tous les handlers enregistrés (le « provider »):</p>
<pre><code>  simple_app_myprovider_t *provider = (simple_app_myprovider_t *) self;
</code></pre>
<p>Décodage du premier élément du corps de message :</p>
<pre><code>  testarea_testservice_testcomposite_t *parameter_0 = NULL;
  unsigned int offset = mal_message_get_body_offset(message);
  char *bytes = mal_message_get_body(message);
  rc = testarea_testservice_testsend_send_decode_0(
    provider-&gt;encoding_format_code, bytes, &amp;offset,
    provider-&gt;decoder, &amp;parameter_0);
  if (rc &lt; 0) {
    // destruction des paramètres décodés (voir plus bas)
    return rc;
  }
</code></pre>
<p>Décodage du deuxième élément du corps de message :</p>
<pre><code>  mal_string_list_t *parameter_1;
  rc = testarea_testservice_testsend_send_decode_1(
    provider-&gt;encoding_format_code, bytes, &amp;offset,
    provider-&gt;decoder, &amp;parameter_1);
  if (rc &lt; 0) {
    // destruction des paramètres décodés (voir plus bas)
    return rc;
  }
</code></pre>
<p>Décodage du troisième élément du corps de message (avec polymorphisme) :</p>
<pre><code>  mal_element_holder_t parameter_2;
  rc = testarea_testservice_testsend_send_decode_2(
    provider-&gt;encoding_format_code, bytes, &amp;offset,
    provider-&gt;decoder, &amp;parameter_2);
  if (rc &lt; 0) {
    // destruction des paramètres décodés (voir plus bas)
    return rc;
  }
</code></pre>
<p>La valeur des paramètres décodés peut être nulle.</p>
<p>Le troisième paramètre nécessite de tester la valeur du 'short_form' avant de faire le cast :</p>
<pre><code>if (parameter_2.presence_flag &amp;&amp; parameter_2.short_form ==
    TESTAREA_TESTSERVICE_TESTFINALCOMPOSITEA_SHORT_FORM) {
  testarea_testservice_testfinalcompositea_t *testfinalcompositea =
    (testarea_testservice_testfinalcompositea_t *) parameter_2;
  ...
</code></pre>
<p>Destruction de la donnée :</p>
<pre><code>  testarea_testservice_testfinalcompositea_destroy(&amp;testfinalcompositea);
</code></pre>
<p>Fin du traitement du troisième paramètre :</p>
<pre><code>}
</code></pre>
<p>Enfin, les premier et deuxième paramètres sont détruits :</p>
<pre><code>  testarea_testservice_testcomposite_destroy(&amp;parameter_0);
  mal_string_list_destroy(&amp;parameter_1);
</code></pre>
<p>Le message est également détruit :</p>
<pre><code>mal_message_destroy(&amp;message, mal_ctx);
</code></pre>
<h2 id="lancement-de-lapplication">Lancement de l'application</h2>
<p>Les dépendances nécessaires sont :
  - l'API MAL
  - l'API du transport MALZMQ</p>
<pre><code>#include "mal.h"
#include "malzmq.h"
</code></pre>
<h3 id="creation-dun-contexte-mal">Création d'un contexte MAL :</h3>
<pre><code>mal_ctx_t *mal_ctx = mal_ctx_new();
</code></pre>
<p>Les contextes d'encodage et de décodage sont créés pour le format 'malbinary'. Le format 'varint' n'est pas utilisé et le flag 'verbose' est activé :</p>
<pre><code>malbinary_encoder_t *encoder = malbinary_encoder_new(false, true);
malbinary_decoder_t *decoder = malbinary_decoder_new(false, true);
</code></pre>
<p>Configuration du catalogue de mapping (cf 12.1.3) et des flags de présence (cf 12.1.2) dans le header MALZMQ : dans l'exemple il n'y a pas de catalogue et tous les champs optionnels sont présents (encodés) dans le header.</p>
<pre><code>malzmq_header_t *malzmq_header = malzmq_header_new(NULL, true, 0, true, NULL,
  NULL, NULL, NULL);
</code></pre>
<p>Un contexte de transport MALZMQ est créé à partir du contexte MAL. Une fonction de mapping d'URI est fournie (cf 12.2). Dans l'exemple on utilise la fonction par défaut. L'adresse et le port d'écoute de connexions entrantes sont 'localhost' et 5555.</p>
<pre><code>malzmq_ctx_t *malzmq_ctx = malzmq_ctx_new(
  mal_ctx, NULL,
  "localhost", "5555",
  malzmq_header,
  encoder, decoder,
  true);
</code></pre>
<h3 id="creation-du-provider">Création du provider</h3>
<p>Allocation d'une URI MALZMQ. Un nom unique (dans le contexte MALZMQ) est passé en paramètre.</p>
<pre><code>mal_uri_t *provider_uri =
  mal_ctx_create_uri(mal_ctx, "simple_app/myprovider");
</code></pre>
<p>Création du end-point du provider avec les paramètres suivants :
  - la référence du contexte MAL,
  - l'URI du provider allouée précédemment.</p>
<pre><code>mal_endpoint_t *provider_endpoint = mal_endpoint_new(mal_ctx, provider_uri);
</code></pre>
<p>Instanciation du provider avec la référence du end-point correspondant et les paramètres liés à l'encodage :</p>
<pre><code>simple_app_myprovider_t *provider = simple_app_myprovider_new(
  provider_endpoint,
  MALBINARY_FORMAT_CODE,
  encoder, decoder);
</code></pre>
<p>L'enregistrement du handler de l'opération sera effectuée dans la fonction run de l'acteur CZMQ (voir section 4.2.2).</p>
<h3 id="creation-du-consumer">Création du consumer</h3>
<p>Allocation d'une URI MALZMQ. Un nom unique (dans le contexte MALZMQ) est passé en paramètre.</p>
<pre><code>mal_uri_t *consumer_uri =
  mal_ctx_create_uri(mal_ctx, "simple_app/myconsumer");
</code></pre>
<p>Création du end-point du consumer avec les paramètres suivants :
  - la référence du contexte MAL,
  - l'URI du consumer allouée précédemment.</p>
<pre><code>mal_endpoint_t *consumer_endpoint = mal_endpoint_new(mal_ctx, consumer_uri);
</code></pre>
<p>L'instanciation du consumer nécessite de déterminer certains paramètres du Header de message MAL :</p>
<pre><code>mal_blob_t *authentication_id = mal_blob_new(0);
mal_qoslevel_t qoslevel = MAL_QOSLEVEL_ASSURED;
mal_uinteger_t priority = 4;
mal_identifier_list_t *domain = mal_identifier_list_new(0);
mal_identifier_t *network_zone = mal_identifier_new("Network Zone");
mal_sessiontype_t session = MAL_SESSIONTYPE_LIVE;
mal_identifier_t *session_name = mal_identifier_new("LIVE");

simple_app_myconsumer_t *consumer =
simple_app_myconsumer_new(provider_uri,
  authentication_id, qoslevel, priority, domain, network_zone, session,
  session_name, MALBINARY_FORMAT_CODE, encoder, decoder);
</code></pre>
<p>Les mêmes contextes d'encodage et de décodage que ceux du provider sont utilisés par le consumer.</p>
<p>L'opération Send ne nécessitant pas de handler coté consumer il n'y aura pas d'enregistrement de handler pour ce consumer.</p>
<h3 id="lancement-et-fin-de-lapplication">Lancement et fin de l'application</h3>
<p>Création du provider et de l'acteur ZMQ correspondant :</p>
<pre><code>provider = simple_app_create_provider(
  verbose,
  mal_ctx, provider_uri,
  encoder, decoder);
zactor_t *provider_actor = zactor_new(simple_app_myprovider_run, provider);
</code></pre>
<p>Création du consumer et de l'acteur ZMQ correspondant :</p>
<pre><code>consumer = simple_app_create_consumer(
  verbose,
  mal_ctx, provider_uri,
  encoder, decoder);
zactor_t *consumer_actor = zactor_new(simple_app_myconsumer_run, consumer);
</code></pre>
<p>Démarrage du contexte MALZMQ (appel bloquant jusqu'à l'interruption du contexte) :</p>
<pre><code>  malzmq_ctx_start(malzmq_ctx);
</code></pre>
<p>Destruction des contextes MAL et MALZMQ :</p>
<pre><code>  mal_ctx_destroy(&amp;mal_ctx);
  malzmq_ctx_destroy(&amp;malzmq_ctx);
</code></pre></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
